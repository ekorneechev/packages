 .gitignore                                         |    3 +
 ChangeLog                                          |    8 +-
 INSTALL                                            |    3 +-
 Makefile.in                                        |   12 +-
 acconfig.h                                         |  822 ------
 aclocal.m4                                         |    1 +
 agent/Makefile.in                                  |    7 +-
 agent/agent_handler.c                              |   28 +-
 agent/agent_index.c                                |    2 -
 agent/agent_registry.c                             |   13 +-
 agent/agent_trap.c                                 |   24 +
 agent/helpers/baby_steps.c                         |   16 +-
 agent/helpers/bulk_to_next.c                       |   17 +-
 agent/helpers/cache_handler.c                      |   55 +-
 agent/helpers/debug_handler.c                      |   12 +-
 agent/helpers/instance.c                           |   79 +-
 agent/helpers/null.c                               |   20 +
 agent/helpers/old_api.c                            |   57 +-
 agent/helpers/read_only.c                          |   19 +-
 agent/helpers/row_merge.c                          |   29 +-
 agent/helpers/scalar.c                             |   54 +-
 agent/helpers/scalar_group.c                       |   33 +-
 agent/helpers/serialize.c                          |   29 +-
 agent/helpers/snmp_get_statistic.c                 |   25 +-
 agent/helpers/table.c                              |   33 +-
 agent/helpers/table_array.c                        |   23 +-
 agent/helpers/table_container.c                    |   18 +-
 agent/helpers/table_data.c                         |   31 +-
 agent/helpers/table_dataset.c                      |   23 +-
 agent/helpers/table_iterator.c                     |   23 +-
 agent/helpers/table_row.c                          |   18 +-
 agent/helpers/table_tdata.c                        |   22 +-
 agent/helpers/watcher.c                            |  188 +-
 agent/mibgroup/Rmon/alarm.c                        |   16 +-
 agent/mibgroup/Rmon/alarmTable.c                   |   11 +-
 agent/mibgroup/Rmon/event.h                        |    8 +
 agent/mibgroup/agent/extend.c                      |   31 +-
 agent/mibgroup/agent/nsTransactionTable.c          |    2 -
 agent/mibgroup/agent/nsVacmAccessTable.h           |    1 +
 agent/mibgroup/agentx/client.c                     |    2 -
 agent/mibgroup/agentx/master.c                     |    2 +-
 agent/mibgroup/agentx/master_admin.c               |    4 +-
 agent/mibgroup/agentx/protocol.c                   |    2 +-
 agent/mibgroup/agentx/subagent.c                   |    3 +-
 agent/mibgroup/agentx/subagent.h                   |    9 +
 agent/mibgroup/deliver/deliverByNotify.c           |    2 +-
 agent/mibgroup/disman/event/mteEvent.c             |    3 +-
 agent/mibgroup/disman/event/mteScalars.c           |    4 +-
 agent/mibgroup/disman/event/mteTrigger.c           |    1 -
 agent/mibgroup/disman/event/mteTrigger.h           |    1 +
 agent/mibgroup/disman/expr/expExpression.c         |    2 +-
 agent/mibgroup/disman/expr/expExpressionTable.c    |    3 +-
 agent/mibgroup/disman/expr/expObjectTable.c        |    7 +-
 agent/mibgroup/disman/expr/expValue.c              |   27 +-
 agent/mibgroup/disman/expr/expValueTable.c         |    2 +
 agent/mibgroup/disman/expression/expErrorTable.c   |    3 -
 .../disman/expression/expExpressionTable.c         |   11 +-
 .../disman/expression/expExpressionTable.h         |    2 +
 agent/mibgroup/disman/expression/expObjectTable.c  |   10 +-
 agent/mibgroup/disman/expression/expObjectTable.h  |    3 +
 agent/mibgroup/disman/expression/expValueTable.c   |  856 +++---
 agent/mibgroup/disman/expression/expValueTable.h   |   18 +-
 agent/mibgroup/disman/mteEventTable.c              |    2 +-
 agent/mibgroup/disman/mteObjectsTable.c            |    2 +-
 agent/mibgroup/disman/mteTriggerBooleanTable.c     |    6 -
 agent/mibgroup/disman/mteTriggerDeltaTable.c       |    7 -
 agent/mibgroup/disman/mteTriggerExistenceTable.c   |    8 -
 agent/mibgroup/disman/mteTriggerTable.c            |    7 +-
 agent/mibgroup/disman/mteTriggerTable.h            |    2 +
 agent/mibgroup/disman/mteTriggerThresholdTable.c   |    5 -
 agent/mibgroup/disman/nslookup/lookupCtlTable.c    |   27 +-
 agent/mibgroup/disman/nslookup/lookupCtlTable.h    |    3 +
 .../mibgroup/disman/nslookup/lookupResultsTable.c  |   21 +-
 agent/mibgroup/disman/ping/pingCtlTable.c          |   26 +
 agent/mibgroup/disman/ping/pingCtlTable.h          |   18 +-
 agent/mibgroup/disman/ping/pingProbeHistoryTable.c |   18 +-
 agent/mibgroup/disman/ping/pingResultsTable.c      |   17 +-
 .../disman/traceroute/traceRouteCtlTable.c         | 2983 ++++++++++----------
 .../disman/traceroute/traceRouteCtlTable.h         |    1 -
 .../disman/traceroute/traceRouteHopsTable.c        |   31 +-
 .../traceroute/traceRouteProbeHistoryTable.c       |   28 +-
 .../disman/traceroute/traceRouteResultsTable.c     |   26 +-
 .../disman/traceroute/traceRouteResultsTable.h     |    5 +
 .../etherlike-mib/data_access/dot3stats_linux.c    |    3 +-
 .../dot3StatsTable/dot3StatsTable_data_access.c    |    1 +
 agent/mibgroup/examples/example.c                  |    2 +-
 agent/mibgroup/examples/netSnmpHostsTable.c        |    2 +
 agent/mibgroup/examples/netSnmpHostsTable_access.c |    4 +-
 .../examples/netSnmpHostsTable_checkfns_local.c    |    1 +
 agent/mibgroup/examples/ucdDemoPublic.c            |    6 +-
 agent/mibgroup/hardware/cpu/cpu.c                  |    2 +-
 agent/mibgroup/hardware/cpu/cpu_linux.c            |   13 +-
 agent/mibgroup/hardware/cpu/cpu_sysctl.c           |    5 +-
 agent/mibgroup/hardware/fsys/fsys_getfsstats.c     |    3 +
 agent/mibgroup/hardware/fsys/fsys_mntent.c         |   13 +-
 agent/mibgroup/hardware/fsys/hw_fsys.c             |    4 +-
 agent/mibgroup/hardware/fsys/hw_fsys_private.h     |    2 +
 agent/mibgroup/hardware/fsys/mnttypes.h            |    3 +
 agent/mibgroup/hardware/fsys/mounts.h              |    3 +
 agent/mibgroup/hardware/memory/hw_mem.c            |    4 +-
 agent/mibgroup/hardware/memory/memory_linux.c      |    1 +
 agent/mibgroup/hardware/sensors/dummy_sensors.c    |    1 +
 agent/mibgroup/hardware/sensors/hw_sensors.c       |    3 +-
 .../mibgroup/hardware/sensors/hw_sensors_private.h |    2 +
 agent/mibgroup/hardware/sensors/kstat_sensors.c    |    1 +
 agent/mibgroup/hardware/sensors/lmsensors_v2.c     |    1 +
 agent/mibgroup/hardware/sensors/lmsensors_v3.c     |   24 +-
 agent/mibgroup/hardware/sensors/picld_sensors.c    |    1 +
 agent/mibgroup/host/data_access/swinst.c           |    7 +-
 agent/mibgroup/host/data_access/swinst_apt.c       |    1 +
 agent/mibgroup/host/data_access/swinst_darwin.c    |    1 +
 agent/mibgroup/host/data_access/swinst_null.c      |    1 +
 agent/mibgroup/host/data_access/swinst_pkginfo.c   |    5 +-
 agent/mibgroup/host/data_access/swinst_private.h   |    3 +
 agent/mibgroup/host/data_access/swinst_rpm.c       |    1 +
 agent/mibgroup/host/data_access/swrun.c            |   37 +-
 agent/mibgroup/host/data_access/swrun_cygwin.c     |    1 +
 agent/mibgroup/host/data_access/swrun_darwin.c     |    1 +
 agent/mibgroup/host/data_access/swrun_kinfo.c      |    1 +
 agent/mibgroup/host/data_access/swrun_kvm_proc.c   |    1 +
 agent/mibgroup/host/data_access/swrun_nlist.c      |    1 +
 agent/mibgroup/host/data_access/swrun_null.c       |    1 +
 agent/mibgroup/host/data_access/swrun_private.h    |    3 +
 .../host/data_access/swrun_procfs_psinfo.c         |   12 +-
 .../host/data_access/swrun_procfs_status.c         |    1 +
 agent/mibgroup/host/data_access/swrun_procinfo.c   |    1 +
 agent/mibgroup/host/data_access/swrun_prpsinfo.c   |    1 +
 agent/mibgroup/host/data_access/swrun_pstat.c      |    1 +
 agent/mibgroup/host/hr_disk.c                      |    3 -
 agent/mibgroup/host/hr_filesys.c                   |    5 -
 agent/mibgroup/host/hr_partition.c                 |    2 -
 agent/mibgroup/host/hr_print.c                     |    1 -
 agent/mibgroup/host/hr_storage.c                   |    7 +-
 agent/mibgroup/host/hr_swinst.c                    |   17 +-
 agent/mibgroup/host/hr_system.c                    |   24 +-
 agent/mibgroup/host/hrh_filesys.c                  |    6 +-
 agent/mibgroup/host/hrh_storage.c                  |   17 +-
 agent/mibgroup/if-mib/data_access/interface.c      |   22 +-
 .../mibgroup/if-mib/data_access/interface_linux.c  |    9 +-
 .../if-mib/data_access/interface_openbsd.c         |    1 +
 .../if-mib/data_access/interface_private.h         |   12 +
 .../if-mib/data_access/interface_solaris2.c        |    1 +
 .../mibgroup/if-mib/data_access/interface_sysctl.c |   10 +-
 agent/mibgroup/if-mib/ifXTable/ifXTable.c          |   48 +-
 agent/mibgroup/if-mib/ifXTable/ifXTable.h          |   48 +-
 .../mibgroup/if-mib/ifXTable/ifXTable_interface.c  |   32 +-
 agent/mibgroup/ip-forward-mib/data_access/route.h  |    2 +-
 .../ip-forward-mib/data_access/route_common.c      |   23 +-
 .../ip-forward-mib/data_access/route_ioctl.c       |    1 +
 .../ip-forward-mib/data_access/route_linux.c       |    3 +-
 .../ip-forward-mib/data_access/route_private.h     |    7 +
 .../ip-forward-mib/data_access/route_solaris.c     |    1 +
 .../ip-forward-mib/data_access/route_sysctl.c      |    9 +
 .../inetCidrRouteTable/inetCidrRouteTable.c        |    7 +-
 .../inetCidrRouteTable_interface.c                 |    8 +-
 agent/mibgroup/ip-mib/data_access/arp_linux.c      |    2 +-
 agent/mibgroup/ip-mib/data_access/arp_netlink.c    |   16 +-
 agent/mibgroup/ip-mib/data_access/defaultrouter.h  |    2 +
 .../ip-mib/data_access/defaultrouter_common.c      |   16 +-
 .../ip-mib/data_access/defaultrouter_linux.c       |    1 +
 .../ip-mib/data_access/defaultrouter_private.h     |    6 +
 .../ip-mib/data_access/defaultrouter_solaris2.c    |  142 +
 .../ip-mib/data_access/defaultrouter_sysctl.c      |    1 +
 agent/mibgroup/ip-mib/data_access/ipaddress.h      |    1 +
 .../mibgroup/ip-mib/data_access/ipaddress_common.c |   25 +-
 .../mibgroup/ip-mib/data_access/ipaddress_ioctl.c  |   16 +-
 .../mibgroup/ip-mib/data_access/ipaddress_linux.c  |   32 +-
 .../ip-mib/data_access/ipaddress_private.h         |   10 +
 .../ip-mib/data_access/ipaddress_solaris2.c        |    5 +-
 .../mibgroup/ip-mib/data_access/ipaddress_sysctl.c |    5 +-
 .../ip-mib/data_access/ipv6scopezone_common.c      |   15 +-
 .../ip-mib/data_access/ipv6scopezone_linux.c       |    1 +
 .../ip-mib/data_access/ipv6scopezone_private.h     |    2 +
 .../ip-mib/data_access/systemstats_common.c        |   17 +-
 .../ip-mib/data_access/systemstats_linux.c         |   18 +-
 .../ip-mib/data_access/systemstats_private.h       |    3 +
 .../ip-mib/data_access/systemstats_solaris2.c      |   25 +-
 .../ip-mib/data_access/systemstats_sysctl.c        |    4 +-
 .../inetNetToMediaTable_interface.c                |    8 +-
 .../ipAddressTable/ipAddressTable_interface.c      |    8 +-
 .../ipIfStatsTable/ipIfStatsTable_data_get.c       |   84 +-
 .../ipIfStatsTable/ipIfStatsTable_data_get.h       |   28 +-
 .../ipIfStatsTable/ipIfStatsTable_interface.c      |   56 +-
 .../ip-mib/ipSystemStatsTable/ipSystemStatsTable.c |   84 +-
 .../ip-mib/ipSystemStatsTable/ipSystemStatsTable.h |  921 +-----
 .../ipSystemStatsTable_interface.c                 |   56 +-
 .../ip-mib/ipv4InterfaceTable/ipv4InterfaceTable.c |    3 +-
 .../ipv4InterfaceTable_interface.c                 |   12 +-
 .../ip-mib/ipv6InterfaceTable/ipv6InterfaceTable.c |    3 +-
 .../ipv6InterfaceTable_interface.c                 |    8 +-
 agent/mibgroup/kernel_sunos5.c                     |   27 +-
 agent/mibgroup/kernel_sunos5.h                     |   15 -
 agent/mibgroup/mibII.h                             |   10 +-
 agent/mibgroup/mibII/at.c                          |    7 +-
 agent/mibgroup/mibII/icmp.c                        |    8 +-
 agent/mibgroup/mibII/icmp.h                        |    4 +
 agent/mibgroup/mibII/interfaces.c                  |   22 +-
 agent/mibgroup/mibII/ip.c                          |    3 -
 agent/mibgroup/mibII/ip.h                          |    5 +
 agent/mibgroup/mibII/ipAddr.c                      |    2 +-
 agent/mibgroup/mibII/ipv6.c                        |  355 ++-
 agent/mibgroup/mibII/mibII_common.h                |    6 +
 agent/mibgroup/mibII/mta_sendmail.c                |    2 +-
 agent/mibgroup/mibII/route_write.c                 |    7 +-
 agent/mibgroup/mibII/snmp_mib.c                    |   33 +-
 agent/mibgroup/mibII/sysORTable.c                  |    7 +-
 agent/mibgroup/mibII/system_mib.c                  |    6 -
 agent/mibgroup/mibII/system_mib.h                  |    4 +
 agent/mibgroup/mibII/tcp.c                         |    6 +-
 agent/mibgroup/mibII/tcpTable.c                    |  127 +-
 agent/mibgroup/mibII/udpTable.c                    |   93 +-
 agent/mibgroup/mibII/updates.c                     |    1 +
 agent/mibgroup/mibII/vacm_context.c                |   13 +-
 agent/mibgroup/mibII/vacm_vars.c                   |   40 +-
 agent/mibgroup/mibII/var_route.c                   |    7 +-
 agent/mibgroup/mibII/var_route.h                   |    7 +
 agent/mibgroup/misc/ipfwacc.c                      |    2 +-
 .../etherStatsTable/etherStatsTable_data_access.c  |    1 +
 agent/mibgroup/sctp-mib/sctpScalars_common.c       |    4 +-
 agent/mibgroup/sctp-mib/sctpScalars_linux.c        |    4 +-
 agent/mibgroup/smux/smux.c                         |   58 +-
 agent/mibgroup/smux/snmp_bgp.c                     |    1 -
 agent/mibgroup/smux/snmp_ospf.c                    |    1 -
 agent/mibgroup/smux/snmp_rip2.c                    |    1 -
 .../snmpNotifyFilterTable_interface.c              |   58 +-
 .../usmDHUserKeyTable/usmDHUserKeyTable_data_get.c |   12 +-
 .../usmDHUserKeyTable_interface.c                  |    8 +-
 agent/mibgroup/snmpv3/snmpEngine.c                 |    9 -
 agent/mibgroup/snmpv3/snmpMPDStats_5_5.c           |   24 +-
 agent/mibgroup/snmpv3/usmStats_5_5.c               |   26 +-
 agent/mibgroup/snmpv3/usmUser.c                    |   13 +
 .../mibgroup/tcp-mib/data_access/tcpConn_common.c  |   20 -
 .../tcp-mib/data_access/tcpConn_freebsd4.c         |   10 +
 agent/mibgroup/tcp-mib/data_access/tcpConn_linux.c |    6 +
 .../mibgroup/tcp-mib/data_access/tcpConn_openbsd.c |  108 +
 .../tcpConnectionTable_interface.c                 |    8 +-
 agent/mibgroup/testhandler.c                       |   17 +-
 .../snmpTlstmAddrTable/snmpTlstmAddrTable.c        |    6 -
 .../snmpTlstmCertToTSNTable.c                      |    3 -
 agent/mibgroup/tunnel/tunnel.c                     |   21 +-
 agent/mibgroup/ucd-snmp/disk_hw.c                  |    1 +
 agent/mibgroup/ucd-snmp/diskio.c                   |   58 +-
 agent/mibgroup/ucd-snmp/diskio.h                   |    1 +
 agent/mibgroup/ucd-snmp/dlmod.c                    |    6 +-
 agent/mibgroup/ucd-snmp/extensible.c               |   23 +-
 agent/mibgroup/ucd-snmp/extensible.h               |    4 +
 agent/mibgroup/ucd-snmp/lmsensorsMib.c             |   16 +-
 agent/mibgroup/ucd-snmp/logmatch.c                 |    2 +-
 agent/mibgroup/ucd-snmp/memory.c                   |  100 +-
 agent/mibgroup/ucd-snmp/memory.h                   |    9 +
 agent/mibgroup/ucd-snmp/pass_common.c              |    2 +-
 agent/mibgroup/ucd-snmp/proxy.c                    |   63 +-
 agent/mibgroup/ucd-snmp/versioninfo.c              |    2 +-
 agent/mibgroup/ucd_snmp.h                          |    2 +
 .../udp-mib/data_access/udp_endpoint_freebsd4.c    |   10 +
 .../udp-mib/data_access/udp_endpoint_openbsd.c     |   88 +
 .../udp-mib/data_access/udp_endpoint_private.h     |    1 +
 .../udpEndpointTable_data_access.c                 |    3 +-
 agent/mibgroup/util_funcs.c                        |   35 +-
 agent/mibgroup/util_funcs/restart.c                |    2 +
 agent/mibgroup/util_funcs/restart.h                |    2 +
 agent/mibgroup/utilities/execute.c                 |    9 +-
 agent/mibgroup/utilities/iquery.c                  |    2 +-
 agent/mibgroup/utilities/override.c                |    1 +
 agent/netsnmp_close_fds.c                          |   41 +
 agent/snmp_agent.c                                 |   45 +-
 agent/snmp_vars.c                                  |    2 -
 agent/snmpd.c                                      |   92 +-
 apps/agentxtrap.c                                  |   55 +-
 apps/encode_keychange.c                            |    5 +-
 apps/snmpbulkget.c                                 |   24 +-
 apps/snmpbulkwalk.c                                |   21 +-
 apps/snmpdelta.c                                   |   35 +-
 apps/snmpdf.c                                      |   32 +-
 apps/snmpget.c                                     |   33 +-
 apps/snmpgetnext.c                                 |   33 +-
 apps/snmpnetstat/ffs.c                             |    2 +
 apps/snmpnetstat/ffs.h                             |    1 +
 apps/snmpnetstat/inet.c                            |  117 +-
 apps/snmpnetstat/inet6.c                           |    3 +-
 apps/snmpnetstat/main.c                            |  706 ++---
 apps/snmpnetstat/route.c                           |    2 +-
 apps/snmpnetstat/winstub.c                         |    8 +
 apps/snmpset.c                                     |   39 +-
 apps/snmpstatus.c                                  |   53 +-
 apps/snmptable.c                                   |   40 +-
 apps/snmptest.c                                    |   25 +-
 apps/snmptranslate.c                               |   58 +-
 apps/snmptrap.c                                    |   73 +-
 apps/snmptrapd.c                                   |  156 +-
 apps/snmptrapd_handlers.c                          |   19 +-
 apps/snmptrapd_handlers.h                          |    4 +
 apps/snmptrapd_log.c                               |    6 +-
 apps/snmptrapd_sql.c                               |   36 +-
 apps/snmptrapd_sql.h                               |    2 +
 apps/snmpusm.c                                     |   66 +-
 apps/snmpvacm.c                                    |   70 +-
 apps/snmpwalk.c                                    |   22 +-
 apps/sshtosnmp.c                                   |    7 +-
 configure                                          |  518 +++-
 configure.ac                                       |   19 +
 configure.d/config_net_snmp_config_h               |  820 ++++++
 configure.d/config_os_functions                    |   20 +-
 configure.d/config_os_libs1                        |    4 +-
 configure.d/config_os_libs2                        |   40 +-
 configure.d/config_os_progs                        |   17 +-
 configure.d/config_os_struct_members               |    1 +
 configure.d/config_project_perl_python             |    2 +-
 configure.d/config_project_with_enable             |   12 +-
 dist/makerelease.xml                               |   20 +-
 dist/run-autoconf                                  |    4 +
 include/net-snmp/agent/agent_index.h               |    2 +
 include/net-snmp/agent/agent_registry.h            |    1 +
 include/net-snmp/agent/agent_trap.h                |    8 +
 include/net-snmp/agent/hardware/cpu.h              |    1 +
 include/net-snmp/agent/hardware/fsys.h             |   12 +-
 include/net-snmp/agent/hardware/memory.h           |    1 +
 include/net-snmp/agent/netsnmp_close_fds.h         |    6 +
 include/net-snmp/agent/snmp_agent.h                |   10 +
 include/net-snmp/agent/snmp_vars.h                 |    2 +
 include/net-snmp/data_access/ipstats.h             |   42 +-
 include/net-snmp/data_access/swrun.h               |    2 +-
 include/net-snmp/library/asn1.h                    |   22 +
 include/net-snmp/library/cert_util.h               |    1 +
 include/net-snmp/library/container.h               |    1 +
 include/net-snmp/library/data_list.h               |    8 +
 include/net-snmp/library/int64.h                   |   44 +-
 .../net-snmp/library/netsnmp-attribute-format.h    |   11 +
 include/net-snmp/library/read_config.h             |   18 +-
 include/net-snmp/library/snmp_api.h                |   30 +-
 include/net-snmp/library/snmp_debug.h              |   28 +-
 include/net-snmp/library/snmp_enum.h               |    2 +-
 include/net-snmp/library/snmpv3.h                  |   10 +
 include/net-snmp/library/tools.h                   |    1 +
 include/net-snmp/library/vacm.h                    |   13 +-
 include/net-snmp/net-snmp-config.h.in              |   23 +-
 include/net-snmp/output_api.h                      |   12 +-
 include/net-snmp/session_api.h                     |   12 +
 include/net-snmp/system/darwin14.h                 |  143 +
 include/net-snmp/system/freebsd8.h                 |    8 +
 include/net-snmp/system/netbsd.h                   |   19 +-
 include/net-snmp/system/openbsd5.h                 |   12 +
 include/net-snmp/system/openbsd6.h                 |    3 +
 include/net-snmp/types.h                           |   13 +-
 local/gittools/shell-functions                     |    9 +-
 local/mib2c                                        |    3 +
 local/mib2c-conf.d/details-enums.m2i               |    5 +-
 local/mib2c-conf.d/details-node.m2i                |    5 +-
 local/mib2c-conf.d/details-table.m2i               |    5 +-
 local/mib2c-conf.d/generic-ctx-copy.m2i            |    5 +-
 local/mib2c-conf.d/generic-ctx-get.m2i             |    5 +-
 local/mib2c-conf.d/generic-ctx-set.m2i             |    5 +-
 local/mib2c-conf.d/generic-data-allocate.m2i       |    5 +-
 local/mib2c-conf.d/generic-data-context.m2i        |    5 +-
 local/mib2c-conf.d/generic-get-U64.m2i             |    5 +-
 local/mib2c-conf.d/generic-get-char.m2i            |    8 +-
 local/mib2c-conf.d/generic-get-decl-bot.m2i        |    5 +-
 local/mib2c-conf.d/generic-get-decl.m2i            |    5 +-
 local/mib2c-conf.d/generic-get-long.m2i            |    5 +-
 local/mib2c-conf.d/generic-get-oid.m2i             |    5 +-
 local/mib2c-conf.d/generic-header-bottom.m2i       |    5 +-
 local/mib2c-conf.d/generic-header-top.m2i          |    5 +-
 local/mib2c-conf.d/generic-source-includes.m2i     |    5 +-
 local/mib2c-conf.d/generic-table-constants.m2c     |   12 +-
 local/mib2c-conf.d/generic-table-enums.m2c         |   12 +-
 .../generic-table-indexes-from-oid.m2i             |    5 +-
 local/mib2c-conf.d/generic-table-indexes-set.m2i   |    5 +-
 .../mib2c-conf.d/generic-table-indexes-to-oid.m2i  |    5 +-
 .../generic-table-indexes-varbind-setup.m2i        |    5 +-
 local/mib2c-conf.d/generic-table-indexes.m2i       |    5 +-
 local/mib2c-conf.d/generic-table-oids.m2c          |   12 +-
 local/mib2c-conf.d/generic-value-map-func.m2i      |    5 +-
 local/mib2c-conf.d/generic-value-map-reverse.m2i   |    5 +-
 local/mib2c-conf.d/generic-value-map.m2i           |    5 +-
 local/mib2c-conf.d/m2c_setup_enum.m2i              |    5 +-
 local/mib2c-conf.d/m2c_setup_node.m2i              |    1 -
 local/mib2c-conf.d/m2c_setup_table.m2i             |    5 +-
 local/mib2c-conf.d/m2c_table_save_defaults.m2i     |    1 -
 .../mfd-access-container-cached-defines.m2i        |   23 +-
 .../mfd-access-unsorted-external-defines.m2i       |    5 +-
 local/mib2c-conf.d/mfd-data-access.m2c             |   18 +-
 local/mib2c-conf.d/mfd-data-get.m2c                |   22 +-
 local/mib2c-conf.d/mfd-data-set.m2c                |   22 +-
 local/mib2c-conf.d/mfd-interactive-setup.m2c       |    5 +-
 local/mib2c-conf.d/mfd-interface.m2c               |   26 +-
 local/mib2c-conf.d/mfd-makefile.m2m                |    5 +-
 local/mib2c-conf.d/mfd-persistence.m2i             |    5 +-
 local/mib2c-conf.d/mfd-readme.m2c                  |    5 +-
 local/mib2c-conf.d/mfd-top.m2c                     |   22 +-
 local/mib2c-conf.d/node-get.m2i                    |    5 +-
 local/mib2c-conf.d/node-set.m2i                    |    5 +-
 local/mib2c-conf.d/node-storage.m2i                |    5 +-
 local/mib2c-conf.d/node-validate.m2i               |   16 +-
 local/mib2c-conf.d/node-varbind-validate.m2i       |    5 +-
 local/mib2c-conf.d/parent-dependencies.m2i         |    5 +-
 local/mib2c-conf.d/parent-set.m2i                  |   13 +-
 local/mib2c-conf.d/subagent.m2c                    |   13 +-
 local/mib2c-conf.d/syntax-COUNTER64-get.m2i        |    5 +-
 local/mib2c-conf.d/syntax-DateAndTime-get.m2i      |    5 +-
 local/mib2c-conf.d/syntax-InetAddress-get.m2i      |    5 +-
 local/mib2c-conf.d/syntax-InetAddress-set.m2i      |    5 +-
 local/mib2c-conf.d/syntax-InetAddressType-get.m2i  |    5 +-
 local/mib2c-conf.d/syntax-InetAddressType-set.m2i  |    5 +-
 .../mib2c-conf.d/syntax-RowStatus-dependencies.m2i |   13 +-
 local/mib2c-conf.d/syntax-RowStatus-get.m2i        |    5 +-
 .../syntax-RowStatus-varbind-validate.m2i          |    5 +-
 .../syntax-StorageType-dependencies.m2i            |    5 +-
 local/mib2c-conf.d/syntax-TestAndIncr-get.m2i      |    5 +-
 local/mib2c.access_functions.conf                  |    8 +-
 local/mib2c.array-user.conf                        |   14 +-
 local/mib2c.check_values.conf                      |    7 +-
 local/mib2c.check_values_local.conf                |   14 +-
 local/mib2c.column_defines.conf                    |    4 +-
 local/mib2c.column_enums.conf                      |    4 +-
 local/mib2c.column_storage.conf                    |    5 +-
 local/mib2c.container.conf                         |   32 +-
 local/mib2c.create-dataset.conf                    |    8 +-
 local/mib2c.emulation.conf                         |    1 -
 local/mib2c.int_watch.conf                         |    8 +-
 local/mib2c.iterate.conf                           |   10 +-
 local/mib2c.iterate_access.conf                    |    8 +-
 local/mib2c.mfd.conf                               |    5 +-
 local/mib2c.notify.conf                            |    8 +-
 local/mib2c.old-api.conf                           |    8 +-
 local/mib2c.raw-table.conf                         |    8 +-
 local/mib2c.row.conf                               |    8 +-
 local/mib2c.scalar.conf                            |    8 +-
 local/mib2c.table_data.conf                        |    8 +-
 local/pass_persisttest                             |    8 +
 m4/pkg.m4                                          |  214 ++
 man/mib2c.conf.5.in                                |    2 +-
 man/netsnmp_config_api.3.def                       |    4 +-
 man/netsnmp_mib_api.3.def                          |    3 +-
 man/snmpcmd.1.def                                  |   15 +-
 man/snmpd.8.def                                    |    4 +-
 man/snmpd.conf.5.def                               |   21 +-
 man/variables.5.def                                |    3 +-
 mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB.txt           |  336 +--
 mibs/IANA-LANGUAGE-MIB.txt                         |    4 +-
 mibs/IANA-RTPROTO-MIB.txt                          |   19 +-
 mibs/IANAifType-MIB.txt                            |  179 +-
 mibs/NET-SNMP-PASS-MIB.txt                         |   14 +
 mibs/UCD-DISKIO-MIB.txt                            |   18 +-
 mibs/UCD-SNMP-MIB.txt                              |  116 +-
 mibs/ianalist                                      |    6 +-
 mibs/rfclist                                       |   18 +-
 mibs/smistrip                                      |    2 +-
 net-snmp-create-v3-user.in                         |    2 +
 perl/ASN/Makefile.PL                               |   36 +-
 perl/Makefile.PL                                   |   35 +-
 perl/Makefile.makefiles                            |   10 +-
 perl/Makefile.subs.pl                              |   29 +-
 perl/OID/Makefile.PL                               |   37 +-
 perl/SNMP/Makefile.PL                              |   37 +-
 perl/SNMP/SNMP.xs                                  |   24 +-
 perl/SNMP/examples/bulkwalk.pl                     |    4 +-
 perl/TrapReceiver/Makefile.PL                      |   37 +-
 perl/agent/Makefile.PL                             |   37 +-
 perl/agent/Support/Makefile.PL                     |   41 +-
 perl/agent/default_store/Makefile.PL               |   37 +-
 perl/default_store/Makefile.PL                     |   38 +-
 perl/make-perl-makefiles                           |   11 +-
 python/netsnmp/client_intf.c                       |   10 +-
 snmplib/Makefile.in                                |   52 +-
 snmplib/asn1.c                                     |  347 ++-
 snmplib/cert_util.c                                |   23 +-
 snmplib/container.c                                |   13 +-
 snmplib/container_binary_array.c                   |   94 +-
 snmplib/container_list_ssll.c                      |   25 +-
 snmplib/data_list.c                                |   19 +-
 snmplib/default_store.c                            |   11 +-
 snmplib/int64.c                                    |   46 +-
 snmplib/large_fd_set.c                             |   73 +-
 snmplib/mib.c                                      |  114 +-
 snmplib/parse.c                                    |   63 +-
 snmplib/read_config.c                              |   17 +-
 snmplib/scapi.c                                    |   19 +-
 snmplib/snmp_api.c                                 |  167 +-
 snmplib/snmp_client.c                              |   47 +-
 snmplib/snmp_debug.c                               |   34 +-
 snmplib/snmp_enum.c                                |   15 +-
 snmplib/snmp_logging.c                             |   44 +-
 snmplib/snmp_openssl.c                             |   14 +-
 snmplib/snmp_parse_args.c                          |   12 +-
 snmplib/snmp_secmod.c                              |   23 +-
 snmplib/snmp_transport.c                           |   14 +-
 snmplib/snmpusm.c                                  |   34 +-
 snmplib/snmpv3.c                                   |   27 +-
 snmplib/snprintf.c                                 |   34 +-
 snmplib/snprintf.h                                 |    2 +
 snmplib/system.c                                   |   44 +-
 snmplib/transports/snmpIPv6BaseDomain.c            |   59 +-
 snmplib/transports/snmpTCPIPv6Domain.c             |    6 -
 snmplib/transports/snmpTLSBaseDomain.c             |    6 +
 snmplib/transports/snmpTLSTCPDomain.c              |    4 +-
 snmplib/transports/snmpUDPBaseDomain.c             |   21 +-
 snmplib/transports/snmpUDPDomain.c                 |    5 -
 snmplib/transports/snmpUDPIPv4BaseDomain.c         |   14 +-
 snmplib/transports/snmpUDPIPv6Domain.c             |   28 +-
 snmplib/ucd_compat.c                               |    4 +
 snmplib/vacm.c                                     |    7 +-
 snmplib/winservice.c                               |    5 +-
 testing/Makefile.in                                |    1 +
 testing/RUNFULLTESTS                               |    7 +
 testing/RUNTESTS                                   |   14 +-
 testing/check_for_pskill                           |   15 +
 testing/fulltests/default/Sv3vacmconfigMD5         |   28 +
 testing/fulltests/default/T000configure_simple     |    2 +-
 .../fulltests/default/T023snmpv3getMD5DES_simple   |    1 +
 .../fulltests/default/T065agentextend_sh_simple    |    2 +-
 testing/fulltests/default/T067passpersist_simple   |    2 +
 testing/fulltests/default/T069exechup_simple       |   67 +
 testing/fulltests/default/T124proxywalkself_simple |   54 +
 testing/fulltests/default/T132snmpv3vacmget_simple |    2 +-
 .../fulltests/default/T142snmpv3vacmgetfail_simple |    2 +-
 testing/fulltests/default/T155dismanexprmib_simple |   89 +
 testing/fulltests/snmpv3/T010scapitest_capp.c      |   13 -
 testing/fulltests/snmpv3/T020hashtests_capp.c      |    2 -
 testing/fulltests/snmpv3/T040keymanagetest_capp.c  |   12 -
 testing/fulltests/snmpv3/T050etimetest_capp.c      |   13 -
 testing/fulltests/support/simple_TESTCONF.sh       |    3 +
 testing/fulltests/support/simple_eval_tools.sh     |    2 +-
 testing/fulltests/unit-tests/T004snmp_enum_clib.c  |    6 +-
 .../T011snmp_old_api_registration_cagentlib.c      |    2 +-
 .../fulltests/unit-tests/T014gethostbyaddr_clib.c  |    9 +-
 testing/fulltests/unit-tests/T015int64_clib.c      |   10 +-
 testing/fulltests/unit-tests/T102pdu_build_clib.c  |    5 -
 win32/Makefile-apps.in                             |    2 +-
 win32/build.pl                                     |    8 +-
 win32/net-snmp/net-snmp-config.h                   |   29 +-
 win32/net-snmp/net-snmp-config.h.in                |   31 +-
 531 files changed, 10466 insertions(+), 7411 deletions(-)

diff --git a/.gitignore b/.gitignore
index df174ed..17c0add 100644
--- a/.gitignore
+++ b/.gitignore
@@ -80,9 +80,12 @@ net-snmp-config
 net-snmp-config-x
 net-snmp-create-v3-user
 NEWS.new*
+perl/*.json
 perl/*.yml
 perl/*/*.def
+perl/*/*.json
 perl/*/*.yml
+perl/*/*/*.json
 perl/*/*/*.yml
 perl/agent/agent.c
 perl/agent/default_store/default_store.c
diff --git a/ChangeLog b/ChangeLog
index 04219c0..dd44ee0 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -121991,7 +121991,7 @@ Changes: V5.0.9 -> V5.1
 
    * agent/mibgroup/agentx/master.c:
 
-     - don't send requests for OIDs preceeding the start of a region
+     - don't send requests for OIDs preceding the start of a region
        (this can lead to loops if e.g. a subagent has registered two
        adjacent rows).
    
@@ -151374,7 +151374,7 @@ Changes: V5.0.9 -> V5.1
    snmplib/snmp_impl.h, man/Makefile.in:
 
    - (*/*/*/*): Patch from Niels Baggesen:
-     - fix auto_nlist on preceeding _ architectures.
+     - fix auto_nlist on preceding _ architectures.
      - Change *all* define usage to new SNMP_ and ASN_ prefixes.
      - leave mib access open if no com2sec statements were found in snmpd.conf.
    
@@ -169312,7 +169312,7 @@ Changes: V4.2 -> V5.0
 
    * agent/mibgroup/agentx/master.c:
 
-     - don't send requests for OIDs preceeding the start of a region
+     - don't send requests for OIDs preceding the start of a region
        (this can lead to loops if e.g. a subagent has registered two
        adjacent rows).
    
@@ -195054,7 +195054,7 @@ hardaker  9 Mar 98 17:40:04
 
 hardaker 11 Mar 98 08:06:17
     - (*/*/*/*): Patch from Niels Baggesen:
-      - fix auto_nlist on preceeding _ architectures.
+      - fix auto_nlist on preceding _ architectures.
       - Change *all* define usage to new SNMP_ and ASN_ prefixes.
       - leave mib access open if no com2sec statements were found in snmpd.conf.
 
diff --git a/INSTALL b/INSTALL
index 199de64..24f8d6c 100644
--- a/INSTALL
+++ b/INSTALL
@@ -113,7 +113,8 @@ The simplest way to compile this package is:
      files that `configure' created (so you can compile the package for
      a different kind of computer), type `make distclean'.
 
-  7. You can remove the application by typing `make uninstall'.
+  7. You can remove the application (but not the perl or python modules)
+     by typing `make uninstall'.
 
 There may be additional installation issues discussed in the 
 README's for various platforms such as README.solaris.
diff --git a/Makefile.in b/Makefile.in
index cfcdf73..d74381a 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -18,7 +18,9 @@ CPP		= @CPP@ 					        \
 INSTALLHEADERS=version.h net-snmp-features.h
 INCLUDESUBDIR=system
 INCLUDESUBDIRHEADERS= aix.h bsd.h bsdi3.h bsdi4.h bsdi.h cygwin.h \
-	darwin.h darwin7.h darwin8.h darwin9.h darwin10.h dragonfly.h dynix.h \
+	darwin.h darwin7.h darwin8.h darwin9.h darwin10.h darwin11.h darwin12.h \
+	darwin13.h darwin14.h \
+	dragonfly.h dynix.h \
 	freebsd2.h freebsd3.h freebsd4.h freebsd5.h freebsd6.h \
 	freebsd7.h freebsd8.h freebsd9.h freebsd10.h freebsd11.h \
 	freebsd12.h freebsd.h \
@@ -190,10 +192,7 @@ perlinstall:
         fi
 
 perluninstall:
-	@(cd perl ; $(MAKE) uninstall) ; \
-        if test $$? != 0 ; then \
-           exit 1 ; \
-        fi
+	echo "WARNING: perl doesn't support uninstall"
 
 perltest:
 	@(cd perl ; $(MAKE) test) ; \
@@ -310,6 +309,7 @@ Makefile: Makefile.in config.status Makefile.rules Makefile.top
 configure_ac = configure.ac \
 	configure.d/config_modules_agent \
 	configure.d/config_modules_lib \
+	configure.d/config_net_snmp_config_h \
 	configure.d/config_os_functions \
 	configure.d/config_os_headers \
 	configure.d/config_os_libs1 \
@@ -328,7 +328,7 @@ configure_ac = configure.ac \
 	configure.d/config_project_with_enable
 
 $(srcdir)/include/net-snmp/net-snmp-config.h.in: stamp-h.in
-$(srcdir)/stamp-h.in: $(configure_ac) acconfig.h
+$(srcdir)/stamp-h.in: $(configure_ac)
 	@if test "x$(NOAUTODEPS)" = "x" -a "x$(AUTOHEADER)" != "x:"; then \
 	    cd ${srcdir} && LC_COLLATE=C $(AUTOHEADER); \
 	    echo timestamp > ${srcdir}/stamp-h.in; \
diff --git a/acconfig.h b/acconfig.h
deleted file mode 100644
index 12f85c6..0000000
--- a/acconfig.h
+++ /dev/null
@@ -1,822 +0,0 @@
-/* 
- * net-snmp configuration header file
- *
- * NOTE: DO NOT EDIT include/net-snmp/net-snmp-config.h.in as your changes
- *       will be overwritten. This content is in acconfig.h and merged
- *       into include/net-snmp/net-snmp-config.h.in by autoheader.
- */
-/* Portions of this file are subject to the following copyright(s).  See
- * the Net-SNMP's COPYING file for more details and other copyrights
- * that may apply:
- */
-/*
- * Portions of this file are copyrighted by:
- * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
- * Use is subject to license terms specified in the COPYING file
- * distributed with the Net-SNMP package.
- */
-
-#ifndef NET_SNMP_CONFIG_H
-#define NET_SNMP_CONFIG_H
-
-
-/* ********* NETSNMP_MARK_BEGIN_AUTOCONF_DEFINITIONS ********* */
-/*
- * put all autoconf-specific definitions below here
- *
- */
-#ifndef NETSNMP_NO_AUTOCONF_DEFINITIONS
-
-/* definitions added by configure on-the-fly */
-@TOP@
-@BOTTOM@
-
-/* end of definitions added by configure on-the-fly */
-
-/* If you have openssl 0.9.7 or above, you likely have AES support. */
-#undef NETSNMP_USE_OPENSSL
-#if (defined(NETSNMP_USE_OPENSSL) && defined(HAVE_OPENSSL_AES_H) && defined(HAVE_AES_CFB128_ENCRYPT)) || defined(NETSNMP_USE_INTERNAL_CRYPTO)
-#define HAVE_AES 1
-#endif
-
-/* define random functions */
-
-#ifndef HAVE_RANDOM
-#ifdef HAVE_LRAND48
-#define random lrand48
-#define srandom(s) srand48(s)
-#else
-#ifdef HAVE_RAND
-#define random rand
-#define srandom(s) srand(s)
-#endif
-#endif
-#endif
-
-/* define signal if DNE */
-
-#ifndef HAVE_SIGNAL
-#ifdef HAVE_SIGSET
-#define signal(a,b) sigset(a,b)
-#endif
-#endif
-
-#ifdef HAVE_DMALLOC_H
-#define DMALLOC_FUNC_CHECK
-#endif
-
-#endif /* NETSNMP_NO_AUTOCONF_DEFINITIONS */
-
-
-
-
-/* ********* NETSNMP_MARK_BEGIN_CLEAN_NAMESPACE ********* */
-/* 
- * put all new net-snmp-specific definitions here
- *
- * all definitions MUST have a NETSNMP_ prefix
- *
- */
-
-/* Default (SNMP) version number for the tools to use */
-#define NETSNMP_DEFAULT_SNMP_VERSION 3
-
-/* don't change these values! */
-#define NETSNMP_SNMPV1      0xAAAA       /* readable by anyone */
-#define NETSNMP_SNMPV2ANY   0xA000       /* V2 Any type (includes NoAuth) */
-#define NETSNMP_SNMPV2AUTH  0x8000       /* V2 Authenticated requests only */
-
-/* default list of mibs to load */
-#define NETSNMP_DEFAULT_MIBS "IP-MIB:IF-MIB:TCP-MIB:UDP-MIB:SNMPv2-MIB:RFC1213-MIB"
-
-/* debugging stuff */
-/* if defined, we optimize the code to exclude all debugging calls. */
-#undef NETSNMP_NO_DEBUGGING
-/* ignore the -D flag and always print debugging information */
-#define NETSNMP_ALWAYS_DEBUG 0
-
-/* reverse encoding BER packets is both faster and more efficient in space. */
-#define NETSNMP_USE_REVERSE_ASNENCODING       1
-#define NETSNMP_DEFAULT_ASNENCODING_DIRECTION 1 /* 1 = reverse, 0 = forwards */
-
-/* PERSISTENT_DIRECTORY: If defined, the library is capabile of saving
-   persisant information to this directory in the form of configuration
-   lines: PERSISTENT_DIRECTORY/NAME.persistent.conf */
-#define NETSNMP_PERSISTENT_DIRECTORY "/var/snmp"
-
-/* AGENT_DIRECTORY_MODE: the mode the agents should use to create
-   directories with. Since the data stored here is probably sensitive, it
-   probably should be read-only by root/administrator. */
-#define NETSNMP_AGENT_DIRECTORY_MODE 0700
-
-/* MAX_PERSISTENT_BACKUPS:
- *   The maximum number of persistent backups the library will try to
- *   read from the persistent cache directory.  If an application fails to
- *   close down successfully more than this number of times, data will be lost.
- */
-#define NETSNMP_MAX_PERSISTENT_BACKUPS 10
-
-/* define the system type include file here */
-#define NETSNMP_SYSTEM_INCLUDE_FILE <net-snmp/system/generic.h>
-
-/* define the machine (cpu) type include file here */
-#define NETSNMP_MACHINE_INCLUDE_FILE <net-snmp/machine/generic.h>
-
-/* define the UDP buffer defaults undefined means use the OS buffers
- * by default */
-#undef NETSNMP_DEFAULT_SERVER_SEND_BUF
-#undef NETSNMP_DEFAULT_SERVER_RECV_BUF
-#undef NETSNMP_DEFAULT_CLIENT_SEND_BUF
-#undef NETSNMP_DEFAULT_CLIENT_RECV_BUF
-
-/* net-snmp's major path names */
-#undef SNMPLIBPATH
-#undef SNMPSHAREPATH
-#undef SNMPCONFPATH
-#undef SNMPDLMODPATH
-
-/* NETSNMP_LOGFILE:  If defined it closes stdout/err/in and opens this in 
-   out/err's place.  (stdin is closed so that sh scripts won't wait for it) */
-#undef NETSNMP_LOGFILE
-
-/* default system contact */
-#undef NETSNMP_SYS_CONTACT
-
-/* system location */
-#undef NETSNMP_SYS_LOC
-
-/* Use libwrap to handle allow/deny hosts? */
-#undef NETSNMP_USE_LIBWRAP
-
-/* Mib-2 tree Info */
-/* These are the system information variables. */
-
-#define NETSNMP_VERS_DESC   "unknown"             /* overridden at run time */
-#define NETSNMP_SYS_NAME    "unknown"             /* overridden at run time */
-
-/* comment out the second define to turn off functionality for any of
-   these: (See README for details) */
-
-/*   proc PROCESSNAME [MAX] [MIN] */
-#define NETSNMP_PROCMIBNUM 2
-
-/*   exec/shell NAME COMMAND      */
-#define NETSNMP_SHELLMIBNUM 8
-
-/*   swap MIN                     */
-#define NETSNMP_MEMMIBNUM 4
-
-/*   disk DISK MINSIZE            */
-#define NETSNMP_DISKMIBNUM 9
-
-/*   load 1 5 15                  */
-#define NETSNMP_LOADAVEMIBNUM 10
-
-/* which version are you using? This mibloc will tell you */
-#define NETSNMP_VERSIONMIBNUM 100
-
-/* Reports errors the agent runs into */
-/* (typically its "can't fork, no mem" problems) */
-#define NETSNMP_ERRORMIBNUM 101
-
-/* The sub id of EXTENSIBLEMIB returned to queries of
-   .iso.org.dod.internet.mgmt.mib-2.system.sysObjectID.0 */
-#define NETSNMP_AGENTID 250
-
-/* This ID is returned after the AGENTID above.  IE, the resulting
-   value returned by a query to sysObjectID is
-   EXTENSIBLEMIB.AGENTID.???, where ??? is defined below by OSTYPE */
-
-#define NETSNMP_HPUX9ID 1
-#define NETSNMP_SUNOS4ID 2 
-#define NETSNMP_SOLARISID 3
-#define NETSNMP_OSFID 4
-#define NETSNMP_ULTRIXID 5
-#define NETSNMP_HPUX10ID 6
-#define NETSNMP_NETBSD1ID 7
-#define NETSNMP_FREEBSDID 8
-#define NETSNMP_IRIXID 9
-#define NETSNMP_LINUXID 10
-#define NETSNMP_BSDIID 11
-#define NETSNMP_OPENBSDID 12
-#define NETSNMP_WIN32ID 13
-#define NETSNMP_HPUX11ID 14
-#define NETSNMP_AIXID 15
-#define NETSNMP_MACOSXID 16
-#define NETSNMP_DRAGONFLYID 17
-#define NETSNMP_UNKNOWNID 255
-
-#ifdef hpux9
-#define NETSNMP_OSTYPE NETSNMP_HPUX9ID
-#endif
-#ifdef hpux10
-#define NETSNMP_OSTYPE NETSNMP_HPUX10ID
-#endif
-#ifdef hpux11
-#define NETSNMP_OSTYPE NETSNMP_HPUX11ID
-#endif
-#ifdef sunos4
-#define NETSNMP_OSTYPE NETSNMP_SUNOS4ID
-#endif
-#ifdef solaris2
-#define NETSNMP_OSTYPE NETSNMP_SOLARISID
-#endif
-#if defined(osf3) || defined(osf4) || defined(osf5)
-#define NETSNMP_OSTYPE NETSNMP_OSFID
-#endif
-#ifdef ultrix4
-#define NETSNMP_OSTYPE NETSNMP_ULTRIXID
-#endif
-#if defined(netbsd1) || defined(netbsd2)
-#define NETSNMP_OSTYPE NETSNMP_NETBSD1ID
-#endif
-#if defined(__FreeBSD__)
-#define NETSNMP_OSTYPE NETSNMP_FREEBSDID
-#endif
-#if defined(__DragonFly__)
-#define NETSNMP_OSTYPE NETSNMP_DRAGONFLYID
-#endif
-#if defined(irix6) || defined(irix5)
-#define NETSNMP_OSTYPE NETSNMP_IRIXID
-#endif
-#ifdef linux
-#define NETSNMP_OSTYPE NETSNMP_LINUXID
-#endif
-#if defined(bsdi2) || defined(bsdi3) || defined(bsdi4)
-#define NETSNMP_OSTYPE NETSNMP_BSDIID
-#endif
-#if defined(openbsd)
-#define NETSNMP_OSTYPE NETSNMP_OPENBSDID
-#endif
-#ifdef WIN32
-#define NETSNMP_OSTYPE NETSNMP_WIN32ID
-#endif
-#if defined(aix3) || defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
-#define NETSNMP_OSTYPE NETSNMP_AIXID
-#endif
-#if defined(darwin) && (darwin >= 8)
-#define NETSNMP_OSTYPE NETSNMP_MACOSXID
-#endif
-/* unknown */
-#ifndef NETSNMP_OSTYPE
-#define NETSNMP_OSTYPE NETSNMP_UNKNOWNID
-#endif
-
-/* The enterprise number has been assigned by the IANA group.   */
-/* Optionally, this may point to the location in the tree your  */
-/* company/organization has been allocated.                     */
-/* The assigned enterprise number for the NET_SNMP MIB modules. */
-#define NETSNMP_ENTERPRISE_OID			8072
-#define NETSNMP_ENTERPRISE_MIB			1,3,6,1,4,1,8072
-#define NETSNMP_ENTERPRISE_DOT_MIB		1.3.6.1.4.1.8072
-#define NETSNMP_ENTERPRISE_DOT_MIB_LENGTH	7
-
-/* The assigned enterprise number for sysObjectID. */
-#define NETSNMP_SYSTEM_MIB		1,3,6,1,4,1,8072,3,2,NETSNMP_OSTYPE
-#define NETSNMP_SYSTEM_DOT_MIB		1.3.6.1.4.1.8072.3.2.NETSNMP_OSTYPE
-#define NETSNMP_SYSTEM_DOT_MIB_LENGTH	10
-
-/* The assigned enterprise number for notifications. */
-#define NETSNMP_NOTIFICATION_MIB		1,3,6,1,4,1,8072,4
-#define NETSNMP_NOTIFICATION_DOT_MIB		1.3.6.1.4.1.8072.4
-#define NETSNMP_NOTIFICATION_DOT_MIB_LENGTH	8
-
-/* this is the location of the ucdavis mib tree.  It shouldn't be
-   changed, as the places it is used are expected to be constant
-   values or are directly tied to the UCD-SNMP-MIB. */
-#define NETSNMP_UCDAVIS_OID		2021
-#define NETSNMP_UCDAVIS_MIB		1,3,6,1,4,1,2021
-#define NETSNMP_UCDAVIS_DOT_MIB		1.3.6.1.4.1.2021
-#define NETSNMP_UCDAVIS_DOT_MIB_LENGTH	7
-
-/* how long to wait (seconds) for error querys before reseting the error trap.*/
-#define NETSNMP_ERRORTIMELENGTH 600 
-
-/* Exec command to fix PROC problems */
-/* %s will be replaced by the process name in error */
-
-/* #define NETSNMP_PROCFIXCMD "/usr/bin/perl /local/scripts/fixproc %s" */
-
-/* Exec command to fix EXEC problems */
-/* %s will be replaced by the exec/script name in error */
-
-/* #define NETSNMP_EXECFIXCMD "/usr/bin/perl /local/scripts/fixproc %s" */
-
-/* Should exec output Cashing be used (speeds up things greatly), and
-   if so, After how many seconds should the cache re-newed?  Note:
-   Don't define CASHETIME to disable cashing completely */
-
-#define NETSNMP_EXCACHETIME 30
-#define NETSNMP_CACHEFILE ".snmp-exec-cache"
-#define NETSNMP_MAXCACHESIZE (1500*80)   /* roughly 1500 lines max */
-
-/* misc defaults */
-
-/* default of 100 meg minimum if the minimum size is not specified in
-   the config file */
-#define NETSNMP_DEFDISKMINIMUMSPACE 100000
-
-/* default maximum load average before error */
-#define NETSNMP_DEFMAXLOADAVE 12.0
-
-/* max times to loop reading output from execs. */
-/* Because of sleep(1)s, this will also be time to wait (in seconds) for exec
-   to finish */
-#define NETSNMP_MAXREADCOUNT 100
-
-/* Set if snmpgets should block and never timeout */
-/* The original CMU code had this hardcoded as = 1 */
-#define NETSNMP_SNMPBLOCK 1
-
-/* How long to wait before restarting the agent after a snmpset to
-   EXTENSIBLEMIB.VERSIONMIBNUM.VERRESTARTAGENT.  This is
-   necessary to finish the snmpset reply before restarting. */
-#define NETSNMP_RESTARTSLEEP 5
-
-/* UNdefine to allow specifying zero-length community string */
-/* #define NETSNMP_NO_ZEROLENGTH_COMMUNITY 1 */
-
-/* Number of community strings to store */
-#define NETSNMP_NUM_COMMUNITIES	5
-
-/* internal define */
-#define NETSNMP_LASTFIELD -1
-
-/*  Pluggable transports.  */
-
-/*  This is defined if support for the UDP/IP transport domain is
-    available.   */
-#undef NETSNMP_TRANSPORT_UDP_DOMAIN
-
-/*  This is defined if support for the "callback" transport domain is
-    available.   */
-#undef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
-
-/*  This is defined if support for the TCP/IP transport domain is
-    available.  */
-#undef NETSNMP_TRANSPORT_TCP_DOMAIN
-
-/*  This is defined if support for the Unix transport domain
-    (a.k.a. "local IPC") is available.  */
-#undef NETSNMP_TRANSPORT_UNIX_DOMAIN
-
-/*  This is defined if support for the AAL5 PVC transport domain is
-    available.  */
-#undef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
-
-/*  This is defined if support for the IPX transport domain is
-    available.  */
-#undef NETSNMP_TRANSPORT_IPX_DOMAIN
-
-/*  This is defined if support for the UDP/IPv6 transport domain is
-    available.  */
-#undef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
-
-/*  This is defined if support for the TCP/IPv6 transport domain is
-    available.  */
-#undef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
-
-/*  This is defined if support for the TLS transport domain is
-    available.   */
-#undef NETSNMP_TRANSPORT_TLSBASE_DOMAIN
-
-/*  This is defined if support for the Alias transport domain is
-    available.   */
-#undef NETSNMP_TRANSPORT_ALIAS_DOMAIN
-
-/*  This is defined if support for the SSH transport domain is
-    available.   */
-#undef NETSNMP_TRANSPORT_SSH_DOMAIN
-
-/*  This is defined if support for the DTLS/UDP transport domain is
-    available.   */
-#undef NETSNMP_TRANSPORT_DTLSUDP_DOMAIN
-
-/*  This is defined if support for the TLS/TCP transport domain is
-    available.   */
-#undef NETSNMP_TRANSPORT_TLSTCP_DOMAIN
-
-/*  This is defined if support for stdin/out transport domain is available.   */
-#undef NETSNMP_TRANSPORT_STD_DOMAIN
-
-/*  This is defined if support for the IPv4Base transport domain is available.   */
-#undef NETSNMP_TRANSPORT_IPV4BASE_DOMAIN
-
-/* define this if the USM security module is available */
-#undef NETSNMP_SECMOD_USM
-
-/* define this if the KSM (kerberos based snmp) security module is available */
-#undef NETSNMP_SECMOD_KSM
-
-/* define this if the local security module is available */
-#undef NETSNMP_SECMOD_LOCALSM
-
-/* define if configured as a "mini-agent" */
-#undef NETSNMP_MINI_AGENT
-
-/* this is the location of the net-snmp mib tree.  It shouldn't be
-   changed, as the places it is used are expected to be constant
-   values or are directly tied to the UCD-SNMP-MIB. */
-#define NETSNMP_OID		8072
-#define NETSNMP_MIB		1,3,6,1,4,1,8072
-#define NETSNMP_DOT_MIB		1.3.6.1.4.1.8072
-#define NETSNMP_DOT_MIB_LENGTH	7
-
-/* pattern for temporary file names */
-#define NETSNMP_TEMP_FILE_PATTERN "/tmp/snmpdXXXXXX"
-
-/*
- * this must be before the system/machine includes, to allow them to
- * override and turn off inlining. To do so, they should do the
- * following:
- *
- *    #undef NETSNMP_ENABLE_INLINE
- *    #define NETSNMP_ENABLE_INLINE 0
- *
- * A user having problems with their compiler can also turn off
- * the use of inline by defining NETSNMP_NO_INLINE via their cflags:
- *
- *    -DNETSNMP_NO_INLINE
- *
- * Header and source files should only test against NETSNMP_USE_INLINE:
- *
- *   #ifdef NETSNMP_USE_INLINE
- *   NETSNMP_INLINE function(int parm) { return parm -1; }
- *   #endif
- *
- * Functions which should be static, regardless of whether or not inline
- * is available or enabled should use the NETSNMP_STATIC_INLINE macro,
- * like so:
- *
- *    NETSNMP_STATIC_INLINE function(int parm) { return parm -1; }
- *
- * NOT like this:
- *
- *    static NETSNMP_INLINE function(int parm) { return parm -1; }
- *
- */
-#ifdef NETSNMP_BROKEN_INLINE
-#   define NETSNMP_ENABLE_INLINE 0
-#else
-#   define NETSNMP_ENABLE_INLINE 1
-#endif
-
-#include NETSNMP_SYSTEM_INCLUDE_FILE
-#include NETSNMP_MACHINE_INCLUDE_FILE
-
-#if NETSNMP_ENABLE_INLINE && !defined(NETSNMP_NO_INLINE)
-#   define NETSNMP_USE_INLINE 1
-#   ifndef NETSNMP_INLINE
-#      define NETSNMP_INLINE inline
-#   endif
-#   ifndef NETSNMP_STATIC_INLINE
-#      define NETSNMP_STATIC_INLINE static inline
-#   endif
-#else
-#   define NETSNMP_INLINE 
-#   define NETSNMP_STATIC_INLINE static
-#endif
-
-#ifndef NETSNMP_IMPORT
-#  define NETSNMP_IMPORT extern
-#endif
-
-/* comment the next line if you are compiling with libsnmp.h 
-   and are not using the UC-Davis SNMP library. */
-#define UCD_SNMP_LIBRARY 1
-
-/* final conclusion on nlist usage */
-#if defined(HAVE_NLIST) && defined(HAVE_STRUCT_NLIST_N_VALUE) && !defined(NETSNMP_DONT_USE_NLIST) && defined(HAVE_KMEM) && !defined(NETSNMP_NO_KMEM_USAGE)
-#define NETSNMP_CAN_USE_NLIST
-#endif
-
-
-/* ********* NETSNMP_MARK_BEGIN_LEGACY_DEFINITIONS *********/
-/* 
- * existing definitions prior to Net-SNMP 5.4
- *
- * do not add anything new here
- *
- */
-
-#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
-
-#ifdef NETSNMP_DEFAULT_SNMP_VERSION
-# define DEFAULT_SNMP_VERSION NETSNMP_DEFAULT_SNMP_VERSION
-#endif
-
-#ifdef NETSNMP_SNMPV1
-# define SNMPV1 NETSNMP_SNMPV1
-#endif
-
-#ifdef NETSNMP_SNMPV2ANY
-# define SNMPV2ANY NETSNMP_SNMPV2ANY
-#endif
-
-#ifdef NETSNMP_SNMPV2AUTH
-# define SNMPV2AUTH NETSNMP_SNMPV2AUTH
-#endif
-
-#ifdef NETSNMP_DEFAULT_MIBS
-# define DEFAULT_MIBS NETSNMP_DEFAULT_MIBS
-#endif
-
-#ifdef NETSNMP_DEFAULT_MIBDIRS
-# define DEFAULT_MIBDIRS NETSNMP_DEFAULT_MIBDIRS
-#endif
-
-#ifdef NETSNMP_DEFAULT_MIBFILES
-# define DEFAULT_MIBFILES NETSNMP_DEFAULT_MIBFILES
-#endif
-
-#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
-# define OPAQUE_SPECIAL_TYPES NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
-#endif
-
-#ifdef NETSNMP_ENABLE_SCAPI_AUTHPRIV
-# define SCAPI_AUTHPRIV NETSNMP_ENABLE_SCAPI_AUTHPRIV
-#endif
-
-#ifdef NETSNMP_USE_INTERNAL_MD5
-# define USE_INTERNAL_MD5 NETSNMP_USE_INTERNAL_MD5
-#endif
-
-#ifdef NETSNMP_USE_PKCS11
-# define USE_PKCS NETSNMP_USE_PKCS11
-#endif
-
-#ifdef NETSNMP_USE_OPENSSL
-# define USE_OPENSSL NETSNMP_USE_OPENSSL
-#endif
-
-#ifdef NETSNMP_NO_DEBUGGING
-# define SNMP_NO_DEBUGGING NETSNMP_NO_DEBUGGING
-#endif
-
-#ifdef NETSNMP_ALWAYS_DEBUG
-# define SNMP_ALWAYS_DEBUG NETSNMP_ALWAYS_DEBUG
-#endif
-
-#ifdef NETSNMP_USE_REVERSE_ASNENCODING
-# define USE_REVERSE_ASNENCODING NETSNMP_USE_REVERSE_ASNENCODING
-#endif
-#ifdef NETSNMP_DEFAULT_ASNENCODING_DIRECTION
-# define DEFAULT_ASNENCODING_DIRECTION NETSNMP_DEFAULT_ASNENCODING_DIRECTION
-#endif
-
-#define PERSISTENT_DIRECTORY NETSNMP_PERSISTENT_DIRECTORY
-#define PERSISTENT_MASK NETSNMP_PERSISTENT_MASK
-#define AGENT_DIRECTORY_MODE NETSNMP_AGENT_DIRECTORY_MODE
-#define MAX_PERSISTENT_BACKUPS NETSNMP_MAX_PERSISTENT_BACKUPS
-#define SYSTEM_INCLUDE_FILE NETSNMP_SYSTEM_INCLUDE_FILE
-#define MACHINE_INCLUDE_FILE NETSNMP_MACHINE_INCLUDE_FILE
-
-#ifdef NETSNMP_DEFAULT_SERVER_SEND_BUF
-# define DEFAULT_SERVER_SEND_BUF NETSNMP_DEFAULT_SERVER_SEND_BUF
-#endif
-#ifdef NETSNMP_DEFAULT_SERVER_RECV_BUF
-# define DEFAULT_SERVER_RECV_BUF NETSNMP_DEFAULT_SERVER_RECV_BUF
-#endif
-#ifdef NETSNMP_DEFAULT_CLIENT_SEND_BUF
-# define DEFAULT_CLIENT_SEND_BUF NETSNMP_DEFAULT_CLIENT_SEND_BUF
-#endif
-#ifdef NETSNMP_DEFAULT_CLIENT_RECV_BUF
-# define DEFAULT_CLIENT_RECV_BUF NETSNMP_DEFAULT_CLIENT_RECV_BUF
-#endif
-
-#ifdef NETSNMP_LOGFILE
-# define LOGFILE NETSNMP_LOGFILE
-#endif
-
-#ifdef NETSNMP_SYS_CONTACT
-# define SYS_CONTACT NETSNMP_SYS_CONTACT
-#endif
-
-#ifdef NETSNMP_SYS_LOC
-# define SYS_LOC NETSNMP_SYS_LOC
-#endif
-
-#ifdef NETSNMP_USE_LIBWRAP
-# define USE_LIBWRAP NETSNMP_USE_LIBWRAP
-#endif
-
-#ifdef NETSNMP_ENABLE_TESTING_CODE 
-# define SNMP_TESTING_CODE NETSNMP_ENABLE_TESTING_CODE
-#endif
-
-#ifdef NETSNMP_NO_ROOT_ACCESS
-# define NO_ROOT_ACCESS NETSNMP_NO_ROOT_ACCESS
-#endif
-
-#ifdef NETSNMP_NO_KMEM_USAGE
-# define NO_KMEM_USAGE NETSNMP_NO_KMEM_USAGE
-#endif
-
-#ifdef NETSNMP_NO_DUMMY_VALUES
-# define NO_DUMMY_VALUES NETSNMP_NO_DUMMY_VALUES
-#endif
-
-#define VERS_DESC     NETSNMP_VERS_DESC
-#define SYS_NAME      NETSNMP_SYS_NAME
-
-#define PROCMIBNUM    NETSNMP_PROCMIBNUM
-#define SHELLMIBNUM   NETSNMP_SHELLMIBNUM
-#define MEMMIBNUM     NETSNMP_MEMMIBNUM
-#define DISKMIBNUM    NETSNMP_DISKMIBNUM
-
-#define LOADAVEMIBNUM NETSNMP_LOADAVEMIBNUM
-#define VERSIONMIBNUM NETSNMP_VERSIONMIBNUM
-#define ERRORMIBNUM   NETSNMP_ERRORMIBNUM
-#define AGENTID       NETSNMP_AGENTID
-
-#define HPUX9ID       NETSNMP_HPUX9ID
-#define SUNOS4ID      NETSNMP_SUNOS4ID
-#define SOLARISID     NETSNMP_SOLARISID
-#define OSFID         NETSNMP_OSFID
-#define ULTRIXID      NETSNMP_ULTRIXID
-#define HPUX10ID      NETSNMP_HPUX10ID
-#define NETBSD1ID     NETSNMP_NETBSD1ID
-#define FREEBSDID     NETSNMP_FREEBSDID
-#define IRIXID        NETSNMP_IRIXID
-#define LINUXID       NETSNMP_LINUXID
-#define BSDIID        NETSNMP_BSDIID
-#define OPENBSDID     NETSNMP_OPENBSDID
-#define WIN32ID       NETSNMP_WIN32ID
-#define HPUX11ID      NETSNMP_HPUX11ID
-#define AIXID         NETSNMP_AIXID
-#define MACOSXID      NETSNMP_MACOSXID
-#define UNKNOWNID     NETSNMP_UNKNOWNID
-
-#define ENTERPRISE_OID            NETSNMP_ENTERPRISE_OID
-#define ENTERPRISE_MIB            NETSNMP_ENTERPRISE_MIB
-#define ENTERPRISE_DOT_MIB        NETSNMP_ENTERPRISE_DOT_MIB
-#define ENTERPRISE_DOT_MIB_LENGTH NETSNMP_ENTERPRISE_DOT_MIB_LENGTH
-
-#define SYSTEM_MIB		  NETSNMP_SYSTEM_MIB
-#define SYSTEM_DOT_MIB		  NETSNMP_SYSTEM_DOT_MIB
-#define SYSTEM_DOT_MIB_LENGTH	  NETSNMP_SYSTEM_DOT_MIB_LENGTH
-
-#define NOTIFICATION_MIB	    NETSNMP_NOTIFICATION_MIB	
-#define NOTIFICATION_DOT_MIB	    NETSNMP_NOTIFICATION_DOT_MIB
-#define NOTIFICATION_DOT_MIB_LENGTH NETSNMP_NOTIFICATION_DOT_MIB_LENGTH
-
-#define UCDAVIS_OID		  NETSNMP_UCDAVIS_OID
-#define UCDAVIS_MIB		  NETSNMP_UCDAVIS_MIB
-#define UCDAVIS_DOT_MIB		  NETSNMP_UCDAVIS_DOT_MIB
-#define UCDAVIS_DOT_MIB_LENGTH	  NETSNMP_UCDAVIS_DOT_MIB_LENGTH
-
-#define ERRORTIMELENGTH NETSNMP_ERRORTIMELENGTH
-
-#ifdef NETSNMP_PROCFIXCMD
-# define PROCFIXCMD NETSNMP_PROCFIXCMD
-#endif
-
-#ifdef NETSNMP_EXECFIXCMD
-# define EXECFIXCMD NETSNMP_EXECFIXCMD
-#endif
-
-#define EXCACHETIME  NETSNMP_EXCACHETIME
-#define CACHEFILE    NETSNMP_CACHEFILE
-#define MAXCACHESIZE NETSNMP_MAXCACHESIZE
-
-#define DEFDISKMINIMUMSPACE NETSNMP_DEFDISKMINIMUMSPACE
-#define DEFMAXLOADAVE NETSNMP_DEFMAXLOADAVE
-#define MAXREADCOUNT NETSNMP_MAXREADCOUNT
-
-#define SNMPBLOCK NETSNMP_SNMPBLOCK
-#define RESTARTSLEEP NETSNMP_RESTARTSLEEP
-
-#define NUM_COMMUNITIES	NETSNMP_NUM_COMMUNITIES
-
-#ifdef NETSNMP_NO_ZEROLENGTH_COMMUNITY
-# define NO_ZEROLENGTH_COMMUNITY NETSNMP_NO_ZEROLENGTH_COMMUNITY
-#endif
-
-#define LASTFIELD NETSNMP_LASTFIELD
-
-#define CONFIGURE_OPTIONS NETSNMP_CONFIGURE_OPTIONS
-
-#ifdef NETSNMP_TRANSPORT_UDP_DOMAIN
-# define SNMP_TRANSPORT_UDP_DOMAIN NETSNMP_TRANSPORT_UDP_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
-# define SNMP_TRANSPORT_CALLBACK_DOMAIN NETSNMP_TRANSPORT_CALLBACK_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_TCP_DOMAIN
-# define SNMP_TRANSPORT_TCP_DOMAIN NETSNMP_TRANSPORT_TCP_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_UNIX_DOMAIN
-# define SNMP_TRANSPORT_UNIX_DOMAIN NETSNMP_TRANSPORT_UNIX_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
-# define SNMP_TRANSPORT_AAL5PVC_DOMAIN NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_IPX_DOMAIN
-# define SNMP_TRANSPORT_IPX_DOMAIN NETSNMP_TRANSPORT_IPX_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
-# define SNMP_TRANSPORT_UDPIPV6_DOMAIN NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
-# define SNMP_TRANSPORT_TCPIPV6_DOMAIN NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_TLS_DOMAIN
-# define SNMP_TRANSPORT_TLS_DOMAIN NETSNMP_TRANSPORT_TLS_DOMAIN
-#endif
-
-#ifdef NETSNMP_TRANSPORT_STD_DOMAIN
-# define SNMP_TRANSPORT_STD_DOMAIN NETSNMP_TRANSPORT_STD_DOMAIN
-#endif
-
-#ifdef NETSNMP_SECMOD_USM
-# define SNMP_SECMOD_USM NETSNMP_SECMOD_USM
-#endif
-
-#ifdef NETSNMP_SECMOD_KSM
-# define SNMP_SECMOD_KSM NETSNMP_SECMOD_KSM
-#endif
-
-#ifdef NETSNMP_SECMOD_LOCALSM 
-# define SNMP_SECMOD_LOCALSM NETSNMP_SECMOD_LOCALSM
-#endif
-
-#ifdef NETSNMP_REENTRANT
-# define NS_REENTRANT NETSNMP_REENTRANT
-#endif
-
-#ifdef NETSNMP_ENABLE_IPV6
-# define INET6 NETSNMP_ENABLE_IPV6
-#endif
-
-#ifdef NETSNMP_ENABLE_LOCAL_SMUX
-# define LOCAL_SMUX NETSNMP_ENABLE_LOCAL_SMUX
-#endif
-
-#ifdef NETSNMP_AGENTX_DOM_SOCK_ONLY
-# define AGENTX_DOM_SOCK_ONLY NETSNMP_AGENTX_DOM_SOCK_ONLY
-#endif
-
-#ifdef NETSNMP_SNMPTRAPD_DISABLE_AGENTX
-# define SNMPTRAPD_DISABLE_AGENTX
-#endif
-
-#ifdef NETSNMP_USE_KERBEROS_MIT
-# define MIT_NEW_CRYPTO NETSNMP_USE_KERBEROS_MIT
-#endif
-
-#ifdef NETSNMP_USE_KERBEROS_HEIMDAL
-# define HEIMDAL NETSNMP_USE_KERBEROS_HEIMDAL
-#endif
-
-#ifdef NETSNMP_AGENTX_SOCKET
-# define AGENTX_SOCKET NETSNMP_AGENTX_SOCKET
-#endif
-
-#ifdef NETSNMP_DISABLE_MIB_LOADING
-# define DISABLE_MIB_LOADING NETSNMP_DISABLE_MIB_LOADING
-#endif
-
-#ifdef NETSNMP_DISABLE_SNMPV1
-# define DISABLE_SNMPV1 NETSNMP_DISABLE_SNMPV1
-#endif
-
-#ifdef NETSNMP_DISABLE_SNMPV2C
-# define DISABLE_SNMPV2C NETSNMP_DISABLE_SNMPV2C
-#endif
-
-#ifdef NETSNMP_DISABLE_SET_SUPPORT
-# define DISABLE_SET_SUPPORT NETSNMP_DISABLE_SET_SUPPORT
-#endif
-
-#ifdef NETSNMP_DISABLE_DES
-# define DISABLE_DES NETSNMP_DISABLE_DES
-#endif
-
-#ifdef NETSNMP_DISABLE_MD5
-# define DISABLE_MD5 NETSNMP_DISABLE_MD5
-#endif
-
-#ifdef NETSNMP_DONT_USE_NLIST
-# define DONT_USE_NLIST NETSNMP_DONT_USE_NLIST
-#endif
-
-#ifdef NETSNMP_CAN_USE_NLIST
-# define CAN_USE_NLIST NETSNMP_CAN_USE_NLIST
-#endif
-
-#ifdef NETSNMP_CAN_USE_SYSCTL
-# define CAN_USE_SYSCTL NETSNMP_CAN_USE_SYSCTL
-#endif
-
-#endif /* NETSNMP_NO_LEGACY_DEFINITIONS */
-
-
-#endif /* NET_SNMP_CONFIG_H */
diff --git a/aclocal.m4 b/aclocal.m4
index cd80c74..45e3608 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -22,3 +22,4 @@ m4_include([m4/ltversion.m4])
 m4_include([m4/lt~obsolete.m4])
 m4_include([m4/netsnmp_arg.m4])
 m4_include([m4/netsnmp_search_libs.m4])
+m4_include([m4/pkg.m4])
diff --git a/agent/Makefile.in b/agent/Makefile.in
index 748b01c..829e4fe 100644
--- a/agent/Makefile.in
+++ b/agent/Makefile.in
@@ -65,7 +65,8 @@ HEADERS=\
 	table_dataset.h \
 	table_tdata.h \
 	table_iterator.h \
-	watcher.h
+	watcher.h \
+	netsnmp_close_fds.h
 
 HEADERSONLY=mfd.h set_helper.h
 
@@ -177,6 +178,7 @@ LIBAGENTOBJS= \
 	agent_sysORTable.o \
 	agent_trap.o \
 	kernel.o \
+	netsnmp_close_fds.o \
 	snmp_agent.o \
 	snmp_vars.o \
 	$(agentgroup_list_o) \
@@ -217,6 +219,7 @@ LLIBAGENTOBJS= \
 	agent_sysORTable.lo \
 	agent_trap.lo \
 	kernel.lo \
+	netsnmp_close_fds.lo \
 	snmp_agent.lo \
 	snmp_vars.lo \
 	$(agentgroup_list_lo) \
@@ -257,6 +260,7 @@ LLIBAGENTFTS= \
 	agent_sysORTable.ft \
 	agent_trap.ft \
 	kernel.ft \
+	netsnmp_close_fds.ft \
 	snmp_agent.ft \
 	snmp_vars.ft \
 	$(agentgroup_list_ft) \
@@ -342,4 +346,3 @@ mib_modules.lo: mibgroup/mib_module_inits.h
 
 subdirs: agentlib
 # wait for agentlib before building 'subdirs' target
-
diff --git a/agent/agent_handler.c b/agent/agent_handler.c
index 59e9613..a81edcc 100644
--- a/agent/agent_handler.c
+++ b/agent/agent_handler.c
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
@@ -293,8 +298,16 @@ netsnmp_register_handler(netsnmp_handler_registration *reginfo)
      * for handlers that can't GETBULK, force a conversion handler on them 
      */
     if (!(reginfo->modes & HANDLER_CAN_GETBULK)) {
-        netsnmp_inject_handler(reginfo,
-                               netsnmp_get_bulk_to_next_handler());
+        handler = netsnmp_get_bulk_to_next_handler();
+        if (!handler ||
+            (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+            snmp_log(LOG_WARNING, "could not inject bulk to next handler\n");
+            if (handler)
+                netsnmp_handler_free(handler);
+            /** should this be a critical error? */
+            netsnmp_handler_registration_free(reginfo);
+            return SNMP_ERR_GENERR;
+        }
     }
 
     for (handler = reginfo->handler; handler; handler = handler->next) {
@@ -327,6 +340,8 @@ netsnmp_register_handler(netsnmp_handler_registration *reginfo)
 int
 netsnmp_unregister_handler(netsnmp_handler_registration *reginfo)
 {
+    if (!reginfo)
+        return SNMPERR_SUCCESS;
     return unregister_mib_context(reginfo->rootoid, reginfo->rootoid_len,
                                   reginfo->priority,
                                   reginfo->range_subid, reginfo->range_ubound,
@@ -439,8 +454,13 @@ netsnmp_inject_handler_before(netsnmp_handler_registration *reginfo,
             if (strcmp(nexth->handler_name, before_what) == 0)
                 break;
         }
-        if (!nexth)
+        if (!nexth) {
+	    snmp_log(LOG_ERR, "Cannot inject '%s' before '%s': not found\n", handler->handler_name, before_what);
+	    snmp_log(LOG_ERR, "The handlers are:\n");
+	    for (nexth = reginfo->handler; nexth; nexth = nexth->next)
+		snmp_log(LOG_ERR, "  %s\n", nexth->handler_name);
             return SNMP_ERR_GENERR;
+	}
         if (prevh) {
             /* after prevh and before nexth */
             prevh->next = handler;
@@ -1183,7 +1203,7 @@ netsnmp_inject_handler_into_subtree(netsnmp_subtree *tp, const char *name,
                         tptr->label_a, tptr->reginfo->handlerName));
             netsnmp_inject_handler_before(tptr->reginfo, _clone_handler(handler),
                                           before_what);
-        } else {
+        } else if (tptr->reginfo != NULL) {
             for (mh = tptr->reginfo->handler; mh != NULL; mh = mh->next) {
                 if (mh->handler_name && strcmp(mh->handler_name, name) == 0) {
                     DEBUGMSGTL(("injectHandler", "injecting handler into %s\n",
diff --git a/agent/agent_index.c b/agent/agent_index.c
index 0129217..c063a59 100644
--- a/agent/agent_index.c
+++ b/agent/agent_index.c
@@ -65,8 +65,6 @@ struct snmp_index {
     struct snmp_index *next_idx;
 }              *snmp_index_head = NULL;
 
-extern netsnmp_session *main_session;
-
 /*
  * The caller is responsible for free()ing the memory returned by
  * this function.  
diff --git a/agent/agent_registry.c b/agent/agent_registry.c
index 0dd6c42..7d96c65 100644
--- a/agent/agent_registry.c
+++ b/agent/agent_registry.c
@@ -59,6 +59,7 @@
 #include <net-snmp/agent/null.h>
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
+#include <net-snmp/agent/agent_index.h>
 #include <net-snmp/agent/agent_registry.h>
 
 #ifdef USING_AGENTX_SUBAGENT_MODULE
@@ -793,12 +794,12 @@ netsnmp_subtree_load(netsnmp_subtree *new_sub, const char *context_name)
     /*  Handle new subtrees that start in virgin territory.  */
 
     if (tree1 == NULL) {
-        netsnmp_subtree *new2 = NULL;
+        /*netsnmp_subtree *new2 = NULL;*/
 	/*  Is there any overlap with later subtrees?  */
 	if (tree2 && snmp_oid_compare(new_sub->end_a, new_sub->end_len,
 				      tree2->start_a, tree2->start_len) > 0) {
-	    new2 = netsnmp_subtree_split(new_sub, 
-					 tree2->start_a, tree2->start_len);
+	    /*new2 =*/
+            netsnmp_subtree_split(new_sub, tree2->start_a, tree2->start_len);
 	}
 
 	/*  Link the new subtree (less any overlapping region) with the list of
@@ -820,11 +821,15 @@ netsnmp_subtree_load(netsnmp_subtree *new_sub, const char *context_name)
 
             netsnmp_subtree_change_next(new_sub, tree2);
 
+#if 0
+            /* The code below cannot be reached which is why it has been
+               surrounded with #if 0 / #endif. */
 	    /* If there was any overlap, recurse to merge in the overlapping
 	       region (including anything that may follow the overlap).  */
 	    if (new2) {
 		return netsnmp_subtree_load(new2, context_name);
 	    }
+#endif
 	}
     } else {
 	/*  If the new subtree starts *within* an existing registration
@@ -1253,7 +1258,6 @@ netsnmp_register_mib(const char *moduleName,
      */
     if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 			       NETSNMP_DS_AGENT_ROLE) != MASTER_AGENT) {
-        extern struct snmp_session *main_session;
         if (main_session == NULL) {
             register_mib_detach_node(subtree);
 	}
@@ -2232,7 +2236,6 @@ shutdown_tree(void) {
 
 }
 
-extern void     dump_idx_registry(void);
 void
 dump_registry(void)
 {
diff --git a/agent/agent_trap.c b/agent/agent_trap.c
index 080b8bf..97808af 100644
--- a/agent/agent_trap.c
+++ b/agent/agent_trap.c
@@ -10,6 +10,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 /** @defgroup agent_trap Trap generation routines for mib modules to use
  *  @ingroup agent
@@ -921,7 +926,26 @@ send_trap_to_sess(netsnmp_session * sess, netsnmp_pdu *template_pdu)
 #endif
     template_pdu->version = sess->version;
     pdu = snmp_clone_pdu(template_pdu);
+    if(!pdu) {
+        snmp_log(LOG_WARNING, "send_trap: failed to clone PDU\n");
+        return;
+    }
+
     pdu->sessid = sess->sessid; /* AgentX only ? */
+    /*
+     * RFC 3414 sayeth:
+     *
+     * - If an SNMP engine uses a msgID for correlating Response messages to
+     *   outstanding Request messages, then it MUST use different msgIDs in
+     *   all such Request messages that it sends out during a Time Window
+     *   (150 seconds) period.
+     *
+     *   A Command Generator or Notification Originator Application MUST use
+     *   different request-ids in all Request PDUs that it sends out during
+     *   a TimeWindow (150 seconds) period.
+     */
+    pdu->reqid = snmp_get_next_reqid();
+    pdu->msgid = snmp_get_next_msgid();
 
     if ( template_pdu->command == SNMP_MSG_INFORM
 #ifdef USING_AGENTX_PROTOCOL_MODULE
diff --git a/agent/helpers/baby_steps.c b/agent/helpers/baby_steps.c
index d79acbc..64fb28c 100644
--- a/agent/helpers/baby_steps.c
+++ b/agent/helpers/baby_steps.c
@@ -1,6 +1,11 @@
 /*
  * baby_steps.c
  * $Id$
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
@@ -356,8 +361,15 @@ netsnmp_feature_child_of(netsnmp_baby_steps_handler_init,netsnmp_unused)
 void
 netsnmp_baby_steps_handler_init(void)
 {
-    netsnmp_register_handler_by_name("baby_steps",
-                                     netsnmp_baby_steps_handler_get(BABY_STEP_ALL));
+    netsnmp_mib_handler *handler =
+        netsnmp_baby_steps_handler_get(BABY_STEP_ALL);
+    if (NULL == handler) {
+        netsnmp_handler_free(handler);
+        snmp_log(LOG_ERR, "could not create baby steps handler\n");
+        return;
+    }
+
+    netsnmp_register_handler_by_name("baby_steps", handler);
 }
 #endif /* NETSNMP_FEATURE_REMOVE_NETSNMP_BABY_STEPS_HANDLER_INIT */
 
diff --git a/agent/helpers/bulk_to_next.c b/agent/helpers/bulk_to_next.c
index e607eda..ed57aa4 100644
--- a/agent/helpers/bulk_to_next.c
+++ b/agent/helpers/bulk_to_next.c
@@ -1,3 +1,13 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
@@ -132,8 +142,11 @@ netsnmp_bulk_to_next_helper(netsnmp_mib_handler *handler,
 void
 netsnmp_init_bulk_to_next_helper(void)
 {
-    netsnmp_register_handler_by_name("bulk_to_next",
-                                     netsnmp_get_bulk_to_next_handler());
+    netsnmp_mib_handler *hnd = netsnmp_get_bulk_to_next_handler();
+    if (!hnd)
+        return;
+
+    netsnmp_register_handler_by_name("bulk_to_next", hnd);
 }
 /**  @} */
 
diff --git a/agent/helpers/cache_handler.c b/agent/helpers/cache_handler.c
index 520a4cf..fbc58bf 100644
--- a/agent/helpers/cache_handler.c
+++ b/agent/helpers/cache_handler.c
@@ -7,6 +7,11 @@
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
@@ -428,6 +433,28 @@ netsnmp_get_cache_handler(int timeout, NetsnmpCacheLoad * load_hook,
     return ret;
 }
 
+#if !defined(NETSNMP_FEATURE_REMOVE_NETSNMP_CACHE_HANDLER_REGISTER) || !defined(NETSNMP_FEATURE_REMOVE_NETSNMP_REGISTER_CACHE_HANDLER)
+static int
+_cache_handler_register(netsnmp_handler_registration * reginfo,
+                        netsnmp_mib_handler *handler)
+{
+    /** success path */
+    if (reginfo && handler &&
+        (netsnmp_inject_handler(reginfo, handler) == SNMPERR_SUCCESS))
+        return netsnmp_register_handler(reginfo);
+
+    /** error path */
+    snmp_log(LOG_ERR, "could not register cache handler\n");
+
+    if (handler)
+        netsnmp_handler_free(handler);
+
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
+}
+#endif
+
 /** functionally the same as calling netsnmp_register_handler() but also
  * injects a cache handler at the same time for you. */
 netsnmp_feature_child_of(netsnmp_cache_handler_register,netsnmp_unused)
@@ -436,11 +463,13 @@ int
 netsnmp_cache_handler_register(netsnmp_handler_registration * reginfo,
                                netsnmp_cache* cache)
 {
-    netsnmp_mib_handler *handler = NULL;
-    handler = netsnmp_cache_handler_get(cache);
+    if ((NULL == reginfo) || (NULL == cache)) {
+        snmp_log(LOG_ERR, "bad param in netsnmp_cache_handler_register\n");
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
 
-    netsnmp_inject_handler(reginfo, handler);
-    return netsnmp_register_handler(reginfo);
+    return _cache_handler_register(reginfo, netsnmp_cache_handler_get(cache));
 }
 #endif /* NETSNMP_FEATURE_REMOVE_NETSNMP_CACHE_HANDLER_REGISTER */
 
@@ -453,13 +482,19 @@ netsnmp_register_cache_handler(netsnmp_handler_registration * reginfo,
                                int timeout, NetsnmpCacheLoad * load_hook,
                                NetsnmpCacheFree * free_hook)
 {
-    netsnmp_mib_handler *handler = NULL;
-    handler = netsnmp_get_cache_handler(timeout, load_hook, free_hook,
-                                        reginfo->rootoid,
-                                        reginfo->rootoid_len);
+    netsnmp_mib_handler *handler;
+
+    if (NULL == reginfo) {
+        snmp_log(LOG_ERR, "bad param in netsnmp_cache_handler_register\n");
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
+
+    handler =  netsnmp_get_cache_handler(timeout, load_hook, free_hook,
+                                         reginfo->rootoid,
+                                         reginfo->rootoid_len);
 
-    netsnmp_inject_handler(reginfo, handler);
-    return netsnmp_register_handler(reginfo);
+    return _cache_handler_register(reginfo, handler);
 }
 #endif /* NETSNMP_FEATURE_REMOVE_NETSNMP_REGISTER_CACHE_HANDLER */
 
diff --git a/agent/helpers/debug_handler.c b/agent/helpers/debug_handler.c
index e4a8438..579f0c9 100644
--- a/agent/helpers/debug_handler.c
+++ b/agent/helpers/debug_handler.c
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
@@ -161,6 +166,11 @@ netsnmp_debug_helper(netsnmp_mib_handler *handler,
 void
 netsnmp_init_debug_helper(void)
 {
-    netsnmp_register_handler_by_name("debug", netsnmp_get_debug_handler());
+    netsnmp_mib_handler *handler = netsnmp_get_debug_handler();
+    if (!handler) {
+        snmp_log(LOG_ERR, "could not create debug handler\n");
+        return;
+    }
+    netsnmp_register_handler_by_name("debug", handler);
 }
 /**  @} */
diff --git a/agent/helpers/instance.c b/agent/helpers/instance.c
index a5ee841..4a2928c 100644
--- a/agent/helpers/instance.c
+++ b/agent/helpers/instance.c
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
@@ -38,6 +43,7 @@ typedef struct netsnmp_num_file_instance_s {
     int   flags;
 } netsnmp_num_file_instance;
 
+#ifndef NETSNMP_FEATURE_REMOVE_REGISTER_NUM_FILE_INSTANCE
 /** @defgroup instance instance
  *  Process individual MIB instances easily.
  *  @ingroup leaf
@@ -59,6 +65,7 @@ netsnmp_num_file_instance_deref(netsnmp_num_file_instance *nfi)
 	free(nfi);
     }
 }
+#endif /* NETSNMP_FEATURE_REMOVE_REGISTER_NUM_FILE_INSTANCE */
 
 /**
  * Creates an instance helper handler, calls netsnmp_create_handler, which
@@ -96,9 +103,17 @@ int
 netsnmp_register_instance(netsnmp_handler_registration *reginfo)
 {
     netsnmp_mib_handler *handler = netsnmp_get_instance_handler();
-    handler->flags |= MIB_HANDLER_INSTANCE;
-    netsnmp_inject_handler(reginfo, handler);
-    return netsnmp_register_serialize(reginfo);
+    if (handler) {
+        handler->flags |= MIB_HANDLER_INSTANCE;
+        if (netsnmp_inject_handler(reginfo, handler) == SNMPERR_SUCCESS)
+            return netsnmp_register_serialize(reginfo);
+    }
+
+    snmp_log(LOG_ERR, "failed to register instance\n");
+    netsnmp_handler_free(handler);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 /**
@@ -122,11 +137,27 @@ netsnmp_register_instance(netsnmp_handler_registration *reginfo)
 int
 netsnmp_register_read_only_instance(netsnmp_handler_registration *reginfo)
 {
-    netsnmp_inject_handler(reginfo, netsnmp_get_instance_handler());
-    netsnmp_inject_handler(reginfo, netsnmp_get_read_only_handler());
-    return netsnmp_register_serialize(reginfo);
+    netsnmp_mib_handler *h1, *h2;
+    if (!reginfo)
+        return MIB_REGISTRATION_FAILED;
+
+    h1 = netsnmp_get_instance_handler();
+    h2 = netsnmp_get_read_only_handler();
+    if (h1 && h2 && netsnmp_inject_handler(reginfo, h1) == SNMPERR_SUCCESS) {
+        h1 = NULL;
+        if (netsnmp_inject_handler(reginfo, h2) == SNMPERR_SUCCESS)
+            return netsnmp_register_serialize(reginfo);
+    }
+
+    snmp_log(LOG_ERR, "failed to register read only instance\n");
+    netsnmp_handler_free(h1);
+    netsnmp_handler_free(h2);
+    netsnmp_handler_registration_free(reginfo);
+
+   return MIB_REGISTRATION_FAILED;
 }
 
+#ifndef NETSNMP_FEATURE_REMOVE_REGISTER_NUM_FILE_INSTANCE
 static
 netsnmp_handler_registration *
 get_reg(const char *name,
@@ -142,31 +173,45 @@ get_reg(const char *name,
 
     if (subhandler) {
         myreg =
-            netsnmp_create_handler_registration(name,
-                                                subhandler,
-                                                reg_oid, reg_oid_len,
-                                                modes);
+            netsnmp_create_handler_registration(name, subhandler, reg_oid,
+                                                reg_oid_len, modes);
+        if (!myreg)
+            return NULL;
         myhandler = netsnmp_create_handler(ourname, scalarh);
+        if (!myhandler) {
+            netsnmp_handler_registration_free(myreg);
+            return NULL;
+        }
         myhandler->myvoid = it;
 	myhandler->data_clone = (void*(*)(void*))netsnmp_num_file_instance_ref;
 	myhandler->data_free = (void(*)(void*))netsnmp_num_file_instance_deref;
-        netsnmp_inject_handler(myreg, myhandler);
+        if (netsnmp_inject_handler(myreg, myhandler) != SNMPERR_SUCCESS) {
+            netsnmp_handler_free(myhandler);
+            netsnmp_handler_registration_free(myreg);
+            return NULL;
+        }
     } else {
-        myreg =
-            netsnmp_create_handler_registration(name,
-                                                scalarh,
-                                                reg_oid, reg_oid_len,
-                                                modes);
+        myreg = netsnmp_create_handler_registration(name, scalarh, reg_oid,
+                                                    reg_oid_len, modes);
+        if (!myreg)
+            return NULL;
         myreg->handler->myvoid = it;
 	myreg->handler->data_clone
 	    = (void *(*)(void *))netsnmp_num_file_instance_ref;
 	myreg->handler->data_free
 	    = (void (*)(void *))netsnmp_num_file_instance_deref;
     }
-    if (contextName)
+    if (contextName) {
         myreg->contextName = strdup(contextName);
+        if (!myreg->contextName) {
+            netsnmp_handler_registration_free(myreg);
+            return NULL;
+        }
+    }
+
     return myreg;
 }
+#endif /* NETSNMP_FEATURE_REMOVE_REGISTER_NUM_FILE_INSTANCE */
 
 /* Watched 'long' instances are writable on both 32-bit and 64-bit systems  */
 netsnmp_feature_child_of(read_only_ulong_instance,instance)
diff --git a/agent/helpers/null.c b/agent/helpers/null.c
index 97dfc92..879ad16 100644
--- a/agent/helpers/null.c
+++ b/agent/helpers/null.c
@@ -1,3 +1,13 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
@@ -32,6 +42,16 @@ netsnmp_register_null_context(oid * loc, size_t loc_len,
         if (contextName)
             reginfo->contextName = strdup(contextName);
         reginfo->modes = HANDLER_CAN_DEFAULT | HANDLER_CAN_GETBULK;
+
+        if (!reginfo->handlerName || !reginfo->handler ||
+            (contextName && !reginfo->contextName)) {
+            snmp_log(LOG_ERR,"null context allocation failure(s)\n");
+            netsnmp_handler_registration_free(reginfo);
+            return MIB_REGISTRATION_FAILED;
+        }
+    } else {
+        snmp_log(LOG_ERR,"null context allocation failure\n");
+        return MIB_REGISTRATION_FAILED;
     }
     return netsnmp_register_handler(reginfo);
 }
diff --git a/agent/helpers/old_api.c b/agent/helpers/old_api.c
index d2b99d9..f0e4ea1 100644
--- a/agent/helpers/old_api.c
+++ b/agent/helpers/old_api.c
@@ -1,3 +1,13 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
@@ -30,7 +40,6 @@ static void free_wrapper(void * p)
  * don't use these! 
  */
 void            set_current_agent_session(netsnmp_agent_session *asp);
-netsnmp_agent_session *netsnmp_get_current_agent_session(void);
 
 /** @defgroup old_api old_api
  *  Calls mib module code written in the old style of code.
@@ -84,6 +93,7 @@ netsnmp_register_old_api(const char *moduleName,
 {
 
     unsigned int    i;
+    int             res;
 
     /*
      * register all subtree nodes 
@@ -103,9 +113,12 @@ netsnmp_register_old_api(const char *moduleName,
         reginfo->rootoid_len = (mibloclen + vp->namelen);
         reginfo->rootoid =
             (oid *) malloc(reginfo->rootoid_len * sizeof(oid));
-        if (reginfo->rootoid == NULL) {
+        if (NULL == reginfo->handler || NULL == reginfo->handlerName ||
+            NULL == reginfo->rootoid) {
+            netsnmp_handler_free(reginfo->handler);
             SNMP_FREE(vp);
             SNMP_FREE(reginfo->handlerName);
+            SNMP_FREE(reginfo->rootoid);
             SNMP_FREE(reginfo);
             return SNMP_ERR_GENERR;
         }
@@ -130,9 +143,11 @@ netsnmp_register_old_api(const char *moduleName,
         /*
          * register ourselves in the mib tree 
          */
-        if (netsnmp_register_handler(reginfo) != MIB_REGISTERED_OK) {
-            /** netsnmp_handler_registration_free(reginfo); already freed */
-            /* SNMP_FREE(vp); already freed */
+        res = netsnmp_register_handler(reginfo);
+        if (MIB_REGISTERED_OK != res) {
+            /** reginfo already freed on error. */
+            snmp_log(LOG_WARNING, "old_api handler registration failed\n");
+            return res;
         }
     }
     return SNMPERR_SUCCESS;
@@ -168,23 +183,17 @@ netsnmp_register_mib_table_row(const char *moduleName,
              * Unregister whatever we have registered so far, and
              * return an error.  
              */
+            snmp_log(LOG_ERR, "mib table row registration failed\n");
             rc = MIB_REGISTRATION_FAILED;
             break;
         }
-        memset(r, 0, sizeof(netsnmp_handler_registration));
 
         r->handler = get_old_api_handler();
         r->handlerName = strdup(moduleName);
-
-        if (r->handlerName == NULL) {
-            netsnmp_handler_registration_free(r);
-            break;
-        }
-
         r->rootoid_len = mibloclen;
         r->rootoid = (oid *) malloc(r->rootoid_len * sizeof(oid));
-
-        if (r->rootoid == NULL) {
+        if (r->handler == NULL || r->handlerName == NULL ||
+            r->rootoid == NULL) {
             netsnmp_handler_registration_free(r);
             rc = MIB_REGISTRATION_FAILED;
             break;
@@ -201,15 +210,9 @@ netsnmp_register_mib_table_row(const char *moduleName,
         r->handler->data_clone = (void *(*)(void *))netsnmp_duplicate_variable;
         r->handler->data_free = free;
 
-        if (r->handler->myvoid == NULL) {
-            netsnmp_handler_registration_free(r);
-            rc = MIB_REGISTRATION_FAILED;
-            break;
-        }
-
         r->contextName = (context) ? strdup(context) : NULL;
-
-        if (context != NULL && r->contextName == NULL) {
+        if (r->handler->myvoid == NULL ||
+            (context != NULL && r->contextName == NULL)) {
             netsnmp_handler_registration_free(r);
             rc = MIB_REGISTRATION_FAILED;
             break;
@@ -227,9 +230,10 @@ netsnmp_register_mib_table_row(const char *moduleName,
         if ((rc =
              netsnmp_register_handler_nocallback(r)) !=
             MIB_REGISTERED_OK) {
+            snmp_log(LOG_ERR, "mib table row registration failed\n");
             DEBUGMSGTL(("netsnmp_register_mib_table_row",
                         "register failed %d\n", rc));
-            netsnmp_handler_registration_free(r);
+            /** reginfo already freed */
             break;
         }
 
@@ -319,8 +323,11 @@ netsnmp_old_api_helper(netsnmp_mib_handler *handler,
              * Actually call the old mib-module function 
              */
             if (vp && vp->findVar) {
-                memcpy(tmp_name, requests->requestvb->name,
-                                 requests->requestvb->name_length*sizeof(oid));
+                tmp_len = requests->requestvb->name_length*sizeof(oid);
+                memcpy(tmp_name, requests->requestvb->name, tmp_len);
+                /** clear the rest of tmp_name to keep valgrind happy */
+                memset(&tmp_name[requests->requestvb->name_length], 0x0,
+                       sizeof(tmp_name)-tmp_len);
                 tmp_len = requests->requestvb->name_length;
                 access = (*(vp->findVar)) (cvp, tmp_name, &tmp_len,
                                            exact, &len, &write_method);
diff --git a/agent/helpers/read_only.c b/agent/helpers/read_only.c
index 0b06d4f..359d91a 100644
--- a/agent/helpers/read_only.c
+++ b/agent/helpers/read_only.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
@@ -73,8 +84,12 @@ netsnmp_read_only_helper(netsnmp_mib_handler *handler,
 void
 netsnmp_init_read_only_helper(void)
 {
-    netsnmp_register_handler_by_name("read_only",
-                                     netsnmp_get_read_only_handler());
+    netsnmp_mib_handler *handler = netsnmp_get_read_only_handler();
+    if (!handler) {
+        snmp_log(LOG_ERR, "could not create read_only handler\n");
+        return;
+    }
+    netsnmp_register_handler_by_name("read_only", handler);
 }
 /**  @} */
 
diff --git a/agent/helpers/row_merge.c b/agent/helpers/row_merge.c
index 4a8e476..0198791 100644
--- a/agent/helpers/row_merge.c
+++ b/agent/helpers/row_merge.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
@@ -50,9 +61,21 @@ netsnmp_feature_child_of(register_row_merge, row_merge_all)
 int
 netsnmp_register_row_merge(netsnmp_handler_registration *reginfo)
 {
-    netsnmp_inject_handler(reginfo,
-		    netsnmp_get_row_merge_handler(reginfo->rootoid_len+1));
-    return netsnmp_register_handler(reginfo);
+    netsnmp_mib_handler *handler;
+
+    if (!reginfo)
+        return MIB_REGISTRATION_FAILED;
+
+    handler = netsnmp_get_row_merge_handler(reginfo->rootoid_len+1);
+    if (handler &&
+        (netsnmp_inject_handler(reginfo, handler) == SNMPERR_SUCCESS))
+        return netsnmp_register_handler(reginfo);
+
+    snmp_log(LOG_ERR, "failed to register row_merge\n");
+    netsnmp_handler_free(handler);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 #endif /* NETSNMP_FEATURE_REMOVE_REGISTER_ROW_MERGE */
 
diff --git a/agent/helpers/scalar.c b/agent/helpers/scalar.c
index 7a4c9e0..63aeb37 100644
--- a/agent/helpers/scalar.c
+++ b/agent/helpers/scalar.c
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
@@ -74,6 +79,8 @@ netsnmp_get_scalar_handler(void)
 int
 netsnmp_register_scalar(netsnmp_handler_registration *reginfo)
 {
+    netsnmp_mib_handler *h1, *h2;
+
     /*
      * Extend the registered OID with space for the instance subid
      * (but don't extend the length just yet!)
@@ -82,9 +89,22 @@ netsnmp_register_scalar(netsnmp_handler_registration *reginfo)
                                     (reginfo->rootoid_len+1) * sizeof(oid) );
     reginfo->rootoid[ reginfo->rootoid_len ] = 0;
 
-    netsnmp_inject_handler(reginfo, netsnmp_get_instance_handler());
-    netsnmp_inject_handler(reginfo, netsnmp_get_scalar_handler());
-    return netsnmp_register_serialize(reginfo);
+    h1 = netsnmp_get_instance_handler();
+    h2 = netsnmp_get_scalar_handler();
+    if (h1 && h2) {
+        if (netsnmp_inject_handler(reginfo, h1) == SNMPERR_SUCCESS) {
+            h1 = NULL;
+            if (netsnmp_inject_handler(reginfo, h2) == SNMPERR_SUCCESS)
+                return netsnmp_register_serialize(reginfo);
+        }
+    }
+
+    snmp_log(LOG_ERR, "register scalar failed\n");
+    netsnmp_handler_free(h1);
+    netsnmp_handler_free(h2);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 
@@ -99,7 +119,7 @@ netsnmp_register_scalar(netsnmp_handler_registration *reginfo)
  *                a read only scalar helper handler.
  *
  * @return  MIB_REGISTERED_OK is returned if the registration was a success.
- *  	Failures are MIB_REGISTRATION_FAILURE and MIB_DUPLICATE_REGISTRATION.
+ *  	Failures are MIB_REGISTRATION_FAILED and MIB_DUPLICATE_REGISTRATION.
  *
  * @see netsnmp_register_scalar
  * @see netsnmp_get_scalar_handler
@@ -109,6 +129,7 @@ netsnmp_register_scalar(netsnmp_handler_registration *reginfo)
 int
 netsnmp_register_read_only_scalar(netsnmp_handler_registration *reginfo)
 {
+    netsnmp_mib_handler *h1, *h2, *h3;
     /*
      * Extend the registered OID with space for the instance subid
      * (but don't extend the length just yet!)
@@ -117,10 +138,27 @@ netsnmp_register_read_only_scalar(netsnmp_handler_registration *reginfo)
                                     (reginfo->rootoid_len+1) * sizeof(oid) );
     reginfo->rootoid[ reginfo->rootoid_len ] = 0;
 
-    netsnmp_inject_handler(reginfo, netsnmp_get_instance_handler());
-    netsnmp_inject_handler(reginfo, netsnmp_get_scalar_handler());
-    netsnmp_inject_handler(reginfo, netsnmp_get_read_only_handler());
-    return netsnmp_register_serialize(reginfo);
+    h1 = netsnmp_get_instance_handler();
+    h2 = netsnmp_get_scalar_handler();
+    h3 = netsnmp_get_read_only_handler();
+    if (h1 && h2 && h3) {
+        if (netsnmp_inject_handler(reginfo, h1) == SNMPERR_SUCCESS) {
+            h1 = NULL;
+            if (netsnmp_inject_handler(reginfo, h2) == SNMPERR_SUCCESS) {
+                h2 = NULL;
+                if (netsnmp_inject_handler(reginfo, h3) == SNMPERR_SUCCESS)
+                    return netsnmp_register_serialize(reginfo);
+            }
+        }
+    }
+
+    snmp_log(LOG_ERR, "register read only scalar failed\n");
+    netsnmp_handler_free(h1);
+    netsnmp_handler_free(h2);
+    netsnmp_handler_free(h3);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 
diff --git a/agent/helpers/scalar_group.c b/agent/helpers/scalar_group.c
index 6b7f098..d9e0afd 100644
--- a/agent/helpers/scalar_group.c
+++ b/agent/helpers/scalar_group.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
@@ -60,9 +71,25 @@ int
 netsnmp_register_scalar_group(netsnmp_handler_registration *reginfo,
                               oid first, oid last)
 {
-    netsnmp_inject_handler(reginfo, netsnmp_get_instance_handler());
-    netsnmp_inject_handler(reginfo, netsnmp_get_scalar_group_handler(first, last));
-    return netsnmp_register_serialize(reginfo);
+    netsnmp_mib_handler *h1, *h2;
+
+    h1 = netsnmp_get_instance_handler();
+    h2 = netsnmp_get_scalar_group_handler(first, last);
+
+    if (h1 && h2) {
+        if (netsnmp_inject_handler(reginfo, h1) == SNMPERR_SUCCESS) {
+            h1 = NULL;
+            if (netsnmp_inject_handler(reginfo, h2) == SNMPERR_SUCCESS)
+                return netsnmp_register_serialize(reginfo);
+        }
+    }
+
+    snmp_log(LOG_ERR, "register read only scalar group failed\n");
+    netsnmp_handler_free(h1);
+    netsnmp_handler_free(h2);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 
diff --git a/agent/helpers/serialize.c b/agent/helpers/serialize.c
index eec66b4..9680797 100644
--- a/agent/helpers/serialize.c
+++ b/agent/helpers/serialize.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
@@ -33,7 +44,15 @@ netsnmp_get_serialize_handler(void)
 int
 netsnmp_register_serialize(netsnmp_handler_registration *reginfo)
 {
-    netsnmp_inject_handler(reginfo, netsnmp_get_serialize_handler());
+    netsnmp_mib_handler *handler = netsnmp_get_serialize_handler();
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create serialize handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
+
     return netsnmp_register_handler(reginfo);
 }
 
@@ -86,8 +105,12 @@ netsnmp_serialize_helper_handler(netsnmp_mib_handler *handler,
 void
 netsnmp_init_serialize(void)
 {
-    netsnmp_register_handler_by_name("serialize",
-                                     netsnmp_get_serialize_handler());
+    netsnmp_mib_handler *handler = netsnmp_get_serialize_handler();
+    if (!handler) {
+        snmp_log(LOG_ERR, "could not create serialize handler\n");
+        return;
+    }
+    netsnmp_register_handler_by_name("serialize", handler);
 }
 /**  @} */
 
diff --git a/agent/helpers/snmp_get_statistic.c b/agent/helpers/snmp_get_statistic.c
index efac2ac..65a78bf 100644
--- a/agent/helpers/snmp_get_statistic.c
+++ b/agent/helpers/snmp_get_statistic.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
@@ -52,9 +63,17 @@ int
 netsnmp_register_statistic_handler(netsnmp_handler_registration *reginfo,
                                    oid start, int begin, int end)
 {
-    netsnmp_inject_handler(reginfo,
-                           netsnmp_get_statistic_handler(begin - start));
-    return netsnmp_register_scalar_group(reginfo, start, start + (end - begin));
+    netsnmp_mib_handler *handler =
+        netsnmp_get_statistic_handler(begin - start);
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create statistic handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
+    return netsnmp_register_scalar_group(reginfo, start,
+                                         start + (end - begin));
 }
 #else /* !NETSNMP_FEATURE_REMOVE_HELPER_GET_STATISTICS */
 netsnmp_feature_unused(helper_statistics);
diff --git a/agent/helpers/table.c b/agent/helpers/table.c
index 882e84c..9e575d5 100644
--- a/agent/helpers/table.c
+++ b/agent/helpers/table.c
@@ -17,6 +17,11 @@
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -151,9 +156,14 @@ int
 netsnmp_register_table(netsnmp_handler_registration *reginfo,
                        netsnmp_table_registration_info *tabreq)
 {
-    int rc = netsnmp_inject_handler(reginfo, netsnmp_get_table_handler(tabreq));
-    if (SNMPERR_SUCCESS != rc)
-        return rc;
+    netsnmp_mib_handler *handler = netsnmp_get_table_handler(tabreq);
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create table handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
 
     return netsnmp_register_handler(reginfo);
 }
@@ -406,6 +416,8 @@ table_helper_handler(netsnmp_mib_handler *handler,
             if (reqinfo->mode == MODE_GET)
                 table_helper_cleanup(reqinfo, request,
                                      SNMP_NOSUCHOBJECT);
+            else
+                request->processed = 1; /* skip if next handler called */
             continue;
         }
 
@@ -483,6 +495,8 @@ table_helper_handler(netsnmp_mib_handler *handler,
 #endif /* NETSNMP_NO_WRITE_SUPPORT */
                     table_helper_cleanup(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
+                else
+                    request->processed = 1; /* skip if next handler called */
                 continue;
             }
             /*
@@ -828,12 +842,11 @@ netsnmp_sparse_table_register(netsnmp_handler_registration *reginfo,
                        netsnmp_table_registration_info *tabreq)
 {
     netsnmp_mib_handler *handler1, *handler2;
-    int rc;
 
     handler1 = netsnmp_create_handler(SPARSE_TABLE_HANDLER_NAME,
                                      sparse_table_helper_handler);
     if (NULL == handler1)
-        return SNMP_ERR_GENERR;
+        return MIB_REGISTRATION_FAILED;
 
     handler2 = netsnmp_get_table_handler(tabreq);
     if (NULL == handler2 ) {
@@ -841,18 +854,16 @@ netsnmp_sparse_table_register(netsnmp_handler_registration *reginfo,
         return SNMP_ERR_GENERR;
     }
 
-    rc = netsnmp_inject_handler(reginfo, handler1);
-    if (SNMPERR_SUCCESS != rc) {
+    if (SNMPERR_SUCCESS != netsnmp_inject_handler(reginfo, handler1)) {
         netsnmp_handler_free(handler1);
         netsnmp_handler_free(handler2);
-        return rc;
+        return MIB_REGISTRATION_FAILED;
     }
 
-    rc = netsnmp_inject_handler(reginfo, handler2);
-    if (SNMPERR_SUCCESS != rc) {
+    if (SNMPERR_SUCCESS != netsnmp_inject_handler(reginfo, handler2)) {
         /** handler1 is in reginfo... remove and free?? */
         netsnmp_handler_free(handler2);
-        return rc;
+        return MIB_REGISTRATION_FAILED;
     }
 
     /** both handlers now in reginfo, so nothing to do on error */
diff --git a/agent/helpers/table_array.c b/agent/helpers/table_array.c
index 7c98aae..5892fe6 100644
--- a/agent/helpers/table_array.c
+++ b/agent/helpers/table_array.c
@@ -1,6 +1,15 @@
 /*
  * table_array.c
  * $Id$
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -212,9 +221,17 @@ netsnmp_table_array_register(netsnmp_handler_registration *reginfo,
                              netsnmp_container *container,
                              int group_rows)
 {
-    netsnmp_inject_handler(reginfo,
-                           netsnmp_create_handler(reginfo->handlerName,
-                               netsnmp_table_array_helper_handler));
+    netsnmp_mib_handler *handler =
+        netsnmp_create_handler(reginfo->handlerName,
+                               netsnmp_table_array_helper_handler);
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create table array handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return SNMP_ERR_GENERR;
+    }
+
     return netsnmp_table_container_register(reginfo, tabreg, cb,
                                             container, group_rows);
 }
diff --git a/agent/helpers/table_container.c b/agent/helpers/table_container.c
index 08e9741..f7a7c34 100644
--- a/agent/helpers/table_container.c
+++ b/agent/helpers/table_container.c
@@ -1,6 +1,15 @@
 /*
  * table_container.c
  * $Id$
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -340,6 +349,7 @@ netsnmp_container_table_register(netsnmp_handler_registration *reginfo,
 
     if ((NULL == reginfo) || (NULL == reginfo->handler) || (NULL == tabreg)) {
         snmp_log(LOG_ERR, "bad param in netsnmp_container_table_register\n");
+        netsnmp_handler_registration_free(reginfo);
         return SNMPERR_GENERR;
     }
 
@@ -347,7 +357,13 @@ netsnmp_container_table_register(netsnmp_handler_registration *reginfo,
         container = netsnmp_container_find(reginfo->handlerName);
 
     handler = netsnmp_container_table_handler_get(tabreg, container, key_type);
-    netsnmp_inject_handler(reginfo, handler );
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create container table handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
 
     return netsnmp_register_table(reginfo, tabreg);
 }
diff --git a/agent/helpers/table_data.c b/agent/helpers/table_data.c
index 659d903..2941f50 100644
--- a/agent/helpers/table_data.c
+++ b/agent/helpers/table_data.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
@@ -430,7 +441,15 @@ netsnmp_register_table_data(netsnmp_handler_registration *reginfo,
                             netsnmp_table_data *table,
                             netsnmp_table_registration_info *table_info)
 {
-    netsnmp_inject_handler(reginfo, netsnmp_get_table_data_handler(table));
+    netsnmp_mib_handler *handler = netsnmp_get_table_data_handler(table);
+    if (!table || !handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create table data handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
+
     return netsnmp_register_table(reginfo, table_info);
 }
 
@@ -443,7 +462,15 @@ netsnmp_register_read_only_table_data(netsnmp_handler_registration *reginfo,
                                       netsnmp_table_data *table,
                                       netsnmp_table_registration_info *table_info)
 {
-    netsnmp_inject_handler(reginfo, netsnmp_get_read_only_handler());
+    netsnmp_mib_handler *handler = netsnmp_get_read_only_handler();
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create read only table data handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
+
     return netsnmp_register_table_data(reginfo, table, table_info);
 }
 #endif /* NETSNMP_FEATURE_REMOVE_REGISTER_READ_ONLY_TABLE_DATA */
diff --git a/agent/helpers/table_dataset.c b/agent/helpers/table_dataset.c
index 931c27a..2f25795 100644
--- a/agent/helpers/table_dataset.c
+++ b/agent/helpers/table_dataset.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
@@ -425,6 +436,7 @@ netsnmp_register_table_data_set(netsnmp_handler_registration *reginfo,
                                 netsnmp_table_data_set *data_set,
                                 netsnmp_table_registration_info *table_info)
 {
+    netsnmp_mib_handler *handler;
     int ret;
 
     if (NULL == table_info) {
@@ -462,8 +474,15 @@ netsnmp_register_table_data_set(netsnmp_handler_registration *reginfo,
             table_info->max_column = maxcol;
     }
 
-    netsnmp_inject_handler(reginfo,
-                           netsnmp_get_table_data_set_handler(data_set));
+    handler = netsnmp_get_table_data_set_handler(data_set);
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create table data set handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return MIB_REGISTRATION_FAILED;
+    }
+
     ret = netsnmp_register_table_data(reginfo, data_set->table,
                                        table_info);
     if (ret == SNMPERR_SUCCESS && reginfo->handler)
diff --git a/agent/helpers/table_iterator.c b/agent/helpers/table_iterator.c
index 8ed5cd0..dbff8e2 100644
--- a/agent/helpers/table_iterator.c
+++ b/agent/helpers/table_iterator.c
@@ -10,6 +10,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 /** @defgroup table_iterator table_iterator
@@ -259,14 +264,21 @@ int
 netsnmp_register_table_iterator(netsnmp_handler_registration *reginfo,
                                 netsnmp_iterator_info *iinfo)
 {
+    netsnmp_mib_handler *handler = netsnmp_get_table_iterator_handler(iinfo);
+
+    if (!reginfo || !iinfo || !handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create iterator table handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return SNMP_ERR_GENERR;
+    }
+
 #ifndef NETSNMP_FEATURE_REMOVE_STASH_CACHE
     reginfo->modes |= HANDLER_CAN_STASH;
 #endif  /* NETSNMP_FEATURE_REMOVE_STASH_CACHE */
-    netsnmp_inject_handler(reginfo,
-                           netsnmp_get_table_iterator_handler(iinfo));
-    if (!iinfo)
-        return SNMPERR_GENERR;
-    if (!iinfo->indexes && iinfo->table_reginfo &&
+
+   if (!iinfo->indexes && iinfo->table_reginfo &&
                            iinfo->table_reginfo->indexes )
         iinfo->indexes = snmp_clone_varbind( iinfo->table_reginfo->indexes );
 
@@ -731,6 +743,7 @@ netsnmp_table_iterator_helper_handler(netsnmp_mib_handler *handler,
                                 if (free_this_index_search)
                                     snmp_free_varbind
                                         (free_this_index_search);
+                                SNMP_FREE(reqtmp);
                                 return SNMP_ERR_GENERR;
                             }
                             vb->type = ASN_NULL;
diff --git a/agent/helpers/table_row.c b/agent/helpers/table_row.c
index 2a33f23..f37a12d 100644
--- a/agent/helpers/table_row.c
+++ b/agent/helpers/table_row.c
@@ -3,7 +3,14 @@
  *
  * Helper for registering single row slices of a shared table
  *
- * $Id$
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #define TABLE_ROW_DATA  "table_row"
 
@@ -110,6 +117,7 @@ netsnmp_table_row_register(netsnmp_handler_registration *reginfo,
 
     if ((NULL == reginfo) || (NULL == reginfo->handler) || (NULL == tabreg)) {
         snmp_log(LOG_ERR, "bad param in netsnmp_table_row_register\n");
+        netsnmp_handler_registration_free(reginfo);
         return SNMPERR_GENERR;
     }
 
@@ -150,7 +158,13 @@ netsnmp_table_row_register(netsnmp_handler_registration *reginfo,
          * ... insert a minimal handler ...
          */
     handler = netsnmp_table_row_handler_get(row);
-    netsnmp_inject_handler(reginfo, handler );
+    if (!handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create table row handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return SNMP_ERR_GENERR;
+    }
 
         /*
          * ... and register the row
diff --git a/agent/helpers/table_tdata.c b/agent/helpers/table_tdata.c
index 8865084..d813345 100644
--- a/agent/helpers/table_tdata.c
+++ b/agent/helpers/table_tdata.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
@@ -405,7 +416,16 @@ netsnmp_tdata_register(netsnmp_handler_registration    *reginfo,
                        netsnmp_tdata                   *table,
                        netsnmp_table_registration_info *table_info)
 {
-    netsnmp_inject_handler(reginfo, netsnmp_get_tdata_handler(table));
+    netsnmp_mib_handler *handler = netsnmp_get_tdata_handler(table);
+
+    if (!reginfo || !table || !table_info || !handler ||
+        (netsnmp_inject_handler(reginfo, handler) != SNMPERR_SUCCESS)) {
+        snmp_log(LOG_ERR, "could not create tdata handler\n");
+        netsnmp_handler_free(handler);
+        netsnmp_handler_registration_free(reginfo);
+        return SNMP_ERR_GENERR;
+    }
+
     return netsnmp_container_table_register(reginfo, table_info,
                   table->container, TABLE_CONTAINER_KEY_NETSNMP_INDEX);
 }
diff --git a/agent/helpers/watcher.c b/agent/helpers/watcher.c
index 9b3933b..780c852 100644
--- a/agent/helpers/watcher.c
+++ b/agent/helpers/watcher.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
@@ -107,13 +118,22 @@ int
 netsnmp_register_watched_instance(netsnmp_handler_registration *reginfo,
                                   netsnmp_watcher_info         *watchinfo)
 {
-    netsnmp_mib_handler *whandler;
+    netsnmp_mib_handler *whandler = NULL;
+
+    if (reginfo && watchinfo) {
+        whandler = netsnmp_get_watcher_handler();
+        if (whandler) {
+            whandler->myvoid = (void *)watchinfo;
+            if (netsnmp_inject_handler(reginfo, whandler) == SNMPERR_SUCCESS)
+                return netsnmp_register_instance(reginfo);
+        }
+    }
 
-    whandler         = netsnmp_get_watcher_handler();
-    whandler->myvoid = (void *)watchinfo;
+    snmp_log(LOG_ERR, "could not create watched instance handler\n");
+    netsnmp_handler_free(whandler);
+    netsnmp_handler_registration_free(reginfo);
 
-    netsnmp_inject_handler(reginfo, whandler);
-    return netsnmp_register_instance(reginfo);
+    return MIB_REGISTRATION_FAILED;
 }
 
 /**
@@ -125,14 +145,23 @@ int
 netsnmp_register_watched_instance2(netsnmp_handler_registration *reginfo,
 				   netsnmp_watcher_info         *watchinfo)
 {
-    netsnmp_mib_handler *whandler;
+    netsnmp_mib_handler *whandler = NULL;
 
-    whandler         = netsnmp_get_watcher_handler();
-    whandler->myvoid = (void *)watchinfo;
-    netsnmp_owns_watcher_info(whandler);
+    if (reginfo && watchinfo) {
+        whandler = netsnmp_get_watcher_handler();
+        if (whandler) {
+            whandler->myvoid = (void *)watchinfo;
+            netsnmp_owns_watcher_info(whandler);
+            if (netsnmp_inject_handler(reginfo, whandler) == SNMPERR_SUCCESS)
+                return netsnmp_register_instance(reginfo);
+        }
+    }
+
+    snmp_log(LOG_ERR, "could not create watched instance2 handler\n");
+    netsnmp_handler_free(whandler);
+    netsnmp_handler_registration_free(reginfo);
 
-    netsnmp_inject_handler(reginfo, whandler);
-    return netsnmp_register_instance(reginfo);
+    return MIB_REGISTRATION_FAILED;
 }
 
 /**
@@ -144,13 +173,22 @@ int
 netsnmp_register_watched_scalar(netsnmp_handler_registration *reginfo,
                                   netsnmp_watcher_info         *watchinfo)
 {
-    netsnmp_mib_handler *whandler;
+    netsnmp_mib_handler *whandler = NULL;
 
-    whandler         = netsnmp_get_watcher_handler();
-    whandler->myvoid = (void *)watchinfo;
+    if (reginfo && watchinfo) {
+        whandler = netsnmp_get_watcher_handler();
+        if (whandler) {
+            whandler->myvoid = (void *)watchinfo;
+            if (netsnmp_inject_handler(reginfo, whandler) == SNMPERR_SUCCESS)
+                return netsnmp_register_scalar(reginfo);
+        }
+    }
+
+    snmp_log(LOG_ERR, "could not create watched scalar handler\n");
+    netsnmp_handler_free(whandler);
+    netsnmp_handler_registration_free(reginfo);
 
-    netsnmp_inject_handler(reginfo, whandler);
-    return netsnmp_register_scalar(reginfo);
+    return MIB_REGISTRATION_FAILED;
 }
 
 /**
@@ -162,14 +200,23 @@ int
 netsnmp_register_watched_scalar2(netsnmp_handler_registration *reginfo,
                                   netsnmp_watcher_info         *watchinfo)
 {
-    netsnmp_mib_handler *whandler;
+    netsnmp_mib_handler *whandler = NULL;
 
-    whandler         = netsnmp_get_watcher_handler();
-    whandler->myvoid = (void *)watchinfo;
-    netsnmp_owns_watcher_info(whandler);
+    if (reginfo && watchinfo) {
+        whandler = netsnmp_get_watcher_handler();
+        if (whandler) {
+            whandler->myvoid = (void *)watchinfo;
+            netsnmp_owns_watcher_info(whandler);
+            if (netsnmp_inject_handler(reginfo, whandler) == SNMPERR_SUCCESS)
+                return netsnmp_register_scalar(reginfo);
+        }
+    }
 
-    netsnmp_inject_handler(reginfo, whandler);
-    return netsnmp_register_scalar(reginfo);
+    snmp_log(LOG_ERR, "could not create watched scalar2 handler\n");
+    netsnmp_handler_free(whandler);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 void
@@ -242,7 +289,9 @@ netsnmp_watcher_helper_handler(netsnmp_mib_handler *handler,
                                netsnmp_request_info *requests)
 {
     netsnmp_watcher_info  *winfo = (netsnmp_watcher_info *) handler->myvoid;
+#ifndef NETSNMP_NO_WRITE_SUPPORT
     netsnmp_watcher_cache *old_data;
+#endif /* NETSNMP_NO_WRITE_SUPPORT */
 
     DEBUGMSGTL(("helper:watcher", "Got request:  %d\n", reqinfo->mode));
     DEBUGMSGTL(( "helper:watcher", "  oid:"));
@@ -359,9 +408,16 @@ netsnmp_watched_timestamp_register(netsnmp_mib_handler *whandler,
                                    netsnmp_handler_registration *reginfo,
                                    marker_t timestamp)
 {
-    whandler->myvoid = (void *)timestamp;
-    netsnmp_inject_handler(reginfo, whandler);
-    return netsnmp_register_scalar(reginfo);   /* XXX - or instance? */
+    if (reginfo && whandler && timestamp) {
+        whandler->myvoid = (void *)timestamp;
+        if (netsnmp_inject_handler(reginfo, whandler) == SNMPERR_SUCCESS)
+            return netsnmp_register_scalar(reginfo);   /* XXX - or instance? */
+    }
+
+    snmp_log(LOG_ERR, "could not create watched timestamp handler\n");
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 #ifndef NETSNMP_FEATURE_REMOVE_WATCHER_REGISTER_TIMESTAMP
@@ -370,10 +426,15 @@ netsnmp_register_watched_timestamp(netsnmp_handler_registration *reginfo,
                                    marker_t timestamp)
 {
     netsnmp_mib_handler *whandler;
+    int                  rc;
 
     whandler         = netsnmp_get_watched_timestamp_handler();
 
-    return netsnmp_watched_timestamp_register(whandler, reginfo, timestamp);
+    rc = netsnmp_watched_timestamp_register(whandler, reginfo, timestamp);
+    if (MIB_REGISTRATION_FAILED == rc && whandler)
+        netsnmp_handler_free(whandler);
+
+    return rc;
 }
 #endif /* NETSNMP_FEATURE_REMOVE_WATCHER_REGISTER_TIMESTAMP */
 
@@ -452,15 +513,28 @@ int
 netsnmp_register_watched_spinlock(netsnmp_handler_registration *reginfo,
                                    int *spinlock)
 {
-    netsnmp_mib_handler  *whandler;
-    netsnmp_watcher_info *winfo;
-
-    whandler         = netsnmp_get_watched_spinlock_handler();
-    whandler->myvoid = (void *)spinlock;
-    winfo            = netsnmp_create_watcher_info((void *)spinlock,
-		           sizeof(int), ASN_INTEGER, WATCHER_FIXED_SIZE);
-    netsnmp_inject_handler(reginfo, whandler);
-    return netsnmp_register_watched_scalar2(reginfo, winfo);
+    netsnmp_mib_handler  *whandler = NULL;
+    netsnmp_watcher_info *winfo = NULL;
+
+    if (reginfo && spinlock) {
+        whandler = netsnmp_get_watched_spinlock_handler();
+        if (whandler) {
+            whandler->myvoid = (void *)spinlock;
+            winfo = netsnmp_create_watcher_info((void *)spinlock, sizeof(int),
+                                                ASN_INTEGER,
+                                                WATCHER_FIXED_SIZE);
+            if (winfo &&
+                (netsnmp_inject_handler(reginfo, whandler) == SNMPERR_SUCCESS))
+                return netsnmp_register_watched_scalar2(reginfo, winfo);
+        }
+    }
+
+    snmp_log(LOG_ERR, "could not create watched spinlock handler\n");
+    SNMP_FREE(winfo);
+    netsnmp_handler_free(whandler);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 
@@ -537,26 +611,34 @@ register_scalar_watcher(const char* name,
 {
     netsnmp_handler_registration *reginfo = NULL;
     netsnmp_mib_handler *whandler = NULL;
-    netsnmp_watcher_info* watchinfo =
-        netsnmp_create_watcher_info(data, size, type, WATCHER_FIXED_SIZE);
-    if (watchinfo)
+    netsnmp_watcher_info* watchinfo;
+
+    if (!name || !reg_oid || !data)
+        return MIB_REGISTRATION_FAILED;
+
+    watchinfo = netsnmp_create_watcher_info(data, size, type,
+                                            WATCHER_FIXED_SIZE);
+    if (watchinfo) {
         whandler = netsnmp_get_watcher_handler();
-    if (watchinfo && whandler) {
-        whandler->myvoid = watchinfo;
-	netsnmp_owns_watcher_info(whandler);
-        reginfo =
-            netsnmp_create_handler_registration(
-                name, subhandler, reg_oid, reg_oid_len, mode);
-    }
-    if (watchinfo && whandler && reginfo) {
-        netsnmp_inject_handler(reginfo, whandler);
-        return netsnmp_register_scalar(reginfo);
+        if (whandler) {
+            whandler->myvoid = watchinfo;
+            netsnmp_owns_watcher_info(whandler);
+            reginfo =
+                netsnmp_create_handler_registration(name, subhandler,
+                                                    reg_oid, reg_oid_len,
+                                                    mode);
+            if (reginfo &&
+                (netsnmp_inject_handler(reginfo, whandler) == SNMPERR_SUCCESS))
+                return netsnmp_register_scalar(reginfo);
+        }
     }
-    if (whandler)
-        netsnmp_handler_free(whandler);
-    else if (watchinfo)
-        free(watchinfo);
-    return SNMP_ERR_RESOURCEUNAVAILABLE;
+
+    snmp_log(LOG_ERR, "failed to register scalar watcher\n");
+    netsnmp_handler_free(whandler);
+    SNMP_FREE(watchinfo);
+    netsnmp_handler_registration_free(reginfo);
+
+    return MIB_REGISTRATION_FAILED;
 }
 
 #ifndef NETSNMP_FEATURE_REMOVE_WATCHER_ULONG_SCALAR
diff --git a/agent/mibgroup/Rmon/alarm.c b/agent/mibgroup/Rmon/alarm.c
index 95cb017..1e8e4f5 100644
--- a/agent/mibgroup/Rmon/alarm.c
+++ b/agent/mibgroup/Rmon/alarm.c
@@ -40,6 +40,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "alarm.h"
+#include "event.h"
     /*
      * Implementation headers 
      */
@@ -128,19 +129,6 @@
          0;
 #endif
 
-/*
- * find & enjoy it in event.c 
- */
-     extern int
-     event_api_send_alarm(u_char is_rising,
-                          u_long alarm_index,
-                          u_long event_index,
-                          oid * alarmed_var,
-                          size_t alarmed_var_length,
-                          u_long sample_type,
-                          u_long value,
-                          u_long the_threshold, char *alarm_descr);
-
 static int
 fetch_var_val(oid * name, size_t namelen, u_long * new_value)
 {
@@ -185,7 +173,7 @@ fetch_var_val(oid * name, size_t namelen, u_long * new_value)
                     && snmp_oid_compare(name, namelen, tree_ptr->end_a,
                                         tree_ptr->end_len) > 0) {
                     memcpy(name, tree_ptr->end_a, tree_ptr->end_len);
-                    access = 0;
+                    access = NULL;
                     ag_trace("access := 0");
                 }
 
diff --git a/agent/mibgroup/Rmon/alarmTable.c b/agent/mibgroup/Rmon/alarmTable.c
index 6181628..5feb574 100644
--- a/agent/mibgroup/Rmon/alarmTable.c
+++ b/agent/mibgroup/Rmon/alarmTable.c
@@ -15,6 +15,7 @@
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "utilities/iquery.h"
 #include "alarmTable.h"
+#include "event.h"
 
 netsnmp_feature_require(iquery)
 netsnmp_feature_require(query_set_default_session)
@@ -69,16 +70,6 @@ initialize_table_alarmTable(void)
      */
 }
 
-extern int
-event_api_send_alarm(u_char is_rising,
-                     u_long alarm_index,
-                     u_long event_index,
-                     oid * alarmed_var,
-                     size_t alarmed_var_length,
-                     u_long sample_type,
-                     u_long value,
-                     u_long the_threshold, const char *alarm_descr);
-
 #define ALARM_STR1_LEN	32
 typedef enum {
     RMON1_ENTRY_VALID = 1,
diff --git a/agent/mibgroup/Rmon/event.h b/agent/mibgroup/Rmon/event.h
index b03e162..242933b 100644
--- a/agent/mibgroup/Rmon/event.h
+++ b/agent/mibgroup/Rmon/event.h
@@ -30,4 +30,12 @@ config_require(util_funcs)
 
 config_require(Rmon/agutil)
 config_require(Rmon/rows)
+
+     int
+     event_api_send_alarm(u_char is_rising, u_long alarm_index,
+                          u_long event_index, oid * alarmed_var,
+                          size_t alarmed_var_length, u_long sample_type,
+                          u_long value, u_long the_threshold,
+                          char *alarm_descr);
+
 #endif                          /* _MIBGROUP_EVENT_H */
diff --git a/agent/mibgroup/agent/extend.c b/agent/mibgroup/agent/extend.c
index 48379a2..5f8cedc 100644
--- a/agent/mibgroup/agent/extend.c
+++ b/agent/mibgroup/agent/extend.c
@@ -23,10 +23,6 @@ netsnmp_feature_require(insert_table_row)
 #endif /* NETSNMP_NO_WRITE_SUPPORT */
 
 oid  ns_extend_oid[]    = { 1, 3, 6, 1, 4, 1, 8072, 1, 3, 2 };
-oid  extend_count_oid[] = { 1, 3, 6, 1, 4, 1, 8072, 1, 3, 2, 1 };
-oid  extend_config_oid[] = { 1, 3, 6, 1, 4, 1, 8072, 1, 3, 2, 2 };
-oid  extend_out1_oid[]  = { 1, 3, 6, 1, 4, 1, 8072, 1, 3, 2, 3 };
-oid  extend_out2_oid[]  = { 1, 3, 6, 1, 4, 1, 8072, 1, 3, 2, 4 };
 
 typedef struct extend_registration_block_s {
     netsnmp_table_data *dinfo;
@@ -522,8 +518,28 @@ extend_parse_config(const char *token, char *cptr)
     size_t oid_len;
     extend_registration_block *eptr;
     int  flags;
+    int cache_timeout = 0;
+    int exec_type = NS_EXTEND_ETYPE_EXEC;
 
-    cptr = copy_nword(cptr, exec_name,    sizeof(exec_name));
+    cptr = copy_nword(cptr, exec_name, sizeof(exec_name));
+    if (strcmp(exec_name, "-cacheTime") == 0) {
+        char cache_timeout_str[32];
+
+        cptr = copy_nword(cptr, cache_timeout_str, sizeof(cache_timeout_str));
+        /* If atoi can't do the conversion, it returns 0 */
+        cache_timeout = atoi(cache_timeout_str);
+        cptr = copy_nword(cptr, exec_name, sizeof(exec_name));
+    }
+    if (strcmp(exec_name, "-execType") == 0) {
+        char exec_type_str[16];
+
+        cptr = copy_nword(cptr, exec_type_str, sizeof(exec_type_str));
+        if (strcmp(exec_type_str, "sh") == 0)
+            exec_type = NS_EXTEND_ETYPE_SHELL;
+        else
+            exec_type = NS_EXTEND_ETYPE_EXEC;
+        cptr = copy_nword(cptr, exec_name, sizeof(exec_name));
+    }
     if ( *exec_name == '.' ) {
         oid_len = MAX_OID_LEN - 2;
         if (0 == read_objid( exec_name, oid_buf, &oid_len )) {
@@ -545,7 +561,8 @@ extend_parse_config(const char *token, char *cptr)
     flags = (NS_EXTEND_FLAGS_ACTIVE | NS_EXTEND_FLAGS_CONFIG);
     if (!strcmp( token, "sh"        ) ||
         !strcmp( token, "extend-sh" ) ||
-        !strcmp( token, "sh2" ))
+        !strcmp( token, "sh2") ||
+        exec_type == NS_EXTEND_ETYPE_SHELL)
         flags |= NS_EXTEND_FLAGS_SHELL;
     if (!strcmp( token, "execFix"   ) ||
         !strcmp( token, "extendfix" ) ||
@@ -566,6 +583,8 @@ extend_parse_config(const char *token, char *cptr)
         extension->command  = strdup( exec_command );
         if (cptr)
             extension->args = strdup( cptr );
+        if (cache_timeout != 0)
+            extension->cache->timeout = cache_timeout;
     } else {
         snmp_log(LOG_ERR, "Failed to register extend entry '%s' - possibly duplicate name.\n", exec_name );
         return;
diff --git a/agent/mibgroup/agent/nsTransactionTable.c b/agent/mibgroup/agent/nsTransactionTable.c
index d7d3ce9..df338ad 100644
--- a/agent/mibgroup/agent/nsTransactionTable.c
+++ b/agent/mibgroup/agent/nsTransactionTable.c
@@ -95,8 +95,6 @@ init_nsTransactionTable(void)
     each appropriately according to the data matching the first row
     and return the put_index_data variable at the end of the function.
 */
-extern netsnmp_agent_session *agent_delegated_list;
-
 netsnmp_variable_list *
 nsTransactionTable_get_first_data_point(void **my_loop_context,
                                         void **my_data_context,
diff --git a/agent/mibgroup/agent/nsVacmAccessTable.h b/agent/mibgroup/agent/nsVacmAccessTable.h
index e7a7e20..c4522ef 100644
--- a/agent/mibgroup/agent/nsVacmAccessTable.h
+++ b/agent/mibgroup/agent/nsVacmAccessTable.h
@@ -12,6 +12,7 @@ config_add_mib(NET-SNMP-VACM-MIB)
  */
 void            init_nsVacmAccessTable(void);
 void            initialize_table_nsVacmAccessTable(void);
+void            init_register_nsVacm_context(const char *context);
 Netsnmp_Node_Handler nsVacmAccessTable_handler;
 Netsnmp_First_Data_Point nsVacmAccessTable_get_first_data_point;
 Netsnmp_Next_Data_Point nsVacmAccessTable_get_next_data_point;
diff --git a/agent/mibgroup/agentx/client.c b/agent/mibgroup/agentx/client.c
index d36fe2d..049108e 100644
--- a/agent/mibgroup/agentx/client.c
+++ b/agent/mibgroup/agentx/client.c
@@ -104,8 +104,6 @@ int
 agentx_open_session(netsnmp_session * ss)
 {
     netsnmp_pdu    *pdu, *response;
-    extern oid      version_sysoid[];
-    extern int      version_sysoid_len;
     u_long 	    timeout;
 
     DEBUGMSGTL(("agentx/subagent", "opening session \n"));
diff --git a/agent/mibgroup/agentx/master.c b/agent/mibgroup/agentx/master.c
index c42a42a..7d4b416 100644
--- a/agent/mibgroup/agentx/master.c
+++ b/agent/mibgroup/agentx/master.c
@@ -531,7 +531,7 @@ agentx_master_handler(netsnmp_mib_handler *handler,
 
             if (snmp_oid_compare(nptr, nlen, request->subtree->start_a,
                                  request->subtree->start_len) < 0) {
-                DEBUGMSGTL(("agentx/master","inexact request preceeding region ("));
+                DEBUGMSGTL(("agentx/master","inexact request preceding region ("));
                 DEBUGMSGOID(("agentx/master", request->subtree->start_a,
                              request->subtree->start_len));
                 DEBUGMSG(("agentx/master", ")\n"));
diff --git a/agent/mibgroup/agentx/master_admin.c b/agent/mibgroup/agentx/master_admin.c
index 4eaeab6..57cf56a 100644
--- a/agent/mibgroup/agentx/master_admin.c
+++ b/agent/mibgroup/agentx/master_admin.c
@@ -35,6 +35,8 @@
 
 #include "agentx/protocol.h"
 #include "agentx/client.h"
+#include "agentx/subagent.h"
+#include "agentx/master_admin.h"
 
 #include <net-snmp/agent/agent_index.h>
 #include <net-snmp/agent/agent_trap.h>
@@ -408,8 +410,6 @@ agentx_notify(netsnmp_session * session, netsnmp_pdu *pdu)
 {
     netsnmp_session       *sp;
     netsnmp_variable_list *var;
-    extern const oid       sysuptime_oid[], snmptrap_oid[];
-    extern const size_t    sysuptime_oid_len, snmptrap_oid_len;
 
     sp = find_agentx_session(session, pdu->sessid);
     if (sp == NULL)
diff --git a/agent/mibgroup/agentx/protocol.c b/agent/mibgroup/agentx/protocol.c
index 0845cf1..ce4d320 100644
--- a/agent/mibgroup/agentx/protocol.c
+++ b/agent/mibgroup/agentx/protocol.c
@@ -1550,7 +1550,7 @@ agentx_parse(netsnmp_session * session, netsnmp_pdu *pdu, u_char * data,
              size_t len)
 {
     register u_char *bufp = data;
-    u_char          buffer[SNMP_MAX_MSG_SIZE];
+    u_char          buffer[65535];
     oid             oid_buffer[MAX_OID_LEN], end_oid_buf[MAX_OID_LEN];
     size_t          buf_len = sizeof(buffer);
     size_t          oid_buf_len = MAX_OID_LEN;
diff --git a/agent/mibgroup/agentx/subagent.c b/agent/mibgroup/agentx/subagent.c
index 1f9d31c..a643576 100644
--- a/agent/mibgroup/agentx/subagent.c
+++ b/agent/mibgroup/agentx/subagent.c
@@ -31,6 +31,7 @@
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/agent_index.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/snmp_assert.h>
 
@@ -89,8 +90,6 @@ struct agent_netsnmp_set_info {
 static struct agent_netsnmp_set_info *Sets = NULL;
 
 netsnmp_session *agentx_callback_sess = NULL;
-extern int      callback_master_num;
-extern netsnmp_session *main_session;   /* from snmp_agent.c */
 
 int
 subagent_startup(int majorID, int minorID,
diff --git a/agent/mibgroup/agentx/subagent.h b/agent/mibgroup/agentx/subagent.h
index b55bec1..eb033e3 100644
--- a/agent/mibgroup/agentx/subagent.h
+++ b/agent/mibgroup/agentx/subagent.h
@@ -11,6 +11,15 @@ config_require(agentx/agentx_config)
 config_error(agentx/subagent depends on the Callback transport)
 #endif
 
+     extern int             callback_master_num;
+
+     extern const oid       snmptrap_oid[];
+     extern const oid       snmptrapenterprise_oid[];
+     extern const oid       sysuptime_oid[];
+     extern const size_t    snmptrap_oid_len;
+     extern const size_t    snmptrapenterprise_oid_len;
+     extern const size_t    sysuptime_oid_len;
+
      int             subagent_init(void);
      int             handle_agentx_packet(int, netsnmp_session *, int,
                                           netsnmp_pdu *, void *);
diff --git a/agent/mibgroup/deliver/deliverByNotify.c b/agent/mibgroup/deliver/deliverByNotify.c
index c89879a..471debb 100644
--- a/agent/mibgroup/deliver/deliverByNotify.c
+++ b/agent/mibgroup/deliver/deliverByNotify.c
@@ -191,7 +191,7 @@ parse_deliver_config(const char *token, char *line) {
         config_perror("no frequency given");
         return;
     }
-    copy_nword(cp, buf, buf_len);
+    copy_nword_const(cp, buf, buf_len);
     frequency = netsnmp_string_time_to_secs(buf);
     cp = skip_token_const(cp);
 
diff --git a/agent/mibgroup/disman/event/mteEvent.c b/agent/mibgroup/disman/event/mteEvent.c
index bc4ff0b..005a892 100644
--- a/agent/mibgroup/disman/event/mteEvent.c
+++ b/agent/mibgroup/disman/event/mteEvent.c
@@ -7,6 +7,7 @@
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "agentx/subagent.h"
 #include "disman/event/mteEvent.h"
 #include "disman/event/mteTrigger.h"
 #include "disman/event/mteObjects.h"
@@ -349,8 +350,6 @@ _mteEvent_fire_notify( struct mteEvent   *entry,     /* The event to fire  */
                        oid *suffix, size_t sfx_len ) /* Matching instance  */
 {
     netsnmp_variable_list *var, *v2;
-    extern const oid       snmptrap_oid[];
-    extern const size_t    snmptrap_oid_len;
     netsnmp_session       *s;
 
          /*
diff --git a/agent/mibgroup/disman/event/mteScalars.c b/agent/mibgroup/disman/event/mteScalars.c
index 769adc1..9fe3aa8 100644
--- a/agent/mibgroup/disman/event/mteScalars.c
+++ b/agent/mibgroup/disman/event/mteScalars.c
@@ -106,9 +106,7 @@ handle_mteTriggerFailures(netsnmp_mib_handler          *handler,
                           netsnmp_agent_request_info   *reqinfo,
                           netsnmp_request_info         *requests)
 {
-#ifdef USING_DISMAN_EVENT_MTETRIGGER_MODULE
-    extern long mteTriggerFailures;
-#else
+#ifndef USING_DISMAN_EVENT_MTETRIGGER_MODULE
     long mteTriggerFailures = 0;
 #endif
 
diff --git a/agent/mibgroup/disman/event/mteTrigger.c b/agent/mibgroup/disman/event/mteTrigger.c
index 5a0dcba..5b55fc7 100644
--- a/agent/mibgroup/disman/event/mteTrigger.c
+++ b/agent/mibgroup/disman/event/mteTrigger.c
@@ -219,7 +219,6 @@ mteTrigger_run( unsigned int reg, void *clientarg)
     }
 
     {
-	extern netsnmp_agent_session *netsnmp_processing_set;
 	if (netsnmp_processing_set) {
 	    /*
 	     * netsnmp_handle_request will not be responsive to our efforts to
diff --git a/agent/mibgroup/disman/event/mteTrigger.h b/agent/mibgroup/disman/event/mteTrigger.h
index 19626b1..f4f6b89 100644
--- a/agent/mibgroup/disman/event/mteTrigger.h
+++ b/agent/mibgroup/disman/event/mteTrigger.h
@@ -184,6 +184,7 @@ struct mteTrigger {
    * Container structure for the (combined) mteTrigger*Tables,
    * and routine to create this.
    */
+extern long mteTriggerFailures;
 extern netsnmp_tdata *trigger_table_data;
 extern void      init_trigger_table_data(void);
 
diff --git a/agent/mibgroup/disman/expr/expExpression.c b/agent/mibgroup/disman/expr/expExpression.c
index c924141..7502e3f 100644
--- a/agent/mibgroup/disman/expr/expExpression.c
+++ b/agent/mibgroup/disman/expr/expExpression.c
@@ -304,7 +304,7 @@ expExpression_getData( unsigned int reg, void *clientarg )
 void
 expExpression_enable( struct expExpression *entry )
 {
-    DEBUGMSG(("disman:expr:run", "Enabling %s\n", entry->expName));
+    DEBUGMSGTL(("disman:expr:run", "Enabling %s\n", entry->expName));
     if (!entry)
         return;
 
diff --git a/agent/mibgroup/disman/expr/expExpressionTable.c b/agent/mibgroup/disman/expr/expExpressionTable.c
index 79aa715..7118cac 100644
--- a/agent/mibgroup/disman/expr/expExpressionTable.c
+++ b/agent/mibgroup/disman/expr/expExpressionTable.c
@@ -279,7 +279,8 @@ expExpressionTable_handler(netsnmp_mib_handler *handler,
             tinfo = netsnmp_extract_table_info(request);
             entry = (struct expExpression *)
                     netsnmp_tdata_extract_entry(request);
-            if (!entry) {
+            if (!entry && tinfo->colnum != COLUMN_EXPEXPRESSIONENTRYSTATUS &&
+                *request->requestvb->val.integer != RS_DESTROY) {
                 /*
                  * New rows must be created via the RowStatus column
                  */
diff --git a/agent/mibgroup/disman/expr/expObjectTable.c b/agent/mibgroup/disman/expr/expObjectTable.c
index adda438..98fbf55 100644
--- a/agent/mibgroup/disman/expr/expObjectTable.c
+++ b/agent/mibgroup/disman/expr/expObjectTable.c
@@ -288,7 +288,8 @@ expObjectTable_handler(netsnmp_mib_handler *handler,
             tinfo = netsnmp_extract_table_info(request);
             entry = (struct expObject *)
                     netsnmp_tdata_extract_entry(request);
-            if (!entry) {
+            if (!entry && tinfo->colnum != COLUMN_EXPOBJECTENTRYSTATUS &&
+                *request->requestvb->val.integer != RS_DESTROY) {
                 /*
                  * New rows must be created via the RowStatus column
                  */
@@ -322,7 +323,7 @@ expObjectTable_handler(netsnmp_mib_handler *handler,
                 memset(entry->expObjectID, 0, sizeof(entry->expObjectID));
                 memcpy(entry->expObjectID, request->requestvb->val.string,
                                            request->requestvb->val_len);
-                entry->expObjectID_len = request->requestvb->val_len;
+                entry->expObjectID_len = request->requestvb->val_len/sizeof(oid);
                 break;
             case COLUMN_EXPOBJECTIDWILDCARD:
                 if (*request->requestvb->val.integer == TV_TRUE)
@@ -371,7 +372,7 @@ expObjectTable_handler(netsnmp_mib_handler *handler,
                         ret = 1;   /* Set the prefix later  */
                     entry->flags |=  EXP_OBJ_FLAG_DWILD;
                 } else {
-                    if ( entry->flags | EXP_OBJ_FLAG_PREFIX ) {
+                    if ( entry->flags & EXP_OBJ_FLAG_PREFIX ) {
                         exp = expExpression_getEntry( entry->expOwner,
                                                       entry->expName );
                         memset( exp->expPrefix, 0, MAX_OID_LEN*sizeof(oid));
diff --git a/agent/mibgroup/disman/expr/expValue.c b/agent/mibgroup/disman/expr/expValue.c
index eeff402..a9c3daa 100644
--- a/agent/mibgroup/disman/expr/expValue.c
+++ b/agent/mibgroup/disman/expr/expValue.c
@@ -242,6 +242,9 @@ _expValue_evalOperator(netsnmp_variable_list *left,
                        netsnmp_variable_list *right) {
     int n;
 
+    if (left->val.integer == NULL || right->val.integer == NULL) {
+	return right;
+    }
     switch( *op->val.integer ) {
     case EXP_OPERATOR_ADD:
         n = *left->val.integer + *right->val.integer; break;
@@ -354,6 +357,7 @@ _expValue_evalExpr(  netsnmp_variable_list *expIdx,
                 /* Note position of failure in expression */
                 var->data = (void *)(cp1 - exprRaw);
                 snmp_free_var(exprAlDente);
+		*exprEnd = cp1;
                 return var;
             } else {
                 if (vtail)
@@ -372,7 +376,7 @@ _expValue_evalExpr(  netsnmp_variable_list *expIdx,
                                       suffix, suffix_len );
             if ( var && var->type == ASN_NULL ) {
                 /* Adjust position of failure */
-                var->data = (void *)(cp1 - exprRaw + (int)var->data);
+                var->data = (void *)(cp1 - exprRaw + (uintptr_t)var->data);
                 return var;
             } else if (*cp2 != ')') {
                 snmp_free_var(exprAlDente);
@@ -381,6 +385,7 @@ _expValue_evalExpr(  netsnmp_variable_list *expIdx,
                                             EXPERRCODE_PARENTHESIS );
                 var->type = ASN_NULL;
                 var->data = (void *)(cp2 - exprRaw);
+		*exprEnd = cp1;
                 return var;
             } else {
                 if (vtail)
@@ -401,7 +406,6 @@ _expValue_evalExpr(  netsnmp_variable_list *expIdx,
              */
             *exprEnd = cp1;
             var = _expValue_evalExpr2( exprAlDente );
-            snmp_free_var(exprAlDente);
             return var;
 
             /* === Constants === */
@@ -501,6 +505,7 @@ DIGIT:
                                             EXPERRCODE_SYNTAX );
                 var->type = ASN_NULL;
                 var->data = (void *)(cp1 - exprRaw);
+		*exprEnd = cp1;
                 return var;
             }
             n = ops[ *cp1 & 0xFF ];
@@ -531,6 +536,7 @@ DIGIT:
                                             EXPERRCODE_SYNTAX );
                 var->type = ASN_NULL;
                 var->data = (void *)(cp1 - exprRaw);
+		*exprEnd = cp1;
                 return var;
             }
             if ( *(cp1+1) == '=' )
@@ -574,6 +580,7 @@ DIGIT:
                                             EXPERRCODE_FUNCTION );
                 var->type = ASN_NULL;
                 var->data = (void *)(cp1 - exprRaw);
+		*exprEnd = cp1;
                 return var;
             }
             else if (!isspace( *cp1 & 0xFF )) {
@@ -585,6 +592,7 @@ DIGIT:
                                             EXPERRCODE_OPERATOR );
                 var->type = ASN_NULL;
                 var->data = (void *)(cp1 - exprRaw);
+		*exprEnd = cp1;
                 return var;
             }
             cp1++;
@@ -722,13 +730,19 @@ expValue_evaluateExpression( struct expExpression *exp,
     char exprRaw[     EXP_STR3_LEN+1 ];
     netsnmp_variable_list *var;
     netsnmp_variable_list owner_var, name_var, param_var;
-    long n;
+    int n;
     char *cp;
 
     if (!exp)
         return NULL;
 
     /*
+     * Gather data for evaluating expressions with no regular delta-value
+     * sampling, i.e. expressions with sampling/delta interval of 0
+     */
+    expExpression_getData(0, exp);
+
+    /* 
      * Set up a varbind list containing the various index values
      *   (including a placeholder for expObjectIndex).
      *
@@ -743,7 +757,7 @@ expValue_evaluateExpression( struct expExpression *exp,
                   (u_char*)exp->expName,  strlen(exp->expName));
     n = 99; /* dummy value */
     snmp_set_var_typed_value( &param_var, ASN_INTEGER,
-                             (u_char*)&n, sizeof(long));
+                             (u_char*)&n, sizeof(n));
     owner_var.next_variable = &name_var;
     name_var.next_variable  = &param_var;
 
@@ -762,7 +776,7 @@ expValue_evaluateExpression( struct expExpression *exp,
          * When we had finished, there was a lot
          * of bricks^Wcharacters left over....
          */
-        _expValue_setError( exp, EXPERRCODE_SYNTAX, suffix, suffix_len, NULL );
+        _expValue_setError( exp, EXPERRCODE_SYNTAX, suffix, suffix_len, var );
         return NULL;
     }
     if (!var) {
@@ -799,10 +813,11 @@ _expValue_setError( struct expExpression *exp, int reason,
         return;
     exp->expErrorCount++;
  /* exp->expErrorTime  = NOW; */
-    exp->expErrorIndex = ( var && var->data ? (int)var->data : 0 );
+    exp->expErrorIndex = ( var && var->data ? (uintptr_t)var->data : 0 );
     exp->expErrorCode  = reason;
     memset( exp->expErrorInstance, 0, sizeof(exp->expErrorInstance));
     memcpy( exp->expErrorInstance, suffix, suffix_len * sizeof(oid));
     exp->expErrorInst_len = suffix_len;
+    if (var) var->data = NULL;
     snmp_free_var( var );
 }
diff --git a/agent/mibgroup/disman/expr/expValueTable.c b/agent/mibgroup/disman/expr/expValueTable.c
index d74dbd1..38a6072 100644
--- a/agent/mibgroup/disman/expr/expValueTable.c
+++ b/agent/mibgroup/disman/expr/expValueTable.c
@@ -320,6 +320,8 @@ expValueTable_handler(netsnmp_mib_handler *handler,
                                (u_char *)value->val.counter64, value->val_len);
                 break;
             }
+            /* remember to free the variable list, or we will leak here.. */
+            snmp_free_varbind(value);
         }
         break;
 
diff --git a/agent/mibgroup/disman/expression/expErrorTable.c b/agent/mibgroup/disman/expression/expErrorTable.c
index 1feb3ee..5ef1ef6 100644
--- a/agent/mibgroup/disman/expression/expErrorTable.c
+++ b/agent/mibgroup/disman/expression/expErrorTable.c
@@ -79,9 +79,6 @@ struct variable2 expErrorTable_variables[] = {
      var_expErrorTable, 2, {1, 4}}
 };
 
-extern struct header_complex_index *expExpressionTableStorage;
-
-
 void
 init_expErrorTable(void)
 {
diff --git a/agent/mibgroup/disman/expression/expExpressionTable.c b/agent/mibgroup/disman/expression/expExpressionTable.c
index 212952d..ccd1006 100644
--- a/agent/mibgroup/disman/expression/expExpressionTable.c
+++ b/agent/mibgroup/disman/expression/expExpressionTable.c
@@ -97,8 +97,6 @@ struct variable2 expExpressionTable_variables[] = {
  */
 
 struct header_complex_index *expExpressionTableStorage = NULL;
-extern struct header_complex_index *expObjectTableStorage;
-extern struct header_complex_index *expValueTableStorage;
 
 oid             mmTimeInstance[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
 
@@ -563,7 +561,10 @@ write_expExpression(int action,
          */
         tmpvar = StorageTmp->expExpression;
         tmplen = StorageTmp->expExpressionLen;
-        StorageTmp->expExpression = netsnmp_memdup(var_val, var_val_len);
+        StorageTmp->expExpression = malloc(var_val_len + 1);
+        if (StorageTmp->expExpression)
+            snprintf(StorageTmp->expExpression, var_val_len + 1, "%.*s",
+                     (int)var_val_len, var_val);
         StorageTmp->expExpressionLen = var_val_len;
         break;
 
@@ -1029,7 +1030,7 @@ write_expExpressionEntryStatus(int action,
          */
 
 
-        if (StorageTmp == NULL) {
+        if (StorageTmp == NULL && set_value != RS_DESTROY) {
             /*
              * row creation, so add it 
              */
@@ -1038,7 +1039,7 @@ write_expExpressionEntryStatus(int action,
             /*
              * XXX: ack, and if it is NULL? 
              */
-        } else if (set_value != RS_DESTROY) {
+        } else if (StorageTmp && set_value != RS_DESTROY) {
             /*
              * set the flag? 
              */
diff --git a/agent/mibgroup/disman/expression/expExpressionTable.h b/agent/mibgroup/disman/expression/expExpressionTable.h
index 6c139f8..a4be6bd 100644
--- a/agent/mibgroup/disman/expression/expExpressionTable.h
+++ b/agent/mibgroup/disman/expression/expExpressionTable.h
@@ -116,6 +116,8 @@ config_require(header_complex)
 #define EXP_FAILURE_DIVIDEBYZERO        11
 
 
+     extern struct header_complex_index *expExpressionTableStorage;
+
 /*
  * function prototypes 
  */
diff --git a/agent/mibgroup/disman/expression/expObjectTable.c b/agent/mibgroup/disman/expression/expObjectTable.c
index e057f56..906ba5f 100644
--- a/agent/mibgroup/disman/expression/expObjectTable.c
+++ b/agent/mibgroup/disman/expression/expObjectTable.c
@@ -99,12 +99,6 @@ struct variable2 expObjectTable_variables[] = {
 };
 
 
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-extern struct header_complex_index *expExpressionTableStorage;
-extern struct header_complex_index *expValueTableStorage;
-
 struct header_complex_index *expObjectTableStorage = NULL;
 
 /*
@@ -1374,7 +1368,7 @@ write_expObjectEntryStatus(int action,
          */
 
 
-        if (StorageTmp == NULL) {
+        if (StorageTmp == NULL && set_value != RS_DESTROY) {
             /*
              * row creation, so add it 
              */
@@ -1383,7 +1377,7 @@ write_expObjectEntryStatus(int action,
             /*
              * XXX: ack, and if it is NULL? 
              */
-        } else if (set_value != RS_DESTROY) {
+        } else if (StorageTmp != NULL && set_value != RS_DESTROY) {
             /*
              * set the flag? 
              */
diff --git a/agent/mibgroup/disman/expression/expObjectTable.h b/agent/mibgroup/disman/expression/expObjectTable.h
index 86fea31..823e8bd 100644
--- a/agent/mibgroup/disman/expression/expObjectTable.h
+++ b/agent/mibgroup/disman/expression/expObjectTable.h
@@ -68,6 +68,9 @@ config_require(header_complex)
 #define EXPOBJCETSAMPLETYPE_ABSOLUTEVALUE	1
 #define EXPOBJCETSAMPLETYPE_DELTAVALUE	2
 #define EXPOBJCETSAMPLETYPE_CHANGEVALUE	3
+
+     extern struct header_complex_index *expObjectTableStorage;
+
     /*
      * function prototypes 
      */
diff --git a/agent/mibgroup/disman/expression/expValueTable.c b/agent/mibgroup/disman/expression/expValueTable.c
index 6b315c6..2463bd4 100644
--- a/agent/mibgroup/disman/expression/expValueTable.c
+++ b/agent/mibgroup/disman/expression/expValueTable.c
@@ -22,6 +22,7 @@
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
+#include <ctype.h>
 #if HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
@@ -43,6 +44,7 @@
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "utilities/iquery.h"
 #include "header_complex.h"
 #include "expExpressionTable.h"
 #include "expValueTable.h"
@@ -56,22 +58,22 @@
  *   variable below.
  */
 
-oid             expValueTable_variables_oid[] =
-    { 1, 3, 6, 1, 2, 1, 90, 1, 3, 1 };
+static const oid expValueTable_variables_oid[] = {
+    1, 3, 6, 1, 2, 1, 90, 1, 3, 1
+};
 
 struct s_node {
     unsigned        data;
     struct s_node  *next;
 };
 typedef struct s_node nodelink;
-nodelink           *operater = NULL;
-nodelink           *operand = NULL;
+static FindVarMethod var_expValueTable;
 
 /*
  * variable2 expObjectTable_variables:
  */
 
-struct variable2 expValueTable_variables[] = {
+static const struct variable2 expValueTable_variables[] = {
     /*
      * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
      */
@@ -102,13 +104,7 @@ struct variable2 expValueTable_variables[] = {
 };
 
 
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-extern struct header_complex_index *expExpressionTableStorage;
-extern struct header_complex_index *expObjectTableStorage;
-struct header_complex_index *expValueTableStorage = NULL;
-struct snmp_session session;
+static struct header_complex_index *expValueTableStorage = NULL;
 
 /*
  * init_expValueTable():
@@ -127,127 +123,328 @@ init_expValueTable(void)
     REGISTER_MIB("expValueTable",
                  expValueTable_variables, variable2,
                  expValueTable_variables_oid);
-    init_snmp("snmpapp");
-
-    /*
-     * Initialize a "session" that defines who we're going to talk to
-     */
-    snmp_sess_init(&session);   /* set up defaults */
-    session.peername = strdup("localhost");
 
     DEBUGMSGTL(("expValueTable", "done.\n"));
 }
 
-struct expValueTable_data *
-create_expValueTable_data(void)
+static int
+expValueTable_set(struct expExpressionTable_data *expression_data,
+                  const char *owner, size_t owner_len, const char *name,
+                  size_t name_len, oid *index, size_t index_len)
 {
-    struct expValueTable_data *StorageNew;
+    netsnmp_variable_list *vars = NULL;
+    struct expValueTable_data *thedata;
+    struct header_complex_index *hcindex;
+    int             found = 0;
+
+    for (hcindex = expValueTableStorage; hcindex; hcindex = hcindex->next) {
+        thedata = hcindex->data;
+        if (strcmp(thedata->expExpressionOwner, owner) == 0 &&
+            thedata->expExpressionOwnerLen == owner_len &&
+            strcmp(thedata->expExpressionName, name) == 0 &&
+            thedata->expExpressionNameLen == name_len) {
+            found = 1;
+            break;
+        }
+
+    }
 
-    StorageNew = SNMP_MALLOC_STRUCT(expValueTable_data);
+    if (found) {
+        if (snmp_oid_compare(thedata->expValueInstance,
+                             thedata->expValueInstanceLen, index,
+                             index_len) != 0) {
+            SNMP_FREE(thedata->expValueInstance);
+            thedata->expValueInstance = netsnmp_memdup(index, index_len);
+            thedata->expValueInstanceLen = index_len;
+        } else {
+            SNMP_FREE(index);
+        }
+    } else if ((thedata = calloc(1, sizeof(*thedata)))) {
+        thedata->expExpressionOwner = owner;
+        thedata->expExpressionOwnerLen = owner_len;
+        thedata->expExpressionName = name;
+        thedata->expExpressionNameLen = name_len;
+        thedata->expValueInstance = index;
+        thedata->expValueInstanceLen = index_len;
+        thedata->expression_data = expression_data;
+
+        snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
+                                  (const char *) thedata->expExpressionOwner,
+                                  thedata->expExpressionOwnerLen);
+        snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR,
+                                  (const char *) thedata->expExpressionName,
+                                  thedata->expExpressionNameLen);
+        snmp_varlist_add_variable(&vars, NULL, 0, ASN_PRIV_IMPLIED_OBJECT_ID,
+                                  (u_char *) thedata->expValueInstance,
+                                  thedata->expValueInstanceLen * sizeof(oid));
 
-    /*
-     * fill in default row values here into StorageNew 
-     */
-    /*
-     * fill in values for all tables (even if not
-     * appropriate), since its easier to do here than anywhere
-     * else 
-     */
-    StorageNew->expExpressionOwner = strdup("");
-    StorageNew->expExpressionName = strdup("");
-    StorageNew->expValueInstance = calloc(1, sizeof(oid) * sizeof(2));  /* 0.0.0 */
-    StorageNew->expValueInstanceLen = 3;
-    return StorageNew;
+        header_complex_add_data(&expValueTableStorage, vars, thedata);
+    } else {
+        return SNMPERR_GENERR;
+    }
+
+    thedata->set = 1;
+
+    return SNMPERR_SUCCESS;
 }
 
-/*
- * mteTriggerTable_add(): adds a structure node to our data set 
- */
-int
-expValueTable_add(struct expExpressionTable_data *expression_data,
-                  char *owner, size_t owner_len, char *name,
-                  size_t name_len, oid * index, size_t index_len)
+static void push(nodelink ** stack, unsigned long value)
 {
-    netsnmp_variable_list *vars = NULL;
-    struct expValueTable_data *thedata, *StorageTmp;
-    struct header_complex_index *hcindex;
-    int             founded = 0;
-    thedata = create_expValueTable_data();
-    thedata->expValueCounter32Val = 0;
-    thedata->expExpressionOwner = owner;
-    thedata->expExpressionOwnerLen = owner_len;
-    thedata->expExpressionName = name;
-    thedata->expExpressionNameLen = name_len;
-    thedata->expValueInstance = index;
-    thedata->expValueInstanceLen = index_len;
-    thedata->expression_data = expression_data;
-    DEBUGMSGTL(("expValueTable", "adding data...  "));
-    /*
-     * add the index variables to the varbind list, which is 
-     * used by header_complex to index the data 
-     */
+    nodelink           *newnode;
+    newnode = (nodelink *) malloc(sizeof(nodelink));
+    if (!newnode) {
+        printf("\nMemory allocation failure!");
+        return;
+    }
+    newnode->data = value;
+    newnode->next = *stack;
+    *stack = newnode;
+}
 
+static unsigned long pop(nodelink **stack)
+{
+    unsigned long   value;
+    nodelink       *top;
 
-    snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) thedata->expExpressionOwner, thedata->expExpressionOwnerLen);     /* expExpressionOwner */
-    snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) thedata->expExpressionName, thedata->expExpressionNameLen);       /* expExpressionName */
-    snmp_varlist_add_variable(&vars, NULL, 0, ASN_PRIV_IMPLIED_OBJECT_ID,
-                              (u_char *) thedata->expValueInstance,
-                              thedata->expValueInstanceLen * sizeof(oid));
+    if (!*stack)
+        return 0;
 
-    for (hcindex = expValueTableStorage; hcindex != NULL;
-         hcindex = hcindex->next) {
-        StorageTmp = (struct expValueTable_data *) hcindex->data;
-        if (!strcmp
-            (StorageTmp->expExpressionOwner, thedata->expExpressionOwner)
-            && (StorageTmp->expExpressionOwnerLen ==
-                thedata->expExpressionOwnerLen)
-            && !strcmp(StorageTmp->expExpressionName,
-                       thedata->expExpressionName)
-            && (StorageTmp->expExpressionNameLen ==
-                thedata->expExpressionNameLen)
-            && !snmp_oid_compare(StorageTmp->expValueInstance,
-                                 StorageTmp->expValueInstanceLen,
-                                 thedata->expValueInstance,
-                                 thedata->expValueInstanceLen)) {
-            founded = 1;
-            break;
-        }
+    top = *stack;
+    *stack = (*stack)->next;
+    value = top->data;
+    free(top);
+    return value;
+}
 
+static int priority(char operator)
+{
+    switch (operator) {
+    case '*':
+    case '/':
+        return 4;
+    case '+':
+    case '-':
+        return 3;
+    case ')':
+        return 2;
+    case '(':
+        return 1;
+    default:
+        return 0;
     }
-    if (!founded) {
-        header_complex_add_data(&expValueTableStorage, vars, thedata);
-        DEBUGMSGTL(("expValueTable", "registered an entry\n"));
-    } else {
-        SNMP_FREE(thedata);
-        DEBUGMSGTL(("expValueTable",
-                    "already have an entry, dont registe\n"));
+}
+
+static unsigned long calculate(int operator, unsigned long a, unsigned long b)
+{
+    switch (operator) {
+    case '+':
+        return (a + b);
+    case '-':
+        return (a - b);
+    case '*':
+        return (a * b);
+    case '/':
+        if (operator == '/' && b == 0) {
+            snmp_log(LOG_ERR, "Division by zero attempted\n");
+            return 0;
+        } else
+            return (a / b);
     }
+    return 0;
+}
 
+static unsigned long get_operand(const char *p, int *length)
+{
+    char            c[13];
+    int             i = 0, k = 1;
+    unsigned long   result = 0;
 
-    DEBUGMSGTL(("expValueTable", "done.\n"));
-    return SNMPERR_SUCCESS;
+    while (isdigit((unsigned char) *p))
+        c[i++] = *(p++);
+    *length += --i;
+    for (; i >= 0; i--) {
+        result += (c[i] - 48) * k;
+        k *= 10;
+    }
+    return result;
+}
+
+enum operator_class {
+    c_other	= 0,
+    c_digit	= 1,
+    c_binop	= 2,
+    c_rpar	= 3,
+    c_lpar	= 4,
+};
+
+static int operator_class(char c)
+{
+    if (isdigit((unsigned char) c))
+        return c_digit;
+    else if (c == '*' || c == '+' || c == '-' || c == '/')
+        return c_binop;
+    else if (c == ')')
+        return c_rpar;
+    else if (c == '(')
+        return c_lpar;
+    else
+        return c_other;
 }
 
+static void eval(nodelink **operator, nodelink **operand, char new_op)
+{
+    unsigned long a, b, op, c;
+
+    DEBUGMSG(("expValueTable", "eval: operator %c; new_op %c\n",
+              *operator ? (*operator)->data : '?', new_op));
+
+    while (*operator != NULL &&
+           priority(new_op) <= priority((*operator)->data)) {
+        b = pop(operand);
+        op = pop(operator);
+        if (op) {
+            a = pop(operand);
+            c = calculate(op, a, b);
+            DEBUGMSG(("expValueTable", "eval: %ld %c %ld -> %ld\n", a, (char)op,
+                      b, c));
+            push(operand, c);
+        } else {
+            DEBUGMSG(("expValueTable", "eval: returning %ld\n", b));
+            push(operand, b);
+            break;
+        }
+    }
 
+}
 
+static unsigned long get_result(const char *expr)
+{
+    int             position = 0;
+    unsigned long   a, result = 0;
+    const char     *expression;
+    nodelink       *operator = NULL;
+    nodelink       *operand = NULL;
 
+    expression = expr;
+    while (*(expression + position) != '\0'
+           && *(expression + position) != '\n') {
+        switch (operator_class(*(expression + position))) {
+        case c_digit:
+            push(&operand, get_operand(expression + position, &position));
+            break;
+        case c_binop:
+            eval(&operator, &operand, *(expression + position));
+            push(&operator, *(expression + position));
+            break;
+        case c_rpar:
+            eval(&operator, &operand, ')');
+            if (operator->data == '(')
+                pop(&operator);
+            break;
+        case c_lpar:
+            push(&operator, '(');
+            break;
+        default:
+            printf("\nInvalid character in expression:");
+            a = 0;
+            while (*(expression + (int) a) != '\n'
+                   && *(expression + (int) a) != '\0') {
+                if (a != position)
+                    printf("%c", *(expression + (int) a));
+                else
+                    printf("<%c>", *(expression + (int) a));
+                a++;
+            }
+            return 0;
+        }                       /* end switch */
+        position++;
+    }
+    eval(&operator, &operand, ')');
+    result = pop(&operand);
+    DEBUGMSG(("expValueTable", "%s: %s -> %ld\n", __func__, expr, result));
+    return result;
+}
 
-unsigned long
-Evaluate_Expression(struct expValueTable_data *vtable_data)
+static int iquery(struct variable_list **vars, char *secName, int snmp_version,
+                  const oid *name, int name_len)
 {
+    struct snmp_session *ss;
+    struct snmp_pdu *pdu;
+    struct snmp_pdu *response;
+    struct variable_list *v;
+    int status, rc = SNMP_ERR_GENERR;
+
+    ss = netsnmp_query_get_default_session();
+    if (!ss) {
+        snmp_log(LOG_ERR, "%s: default SNMP session not available\n", __func__);
+        goto out;
+    }
+
+    ss->retries = 0;
+
+    pdu = snmp_pdu_create(SNMP_MSG_GET);
+    if (!pdu) {
+        snmp_log(LOG_ERR, "%s: failed to create an SNMP PDU\n", __func__);
+        goto out;
+    }
+
+    if (snmp_add_null_var(pdu, name, name_len) == NULL) {
+        snmp_log(LOG_ERR, "%s: appending a variable to a PDU failed\n",
+                 __func__);
+        goto free_pdu;
+    }
+
+    DEBUGMSGTL(("expValueTable", "%s: querying OID ", __func__));
+    DEBUGMSGOID(("expValueTable", name, name_len));
+    DEBUGMSG(("expValueTable", "\n"));
+
+    status = snmp_synch_response(ss, pdu, &response);
+
+    DEBUGMSGTL(("expValueTable", "%s: SNMP response status %d; rc %ld\n",
+                __func__, status, response ? response->errstat : -1));
+
+    if (status != STAT_SUCCESS)
+        goto free_pdu;
 
+    rc = response->errstat;
+    *vars = snmp_clone_varbind(response->variables);
+    if (*vars == NULL)
+        goto free_response;
+
+    for (v = *vars; v; v = v->next_variable) {
+        DEBUGMSGTL(("expValueTable", "%s: response variable type %d; oid ",
+                    __func__, v->type));
+        DEBUGMSGOID(("expValueTable", v->name, v->name_length));
+        if (v->type == ASN_INTEGER)
+            DEBUGMSG(("expValueTable", "; value %ld\n", *v->val.integer));
+        DEBUGMSG(("expValueTable", "\n"));
+    }
+
+    rc = SNMPERR_SUCCESS;
+
+free_response:
+    if (response)
+        snmp_free_pdu(response);
+
+free_pdu:
+    /* if (pdu) snmp_free_pdu(pdu); -- triggers a use-after-free */
+
+out:
+    return rc;
+}
+
+static unsigned long Evaluate_Expression(struct expValueTable_data *vtable_data)
+{
     struct header_complex_index *hcindex;
     struct expObjectTable_data *objstorage, *objfound;
-    struct expValueTable_data *valstorage;
-    valstorage = vtable_data;
-
-    char           *expression;
+    struct expValueTable_data *const valstorage = vtable_data;
+    const char     *expression;
     char           *result, *resultbak;
     char           *temp, *tempbak;
-    char            intchar[10];
-    int             i = 0, j, k, l;
-    long            value;
-    unsigned long   result_u_long;
+    int             i = 0, j, l;
+    unsigned long   result_u_long = 0;
+    static int      level;
+
     temp = malloc(100);
     result = malloc(100);
     tempbak = temp;
@@ -255,8 +452,19 @@ Evaluate_Expression(struct expValueTable_data *vtable_data)
     *result = '\0';
     resultbak = result;
 
+    level++;
+
+    if (level > 1) {
+        snmp_log(LOG_ERR, "%s: detected recursion\n", __func__);
+        goto out;
+    }
+
     expression = vtable_data->expression_data->expExpression;
 
+    DEBUGMSGTL(("expValueTable", "%s(%s.%s): evaluating %s\n", __func__,
+                valstorage->expExpressionOwner, valstorage->expExpressionName,
+                expression));
+
     while (*expression != '\0') {
         if (*expression == '$') {
             objfound = NULL;
@@ -296,14 +504,19 @@ Evaluate_Expression(struct expValueTable_data *vtable_data)
                 }
             }
 
-
             if (!objfound) {
-                /* have err */
-                return 0;
+                snmp_log(LOG_ERR, "%s: lookup of expression %s.%s failed\n",
+                         __func__, valstorage->expExpressionOwner,
+                         valstorage->expExpressionName);
+                goto out;
             }
-            struct snmp_session *ss;
-            struct snmp_pdu *pdu;
-            struct snmp_pdu *response;
+
+            DEBUGMSGTL(("expValueTable", "%s: Found OID ", __func__));
+            DEBUGMSGOID(("expValueTable", objfound->expObjectID,
+                         objfound->expObjectIDLen));
+            DEBUGMSG(("expValueTable", "%s\n",
+                      objfound->expObjectIDWildcard ==
+                      EXPOBJCETIDWILDCARD_TRUE ? "(wildcard)" : ""));
 
             oid             anOID[MAX_OID_LEN];
             size_t          anOID_len;
@@ -319,124 +532,49 @@ Evaluate_Expression(struct expValueTable_data *vtable_data)
                        (valstorage->expValueInstanceLen -
                         2) * sizeof(oid));
             }
-            struct variable_list *vars;
-            int             status;
-
-            /*
-             * Initialize the SNMP library
-             */
-
-            /*
-             * Initialize a "session" that defines who we're going to talk to
-             */
-            session.version = vtable_data->expression_data->pdu_version;
-
-            /*
-             * set the SNMPv1 community name used for authentication 
-             */
-            session.community =
-                vtable_data->expression_data->pdu_community;
-            session.community_len =
-                vtable_data->expression_data->pdu_community_len;
-            /*
-             * Open the session
-             */
-            SOCK_STARTUP;
-            ss = snmp_open(&session);   /* establish the session */
-
-            if (!ss) {
-                /* err */
-                exit(2);
-            }
-            pdu = snmp_pdu_create(SNMP_MSG_GET);
-            snmp_add_null_var(pdu, anOID, anOID_len);
-
-            /*
-             * Send the Request out.
-             */
-            status = snmp_synch_response(ss, pdu, &response);
-
-            /*
-             * Process the response.
-             */
-            if (status == STAT_SUCCESS
-                && response->errstat == SNMP_ERR_NOERROR) {
-                /*
-                 * SUCCESS: Print the result variables
-                 */
-
-                vars = response->variables;
-                value = *(vars->val.integer);
-                sprintf(intchar, "%lu", value);
-                for (k = 1; k <= strlen(intchar); k++) {
-                    *result = intchar[k - 1];
-                    result++;
-                }
-
-            } else {
-                /*
-                 * FAILURE: print what went wrong!
-                 */
-
-                if (status == STAT_SUCCESS)
-                    fprintf(stderr, "Error in packet\nReason: %s\n",
-                            snmp_errstring(response->errstat));
-                else
-                    snmp_sess_perror("snmpget", ss);
-
-            }
-
-            /*
-             * Clean up:
-             *  1) free the response.
-             *  2) close the session.
-             */
-            if (response)
-                snmp_free_pdu(response);
-            snmp_close(ss);
-
-            SOCK_CLEANUP;
 
+            struct variable_list *vars;
+            int             rc;
+
+            rc = iquery(&vars,
+                        (char *)vtable_data->expression_data->pdu_community,
+                        vtable_data->expression_data->pdu_version,
+                        anOID, anOID_len);
+            if (rc != SNMP_ERR_NOERROR)
+                snmp_log(LOG_ERR, "Error in packet: %s\n", snmp_errstring(rc));
+            sprintf(result, "%lu", rc == SNMP_ERR_NOERROR ?
+                    *(vars->val.integer) : 0);
+            result += strlen(result);
         } else {
-            *result = *expression;
-            result++;
-            expression++;
+            *result++ = *expression++;
         }
     }
     result_u_long = get_result(resultbak);
+    DEBUGMSGTL(("expValueTable", "%s(%s.%s): evaluated %s into %ld\n", __func__,
+                valstorage->expExpressionOwner, valstorage->expExpressionName,
+                resultbak, result_u_long));
+
+out:
     free(tempbak);
     free(resultbak);
+    level--;
     return result_u_long;
 }
 
-
-
-
-
-
-
-
-void
-expValueTable_clean(void *data)
+static void expValueTable_clean(void *data)
 {
-    struct expValueTable_data *cleanme =
-        (struct expValueTable_data *) data;
+    struct expValueTable_data *cleanme = data;
+
     SNMP_FREE(cleanme->expValueInstance);
-    SNMP_FREE(cleanme->expValueIpAddressVal);
-    SNMP_FREE(cleanme->expValueOctetStringVal);
-    SNMP_FREE(cleanme->expValueOidVal);
     SNMP_FREE(cleanme);
 }
 
-
-
-void
-build_valuetable(void)
+static void build_valuetable(void)
 {
     struct expExpressionTable_data *expstorage;
     struct expObjectTable_data *objstorage, *objfound = NULL;
     struct header_complex_index *hcindex, *object_hcindex;
-    char           *expression;
+    const char     *expression;
     oid            *index;
     int             i = 0, j, l;
 
@@ -506,74 +644,30 @@ build_valuetable(void)
             *index = 0;
             *(index + 1) = 0;
             *(index + 2) = 0;
-            expValueTable_add(expstorage, objfound->expExpressionOwner,
+            expValueTable_set(expstorage, objfound->expExpressionOwner,
                               objfound->expExpressionOwnerLen,
                               objfound->expExpressionName,
                               objfound->expExpressionNameLen, index, 3);
         } else {
-            oid            *targetOID;
-            size_t          taggetOID_len;
-            targetOID = objfound->expObjectID;
-            struct snmp_pdu *pdu;
-            struct snmp_pdu *response;
+            oid            *targetOID = objfound->expObjectID;
+            size_t          taggetOID_len = objfound->expObjectIDLen;
             oid            *next_OID;
             size_t          next_OID_len;
-            taggetOID_len = objfound->expObjectIDLen;
-            int             status;
-            struct snmp_session *ss;
-            /*
-             * Initialize the SNMP library
-             */
-
-
-            /*
-             * set the SNMP version number 
-             */
-            session.version = expstorage->pdu_version;
-
-            /*
-             * set the SNMPv1 community name used for authentication 
-             */
-            session.community = expstorage->pdu_community;
-            session.community_len = expstorage->pdu_community_len;
-
-            /*
-             * Open the session
-             */
-            SOCK_STARTUP;
-            ss = snmp_open(&session);   /* establish the session */
-            if (!ss) {
-                snmp_perror("ack");
-                snmp_log(LOG_ERR, "something horrible happened!!!\n");
-                exit(2);
-            }
+            struct variable_list *vars;
+            int             rc;
 
             next_OID = targetOID;
             next_OID_len = taggetOID_len;
             do {
                 index = calloc(1, MAX_OID_LEN);
-                pdu = snmp_pdu_create(SNMP_MSG_GETNEXT);
-
-                snmp_add_null_var(pdu, next_OID, next_OID_len);
-
-                /*
-                 * Send the Request out.
-                 */
-                status = snmp_synch_response(ss, pdu, &response);
-
-                /*
-                 * Process the response.
-                 */
-                if (status == STAT_SUCCESS
-                    && response->errstat == SNMP_ERR_NOERROR) {
-                    /*
-                     * SUCCESS: Print the result variables
-                     */
-
-                    if (((response->variables->type >= SNMP_NOSUCHOBJECT &&
-                          response->variables->type <= SNMP_ENDOFMIBVIEW)
+
+                rc = iquery(&vars, (char *)expstorage->pdu_community,
+                            expstorage->pdu_version, next_OID, next_OID_len);
+                if (rc == SNMP_ERR_NOERROR) {
+                    if (((vars->type >= SNMP_NOSUCHOBJECT &&
+                          vars->type <= SNMP_ENDOFMIBVIEW)
                          || snmp_oid_compare(targetOID, taggetOID_len,
-                                             response->variables->name,
+                                             vars->name,
                                              taggetOID_len) != 0)) {
                         break;
                     }
@@ -581,80 +675,64 @@ build_valuetable(void)
 
                     *index = 0;
                     *(index + 1) = 0;
-                    memcpy(index + 2,
-                           response->variables->name + taggetOID_len,
-                           (response->variables->name_length -
-                            taggetOID_len) * sizeof(oid));
-                    expValueTable_add(expstorage,
+                    memcpy(index + 2, vars->name + taggetOID_len,
+                           (vars->name_length - taggetOID_len) * sizeof(oid));
+                    expValueTable_set(expstorage,
                                       objfound->expExpressionOwner,
                                       objfound->expExpressionOwnerLen,
                                       objfound->expExpressionName,
                                       objfound->expExpressionNameLen,
                                       index,
-                                      response->variables->name_length -
+                                      vars->name_length -
                                       taggetOID_len + 2);
 
-                    next_OID = response->variables->name;
-
-                    next_OID_len = response->variables->name_length;
-
-
-
-
+                    next_OID = vars->name;
+                    next_OID_len = vars->name_length;
                 } else {
-                    /*
-                     * FAILURE: print what went wrong!
-                     */
-                    if (status == STAT_SUCCESS)
-                        fprintf(stderr, "Error in packet\nReason: %s\n",
-                                snmp_errstring(response->errstat));
-                    else
-                        snmp_sess_perror("snmpget", ss);
+                    snmp_log(LOG_ERR, "Error in packet: %s\n",
+                             snmp_errstring(rc));
                 }
             } while (TRUE);
-
         }
-
     }
-
 }
 
-
-
-/*
- * var_expValueTable():
- */
-unsigned char  *
-var_expValueTable(struct variable *vp,
-                  oid * name,
-                  size_t *length,
-                  int exact, size_t *var_len, WriteMethod ** write_method)
+static unsigned char *var_expValueTable(struct variable *vp, oid * name,
+                                        size_t *length, int exact,
+                                        size_t *var_len,
+                                        WriteMethod ** write_method)
 {
-
     struct expValueTable_data *StorageTmp = NULL;
 
-
-
-
     DEBUGMSGTL(("expValueTable", "var_expValueTable: Entering...  \n"));
 
-    /*
-     *  before we build valuetable we must free any other valutable if exist
-     */
-    header_complex_free_all(expValueTableStorage, expValueTable_clean);
-    expValueTableStorage = NULL;
+    struct header_complex_index *hciptr, *hciptrn;
 
+    for (hciptr = expValueTableStorage; hciptr; hciptr = hciptr->next) {
+        StorageTmp = hciptr->data;
+        StorageTmp->set = 0;
+    }
 
     build_valuetable();
 
+    for (hciptr = expValueTableStorage; hciptr; hciptr = hciptrn) {
+        hciptrn = hciptr->next;
+        StorageTmp = hciptr->data;
+        if (!StorageTmp->set)
+            header_complex_free_entry(hciptr, expValueTable_clean);
+    }
 
     /*
      * this assumes you have registered all your data properly
      */
     if ((StorageTmp =
          header_complex(expValueTableStorage, vp, name, length, exact,
-                        var_len, write_method)) == NULL)
+                        var_len, write_method)) == NULL) {
+        DEBUGMSGTL(("expValueTable", "%s: entry not found.\n", __func__));
         return NULL;
+    }
+
+    DEBUGMSGTL(("expValueTable", "%s: vp->magic = %d.\n", __func__, vp->magic));
 
 
     /*
@@ -709,165 +787,3 @@ var_expValueTable(struct variable *vp,
 	return NULL;
     }
 }
-
-
-
-
-
-void
-push(nodelink ** stack, unsigned long value)
-{
-    nodelink           *newnode;
-    newnode = (nodelink *) malloc(sizeof(nodelink));
-    if (!newnode) {
-        printf("\nMemory allocation failure!");
-        return;
-    }
-    newnode->data = value;
-    newnode->next = *stack;
-    *stack = newnode;
-}
-
-unsigned long
-pop(nodelink ** stack)
-{
-    unsigned long   value;
-    nodelink           *top;
-    top = *stack;
-    *stack = (*stack)->next;
-    value = top->data;
-    free(top);
-    return value;
-}
-
-int
-priority(char operater)
-{
-    switch (operater) {
-    case '*':
-    case '/':
-        return 4;
-    case '+':
-    case '-':
-        return 3;
-    case ')':
-        return 2;
-    case '(':
-        return 1;
-    default:
-        return 0;
-    }
-}
-
-unsigned long
-calculate(int operater, unsigned long a, unsigned long b)
-{
-    switch (operater) {
-    case '+':
-        return (a + b);
-    case '-':
-        return (a - b);
-    case '*':
-        return (a * b);
-    case '/':
-        if (operater == '/' && b == 0) {
-            printf("\nDivision mustn\'t be 0!");
-            exit(0);
-        } else
-            return (a / b);
-    }
-    return 0;
-}
-
-unsigned long
-get_operand(char *p, int *length)
-{
-    char            c[13];
-    int             i = 0, k = 1;
-    unsigned long   result = 0;
-    while (*p <= 57 && *p >= 48)
-        c[i++] = *(p++);
-    *length += --i;
-    for (; i >= 0; i--) {
-        result += (c[i] - 48) * k;
-        k *= 10;
-    }
-    return result;
-}
-
-int
-operator_class(char c)
-{
-    if (c <= 57 && c >= 48)
-        return 1;
-    if (c == 42 || c == 43 || c == 45 || c == 47)
-        return 2;
-    if (c == 41)
-        return 3;
-    if (c == 40)
-        return 4;
-    return 0;
-}
-
-unsigned long
-get_result(char *expr)
-{
-    int             position = 0;
-    unsigned long   op = 0, a = 0, b = 0, result = 0;
-    char           *expression;
-    expression = expr;
-    while (*(expression + position) != '\0'
-           && *(expression + position) != '\n') {
-        switch (operator_class(*(expression + position))) {
-        case 1:
-            push(&operand, get_operand(expression + position, &position));
-            break;
-        case 2:
-            if (operater != NULL)
-                while (operater != NULL
-                       && priority(*(expression + position)) <=
-                       priority(operater->data)) {
-                    a = pop(&operand);
-                    b = pop(&operand);
-                    op = pop(&operater);
-                    push(&operand, calculate(op, b, a));
-                }
-            push(&operater, *(expression + position));
-            break;
-        case 3:
-            while (operater != NULL && operater->data != '(') {
-                a = pop(&operand);
-                b = pop(&operand);
-                op = pop(&operater);
-                push(&operand, calculate(op, b, a));
-            }
-            if (operater->data == '(')
-                pop(&operater);
-            break;
-        case 4:
-            push(&operater, '(');
-            break;
-        default:
-            printf("\nInvalid character in expression:");
-            a = 0;
-            while (*(expression + (int) a) != '\n'
-                   && *(expression + (int) a) != '\0') {
-                if (a != position)
-                    printf("%c", *(expression + (int) a));
-                else
-                    printf("<%c>", *(expression + (int) a));
-                a++;
-            }
-            exit(0);
-        }                       /* end switch */
-        position++;
-    }
-    while (operater != NULL) {
-        op = pop(&operater);
-        a = pop(&operand);
-        b = pop(&operand);
-        push(&operand, calculate(op, b, a));
-    }
-    result = pop(&operand);
-    return result;
-}
diff --git a/agent/mibgroup/disman/expression/expValueTable.h b/agent/mibgroup/disman/expression/expValueTable.h
index 8569f9d..f88208f 100644
--- a/agent/mibgroup/disman/expression/expValueTable.h
+++ b/agent/mibgroup/disman/expression/expValueTable.h
@@ -25,9 +25,9 @@ config_require(header_complex)
 #ifndef _MIBGROUP_EXPVALUETABLE_H
 #define _MIBGROUP_EXPVALUETABLE_H
      struct expValueTable_data {
-         char           *expExpressionOwner;
+         const char     *expExpressionOwner;
          size_t          expExpressionOwnerLen;
-         char           *expExpressionName;
+         const char     *expExpressionName;
          size_t          expExpressionNameLen;
          oid            *expValueInstance;
          size_t          expValueInstanceLen;
@@ -35,16 +35,17 @@ config_require(header_complex)
          unsigned long   expValueUnsigned32Val;
          unsigned long   expValueTimeTicksVal;
          long            expValueInteger32Val;
-         u_long         *expValueIpAddressVal;
-         char           *expValueOctetStringVal;
+         const u_long   *expValueIpAddressVal;
+         const char     *expValueOctetStringVal;
          size_t          expValueOctetStringValLen;
-         oid            *expValueOidVal;
+         const oid      *expValueOidVal;
          size_t          expValueOidValLen;
          long            expValueCounter64Val;
 
          /* internal var */
          struct expExpressionTable_data *expression_data;
          char           *valuestr;
+         int             set;
      };
 
 
@@ -52,12 +53,5 @@ config_require(header_complex)
      * function prototypes 
      */
      void            init_expValueTable(void);
-     unsigned long   get_result(char *expr);
-     FindVarMethod   var_expValueTable;
-     int             expValueTable_add(struct expExpressionTable_data
-                                       *expression_data, char *owner,
-                                       size_t owner_len, char *name,
-                                       size_t name_len, oid * index,
-                                       size_t index_len);
 
 #endif                          /* _MIBGROUP_EXPVALUETABLE_H */
diff --git a/agent/mibgroup/disman/mteEventTable.c b/agent/mibgroup/disman/mteEventTable.c
index 22bad73..6b3ee8f 100644
--- a/agent/mibgroup/disman/mteEventTable.c
+++ b/agent/mibgroup/disman/mteEventTable.c
@@ -263,7 +263,7 @@ run_mte_events(struct mteTriggerTable_data *item,
             
             tc = netsnmp_table_data_set_find_column(col1,
                                                     COLUMN_MTEEVENTACTIONS);
-            if (!tc->data.bitstring[0] & 0x80) {
+            if (!(tc->data.bitstring[0] & 0x80)) {
                 /* not a notification.  next! (XXX: do sets) */
                 continue;
             }
diff --git a/agent/mibgroup/disman/mteObjectsTable.c b/agent/mibgroup/disman/mteObjectsTable.c
index 09ceb2a..ed2ecbd 100644
--- a/agent/mibgroup/disman/mteObjectsTable.c
+++ b/agent/mibgroup/disman/mteObjectsTable.c
@@ -801,7 +801,7 @@ write_mteObjectsEntryStatus(int action,
          * permanently.  Make sure that anything done here can't fail! 
          */
         if (StorageDel != NULL) {
-            StorageDel = 0;
+            StorageDel = NULL;
             /*
              * XXX: free it, its dead 
              */
diff --git a/agent/mibgroup/disman/mteTriggerBooleanTable.c b/agent/mibgroup/disman/mteTriggerBooleanTable.c
index 5b17927..fccc7ad 100644
--- a/agent/mibgroup/disman/mteTriggerBooleanTable.c
+++ b/agent/mibgroup/disman/mteTriggerBooleanTable.c
@@ -110,12 +110,6 @@ struct variable2 mteTriggerBooleanTable_variables[] = {
 
 
 /*
- * global storage of our data, saved in and configured by header_complex() 
- */
-extern struct header_complex_index *mteTriggerTableStorage;
-
-
-/*
  * init_mteTriggerBooleanTable():
  *   Initialization routine.  This is called when the agent starts up.
  *   At a minimum, registration of your variables should take place here.
diff --git a/agent/mibgroup/disman/mteTriggerDeltaTable.c b/agent/mibgroup/disman/mteTriggerDeltaTable.c
index c829e6a..f5f2fe7 100644
--- a/agent/mibgroup/disman/mteTriggerDeltaTable.c
+++ b/agent/mibgroup/disman/mteTriggerDeltaTable.c
@@ -86,13 +86,6 @@ struct variable2 mteTriggerDeltaTable_variables[] = {
 
 
 /*
- * global storage of our data, saved in and configured by header_complex() 
- */
-extern struct header_complex_index *mteTriggerTableStorage;
-
-
-
-/*
  * init_mteTriggerDeltaTable():
  *   Initialization routine.  This is called when the agent starts up.
  *   At a minimum, registration of your variables should take place here.
diff --git a/agent/mibgroup/disman/mteTriggerExistenceTable.c b/agent/mibgroup/disman/mteTriggerExistenceTable.c
index 4e6b64b..18b578c 100644
--- a/agent/mibgroup/disman/mteTriggerExistenceTable.c
+++ b/agent/mibgroup/disman/mteTriggerExistenceTable.c
@@ -104,14 +104,6 @@ struct variable2 mteTriggerExistenceTable_variables[] = {
 
 
 /*
- * global storage of our data, saved in and configured by header_complex() 
- */
-extern struct header_complex_index *mteTriggerTableStorage;
-
-
-
-
-/*
  * init_mteTriggerExistenceTable():
  *   Initialization routine.  This is called when the agent starts up.
  *   At a minimum, registration of your variables should take place here.
diff --git a/agent/mibgroup/disman/mteTriggerTable.c b/agent/mibgroup/disman/mteTriggerTable.c
index 80a45a3..748ac07 100644
--- a/agent/mibgroup/disman/mteTriggerTable.c
+++ b/agent/mibgroup/disman/mteTriggerTable.c
@@ -189,7 +189,6 @@ struct variable2 mteTriggerTable_variables[] = {
 struct header_complex_index *mteTriggerTableStorage = NULL;
 
 netsnmp_session *mte_callback_sess = NULL;
-extern int      callback_master_num;
 
 /*
  * init_mteTriggerTable():
@@ -468,7 +467,7 @@ parse_simple_monitor(const char *token, char *line)
                      */
                     return;
                 }
-                StorageNew->mteTriggerFrequency = (unsigend long) freq;
+                StorageNew->mteTriggerFrequency = (unsigned long) freq;
             } else {
                 config_perror("No parameter after -r given\n");
                 /*
@@ -2917,7 +2916,7 @@ write_mteTriggerEntryStatus(int action,
          */
         if (StorageDel != NULL) {
             mte_disable_trigger(StorageDel);
-            StorageDel = 0;
+            StorageDel = NULL;
             /*
              * XXX: free it, its dead 
              */
@@ -3164,7 +3163,7 @@ mte_get_response(struct mteTriggerTable_data *item, netsnmp_pdu *pdu)
              * xxx 
              */
             char           *errstr;
-            snmp_error(mte_callback_sess, 0, 0, &errstr);
+            snmp_error(mte_callback_sess, NULL, NULL, &errstr);
             if (response) {
                 DEBUGMSGTL(("mteTriggerTable",
                             "Error received: status=%d, sess_error=%s, pduerr=%d/%s, pdu version=%d\n",
diff --git a/agent/mibgroup/disman/mteTriggerTable.h b/agent/mibgroup/disman/mteTriggerTable.h
index c427602..898b014 100644
--- a/agent/mibgroup/disman/mteTriggerTable.h
+++ b/agent/mibgroup/disman/mteTriggerTable.h
@@ -215,6 +215,8 @@ config_error(disman/mteTriggerTable depends on the Callback transport)
 #define MTE_FAILURE_SAMPLEOVERRUN		-6
 
 
+     extern struct header_complex_index *mteTriggerTableStorage;
+
 /*
  * function prototypes 
  */
diff --git a/agent/mibgroup/disman/mteTriggerThresholdTable.c b/agent/mibgroup/disman/mteTriggerThresholdTable.c
index be963c1..ca0efa9 100644
--- a/agent/mibgroup/disman/mteTriggerThresholdTable.c
+++ b/agent/mibgroup/disman/mteTriggerThresholdTable.c
@@ -157,11 +157,6 @@ struct variable2 mteTriggerThresholdTable_variables[] = {
  * (L = length of the oidsuffix) 
  */
 
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-extern struct header_complex_index *mteTriggerTableStorage;
-
 
 /*
  * init_mteTriggerThresholdTable():
diff --git a/agent/mibgroup/disman/nslookup/lookupCtlTable.c b/agent/mibgroup/disman/nslookup/lookupCtlTable.c
index 0f71da6..baced25 100644
--- a/agent/mibgroup/disman/nslookup/lookupCtlTable.c
+++ b/agent/mibgroup/disman/nslookup/lookupCtlTable.c
@@ -217,22 +217,19 @@ lookupResultsTable_add(struct lookupTable_data *thedata)
 void
 lookupCtlTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr = NULL;
-    struct lookupTable_data *StorageDel = NULL;
+    struct header_complex_index *hciptr, *nhciptr;
+    struct lookupTable_data *StorageDel;
+
     DEBUGMSGTL(("lookupCtlTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
-        StorageDel =
-            header_complex_extract_entry(&lookupCtlTableStorage, hciptr);
+    for (hciptr = thestuff; hciptr; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
+        StorageDel = header_complex_extract_entry(&lookupCtlTableStorage,
+                                                  hciptr);
         if (StorageDel != NULL) {
             free(StorageDel->lookupCtlOwnerIndex);
-            StorageDel->lookupCtlOwnerIndex = NULL;
             free(StorageDel->lookupCtlOperationName);
-            StorageDel->lookupCtlOperationName = NULL;
             free(StorageDel->lookupCtlTargetAddress);
-            StorageDel->lookupCtlTargetAddress = NULL;
             free(StorageDel);
-            StorageDel = NULL;
-
         }
         DEBUGMSGTL(("lookupCtlTable", "cleaner  "));
     }
@@ -887,8 +884,8 @@ modify_lookupCtlRc(struct lookupTable_data *thedata, long val)
 int
 lookupResultsTable_del(struct lookupTable_data *thedata)
 {
-    struct header_complex_index *hciptr2 = NULL;
-    struct lookupResultsTable_data *StorageDel = NULL;
+    struct header_complex_index *hciptr2, *nhciptr2;
+    struct lookupResultsTable_data *StorageDel;
     netsnmp_variable_list *vars = NULL;
     oid             newoid[MAX_OID_LEN];
     size_t          newoid_len;
@@ -901,11 +898,10 @@ lookupResultsTable_del(struct lookupTable_data *thedata)
     memset(newoid, '\0', MAX_OID_LEN * sizeof(oid));
     header_complex_generate_oid(newoid, &newoid_len, NULL, 0, vars);
 
-
     snmp_free_varbind(vars);
     vars = NULL;
-    for (hciptr2 = lookupResultsTableStorage; hciptr2 != NULL;
-         hciptr2 = hciptr2->next) {
+    for (hciptr2 = lookupResultsTableStorage; hciptr2; hciptr2 = nhciptr2) {
+        nhciptr2 = hciptr2->next;
         if (snmp_oid_compare(newoid, newoid_len, hciptr2->name, newoid_len)
             == 0) {
             StorageDel =
@@ -918,7 +914,6 @@ lookupResultsTable_del(struct lookupTable_data *thedata)
                 SNMP_FREE(StorageDel);
             }
             DEBUGMSGTL(("lookupResultsTable", "delete  success!\n"));
-
         }
     }
     return SNMPERR_SUCCESS;
diff --git a/agent/mibgroup/disman/nslookup/lookupCtlTable.h b/agent/mibgroup/disman/nslookup/lookupCtlTable.h
index 085b25b..417f630 100644
--- a/agent/mibgroup/disman/nslookup/lookupCtlTable.h
+++ b/agent/mibgroup/disman/nslookup/lookupCtlTable.h
@@ -56,6 +56,9 @@ struct lookupResultsTable_data {
     int             storagetype;
 };
 
+extern struct header_complex_index *lookupCtlTableStorage;
+extern struct header_complex_index *lookupResultsTableStorage;
+
 /*
  * function declarations 
  */
diff --git a/agent/mibgroup/disman/nslookup/lookupResultsTable.c b/agent/mibgroup/disman/nslookup/lookupResultsTable.c
index d6a937c..6813795 100644
--- a/agent/mibgroup/disman/nslookup/lookupResultsTable.c
+++ b/agent/mibgroup/disman/nslookup/lookupResultsTable.c
@@ -34,12 +34,6 @@ struct variable2 lookupResultsTable_variables[] = {
      var_lookupResultsTable, 2, {1, 3}}
 };
 
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-
-extern struct header_complex_index *lookupCtlTableStorage;
-extern struct header_complex_index *lookupResultsTableStorage;
 
 int
 lookupResultsTable_inadd(struct lookupResultsTable_data *thedata);
@@ -47,13 +41,14 @@ lookupResultsTable_inadd(struct lookupResultsTable_data *thedata);
 void
 lookupResultsTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr = NULL;
-    struct lookupResultsTable_data *StorageDel = NULL;
+    struct header_complex_index *hciptr, *nhciptr;
+    struct lookupResultsTable_data *StorageDel;
+
     DEBUGMSGTL(("lookupResultsTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
-        StorageDel =
-            header_complex_extract_entry(&lookupResultsTableStorage,
-                                         hciptr);
+    for (hciptr = thestuff; hciptr; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
+        StorageDel = header_complex_extract_entry(&lookupResultsTableStorage,
+                                                  hciptr);
         if (StorageDel != NULL) {
             SNMP_FREE(StorageDel->lookupCtlOwnerIndex);
             SNMP_FREE(StorageDel->lookupCtlOperationName);
@@ -62,8 +57,8 @@ lookupResultsTable_cleaner(struct header_complex_index *thestuff)
         }
         DEBUGMSGTL(("lookupResultsTable", "cleaner  "));
     }
-
 }
+
 void
 init_lookupResultsTable(void)
 {
diff --git a/agent/mibgroup/disman/ping/pingCtlTable.c b/agent/mibgroup/disman/ping/pingCtlTable.c
index 87b09ef..3e3157a 100644
--- a/agent/mibgroup/disman/ping/pingCtlTable.c
+++ b/agent/mibgroup/disman/ping/pingCtlTable.c
@@ -57,6 +57,23 @@ static char    *pr_addr(struct in6_addr *, int);
 static char    *pr_addr_n(struct in6_addr *);
 void pingCtlTable_cleaner(struct header_complex_index *thestuff);
 
+static char rcvd_tbl[MAX_DUP_CHK / 8];
+
+static struct proto {
+    int             (*fproc) (char *, ssize_t, struct timeval *, time_t,
+                              struct pingCtlTable_data *,
+                              struct addrinfo *, int, unsigned long *,
+                              unsigned long *, unsigned long *,
+                              unsigned long *, unsigned long, int, int,
+                              int, struct pingProbeHistoryTable_data *,
+                              pid_t);
+    void            (*fsend) (int, pid_t, int, int, char *);
+    struct sockaddr *sasend;    /* sockaddr{} for send, from getaddrinfo */
+    struct sockaddr *sarecv;    /* sockaddr{} for receiving */
+    socklen_t       salen;      /* length of sockaddr{}s */
+    int             icmpproto;  /* IPPROTO_xxx value for ICMP */
+} *pr;
+
 /*
  *pingCtlTable_variables_oid:
  *                                                      
@@ -507,6 +524,7 @@ parse_pingCtlTable(const char *token, char *line)
                               &StorageTmp->pingCtlSourceAddressLen);
     if (StorageTmp->pingCtlSourceAddress == NULL) {
         config_perror("invalid specification for pingCtlSourceAddress");
+        free(StorageTmp);
         return;
     }
 
@@ -1012,6 +1030,7 @@ sock_ntop_host(const struct sockaddr *sa, socklen_t salen)
 }
 
 
+#if 0
 char           *
 Sock_ntop_host(const struct sockaddr *sa, socklen_t salen)
 {
@@ -1023,6 +1042,7 @@ Sock_ntop_host(const struct sockaddr *sa, socklen_t salen)
     }
     return (ptr);
 }
+#endif
 
 
 
@@ -1083,6 +1103,7 @@ host_serv(const char *host, const char *serv, int family, int socktype)
  * end host_serv 
  */
 
+#if 0
 /*
  * There is no easy way to pass back the integer return code from
  * getaddrinfo() in the function above, short of adding another argument
@@ -1116,6 +1137,7 @@ Host_serv(const char *host, const char *serv, int family, int socktype)
 
     return (res);               /* return pointer to first on linked list */
 }
+#endif
 
 int
 readable_timeo(int fd, int sec)
@@ -1944,6 +1966,7 @@ run_ping(unsigned int clientreg, void *clientarg)
                        sz_opt);
         if (err < 0) {
             perror("setsockopt(RAW_CHECKSUM)");
+            free(packet);
             return;
         }
 
@@ -1967,6 +1990,7 @@ run_ping(unsigned int clientreg, void *clientarg)
 
         if (err < 0) {
             perror("setsockopt(ICMP6_FILTER)");
+            free(packet);
             return;
         }
 
@@ -1975,6 +1999,7 @@ run_ping(unsigned int clientreg, void *clientarg)
             if (setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_HOPLIMIT,
                            &on, sizeof(on)) == -1) {
                 perror("can't receive hop limit");
+                free(packet);
                 return;
             }
         }
@@ -4960,6 +4985,7 @@ main_loop(struct pingCtlTable_data *item, int icmp_sock, int preload,
             msg.msg_iovlen = 1;
             msg.msg_control = ans_data;
             msg.msg_controllen = sizeof(ans_data);
+            msg.msg_flags = 0;
 
             cc = recvmsg(icmp_sock, &msg, polling);
             time_t          timep;
diff --git a/agent/mibgroup/disman/ping/pingCtlTable.h b/agent/mibgroup/disman/ping/pingCtlTable.h
index ca69d13..74a7a85 100644
--- a/agent/mibgroup/disman/ping/pingCtlTable.h
+++ b/agent/mibgroup/disman/ping/pingCtlTable.h
@@ -201,6 +201,9 @@ struct pingProbeHistoryTable_data {
 
 };
 
+extern struct header_complex_index *pingCtlTableStorage;
+extern struct header_complex_index *pingResultsTableStorage;
+extern struct header_complex_index *pingProbeHistoryTableStorage;
 
 /*
  * function declarations 
@@ -285,20 +288,6 @@ void            readloop(struct pingCtlTable_data *, struct addrinfo *,
 void            sig_alrm(int);
 void            tv_sub(struct timeval *, struct timeval *);
 unsigned long   round_double(double);
-struct proto {
-    int             (*fproc) (char *, ssize_t, struct timeval *, time_t,
-                              struct pingCtlTable_data *,
-                              struct addrinfo *, int, unsigned long *,
-                              unsigned long *, unsigned long *,
-                              unsigned long *, unsigned long, int, int,
-                              int, struct pingProbeHistoryTable_data *,
-                              pid_t);
-    void            (*fsend) (int, pid_t, int, int, char *);
-    struct sockaddr *sasend;    /* sockaddr{} for send, from getaddrinfo */
-    struct sockaddr *sarecv;    /* sockaddr{} for receiving */
-    socklen_t       salen;      /* length of sockaddr{}s */
-    int             icmpproto;  /* IPPROTO_xxx value for ICMP */
-}              *pr;
 
 
 /*
@@ -337,7 +326,6 @@ struct proto {
 
 
 #define	MAX_DUP_CHK	0x10000
-char            rcvd_tbl[MAX_DUP_CHK / 8];
 
 volatile int    exiting;
 volatile int    status_snapshot;
diff --git a/agent/mibgroup/disman/ping/pingProbeHistoryTable.c b/agent/mibgroup/disman/ping/pingProbeHistoryTable.c
index 78c75be..753d51d 100644
--- a/agent/mibgroup/disman/ping/pingProbeHistoryTable.c
+++ b/agent/mibgroup/disman/ping/pingProbeHistoryTable.c
@@ -61,27 +61,24 @@ struct variable2 pingProbeHistoryTable_variables[] = {
 };
 
 
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-
-extern struct header_complex_index *pingCtlTableStorage;
-extern struct header_complex_index *pingProbeHistoryTableStorage;
 int
 pingProbeHistoryTable_inadd(struct pingProbeHistoryTable_data *thedata);
 
+#if 0
 void
 pingProbeHistoryTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr = NULL;
+    struct header_complex_index *hciptr, *nhciptr;
 
     DEBUGMSGTL(("pingProbeHistoryTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
+    for (hciptr = thestuff; hciptr; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
         header_complex_extract_entry(&pingProbeHistoryTableStorage, hciptr);
         DEBUGMSGTL(("pingProbeHistoryTable", "cleaner  "));
     }
-
 }
+#endif
+
 void
 init_pingProbeHistoryTable(void)
 {
@@ -137,6 +134,7 @@ parse_pingProbeHistoryTable(const char *token, char *line)
                               &StorageTmp->pingCtlOwnerIndexLen);
     if (StorageTmp->pingCtlOwnerIndex == NULL) {
         config_perror("invalid specification for pingCtlOwnerIndex");
+        free(StorageTmp);
         return;
     }
 
@@ -146,6 +144,7 @@ parse_pingProbeHistoryTable(const char *token, char *line)
                               &StorageTmp->pingCtlTestNameLen);
     if (StorageTmp->pingCtlTestName == NULL) {
         config_perror("invalid specification for pingCtlTestName");
+        free(StorageTmp);
         return;
     }
 
@@ -171,6 +170,7 @@ parse_pingProbeHistoryTable(const char *token, char *line)
                               &StorageTmp->pingProbeHistoryTimeLen);
     if (StorageTmp->pingProbeHistoryTime == NULL) {
         config_perror("invalid specification for pingProbeHistoryTime");
+        free(StorageTmp);
         return;
     }
 
diff --git a/agent/mibgroup/disman/ping/pingResultsTable.c b/agent/mibgroup/disman/ping/pingResultsTable.c
index 1445d86..a0a3eb9 100644
--- a/agent/mibgroup/disman/ping/pingResultsTable.c
+++ b/agent/mibgroup/disman/ping/pingResultsTable.c
@@ -72,29 +72,24 @@ struct variable2 pingResultsTable_variables[] = {
 };
 
 
-
-
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-
-extern struct header_complex_index *pingCtlTableStorage;
-extern struct header_complex_index *pingResultsTableStorage;
 int
 pingResultsTable_inadd(struct pingResultsTable_data *thedata);
 
+#if 0
 void
 pingResultsTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr;
+    struct header_complex_index *hciptr, *nhciptr;
 
     DEBUGMSGTL(("pingResultsTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
+    for (hciptr = thestuff; hciptr; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
         header_complex_extract_entry(&pingResultsTableStorage, hciptr);
         DEBUGMSGTL(("pingResultsTable", "cleaner  "));
     }
-
 }
+#endif
+
 void
 init_pingResultsTable(void)
 {
diff --git a/agent/mibgroup/disman/traceroute/traceRouteCtlTable.c b/agent/mibgroup/disman/traceroute/traceRouteCtlTable.c
index b925c5e..90d9f8b 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteCtlTable.c
+++ b/agent/mibgroup/disman/traceroute/traceRouteCtlTable.c
@@ -138,6 +138,110 @@ init_traceRouteCtlTable(void)
     DEBUGMSGTL(("traceRouteCtlTable", "done.\n"));
 }
 
+static void
+init_trResultsTable_ipv4(char *host,
+                         struct traceRouteResultsTable_data *StorageTmp)
+{
+    struct sockaddr whereto;        /* Who to try to reach */
+    struct sockaddr_in *to = (struct sockaddr_in *) &whereto;
+    struct hostinfo *hi;
+
+    hi = gethostinfo(host);
+    if (hi == NULL) {
+        DEBUGMSGTL(("traceRouteCtlTable", "hi calloc %s\n",
+                    strerror(errno)));
+        exit(1);
+    }
+
+    setsin(to, hi->addrs[0]);
+    if (inet_ntoa(to->sin_addr) == NULL) {
+        StorageTmp->traceRouteResultsIpTgtAddrType = 0;
+        StorageTmp->traceRouteResultsIpTgtAddr = strdup("");
+        StorageTmp->traceRouteResultsIpTgtAddrLen = 0;
+    } else {
+        StorageTmp->traceRouteResultsIpTgtAddrType = 1;
+        StorageTmp->traceRouteResultsIpTgtAddr =
+            (char *) malloc(sizeof(char) *
+                            (strlen(inet_ntoa(to->sin_addr)) + 1));
+        if (StorageTmp->traceRouteResultsIpTgtAddr == NULL) {
+            DEBUGMSGTL(("traceRouteCtlTable",
+                        "traceRouteResultsIpTgtAddr malloc %s\n",
+                        strerror(errno)));
+            exit(1);
+        }
+
+        memcpy(StorageTmp->traceRouteResultsIpTgtAddr, inet_ntoa(to->sin_addr),
+               strlen(inet_ntoa(to->sin_addr)) + 1);
+        StorageTmp->traceRouteResultsIpTgtAddr[strlen(inet_ntoa(to->sin_addr))]
+            = '\0';
+        StorageTmp->traceRouteResultsIpTgtAddrLen =
+            strlen(inet_ntoa(to->sin_addr));
+    }
+    freehostinfo(hi);
+}
+
+static void
+init_trResultsTable_ipv6(char *host,
+                         struct traceRouteResultsTable_data *StorageTmp)
+{
+    struct sockaddr_in6 whereto;    /* Who to try to reach */
+    struct sockaddr_in6 *to = (struct sockaddr_in6 *) &whereto;
+    struct hostent *hp = NULL;
+    /* struct hostenv hp; */
+    char            pa[64];
+
+    memset(pa, '\0', 64);
+
+    to->sin6_family = AF_INET6;
+    to->sin6_port = htons(33434);
+
+    if (inet_pton(AF_INET6, host, &to->sin6_addr) > 0) {
+        StorageTmp->traceRouteResultsIpTgtAddrType = 2;
+        StorageTmp->traceRouteResultsIpTgtAddr =
+            (char *) malloc(sizeof(char) * (strlen(host) + 1));
+        if (StorageTmp->traceRouteResultsIpTgtAddr == NULL) {
+            DEBUGMSGTL(("traceRouteCtlTable",
+                        "traceRouteResultsIpTgtAddr malloc %s\n",
+                        strerror(errno)));
+            exit(1);
+        }
+        memset(StorageTmp->traceRouteResultsIpTgtAddr, '\0',
+               sizeof(char) * (strlen(host) + 1));
+        memcpy(StorageTmp->traceRouteResultsIpTgtAddr, host, strlen(host) + 1);
+        StorageTmp->traceRouteResultsIpTgtAddr[strlen(host)] = '\0';
+        StorageTmp->traceRouteResultsIpTgtAddrLen = strlen(host);
+    } else {
+        hp = gethostbyname2(host, AF_INET6);
+        if (hp != NULL) {
+            const char     *hostname;
+
+            memmove((caddr_t) & to->sin6_addr, hp->h_addr, 16);
+            hostname = inet_ntop(AF_INET6, &to->sin6_addr, pa, 64);
+            StorageTmp->traceRouteResultsIpTgtAddrType = 2;
+            StorageTmp->traceRouteResultsIpTgtAddr =
+                (char *) malloc(sizeof(char) * (strlen(hostname) + 1));
+            if (StorageTmp->traceRouteResultsIpTgtAddr == NULL) {
+                DEBUGMSGTL(("traceRouteCtlTable",
+                            "traceRouteResultsIpTgtAddr malloc %s\n",
+                            strerror(errno)));
+                exit(1);
+            }
+            memset(StorageTmp->traceRouteResultsIpTgtAddr, '\0',
+                   sizeof(char) * (strlen(host) + 1));
+            memcpy(StorageTmp->traceRouteResultsIpTgtAddr, hostname,
+                   strlen(hostname) + 1);
+            StorageTmp->traceRouteResultsIpTgtAddr[strlen(hostname)] = '\0';
+            StorageTmp->traceRouteResultsIpTgtAddrLen = strlen(hostname);
+        } else {
+            DEBUGMSGTL(("traceRouteCtlTable",
+                        "traceroute: unknown host %s\n", host));
+
+            StorageTmp->traceRouteResultsIpTgtAddrType = 0;
+            StorageTmp->traceRouteResultsIpTgtAddr = strdup("");
+            StorageTmp->traceRouteResultsIpTgtAddrLen = 0;
+        }
+    }
+}
 
 void
 init_trResultsTable(struct traceRouteCtlTable_data *item)
@@ -203,106 +307,14 @@ init_trResultsTable(struct traceRouteCtlTable_data *item)
 
     StorageTmp->traceRouteResultsOperStatus = 1;
 
-    if (item->traceRouteCtlTargetAddressType == 1
-        || item->traceRouteCtlTargetAddressType == 16) {
-        struct sockaddr whereto;        /* Who to try to reach */
-        register struct sockaddr_in *to = (struct sockaddr_in *) &whereto;
-        register struct hostinfo *hi = NULL;
-        hi = gethostinfo(host);
-        if (hi == NULL) {
-            DEBUGMSGTL(("traceRouteCtlTable", "hi calloc %s\n",
-                        strerror(errno)));
-            exit(1);
-        }
-
-        setsin(to, hi->addrs[0]);
-        if (inet_ntoa(to->sin_addr) == NULL) {
-            StorageTmp->traceRouteResultsIpTgtAddrType = 0;
-            StorageTmp->traceRouteResultsIpTgtAddr = strdup("");
-            StorageTmp->traceRouteResultsIpTgtAddrLen = 0;
-        } else {
-            StorageTmp->traceRouteResultsIpTgtAddrType = 1;
-            StorageTmp->traceRouteResultsIpTgtAddr =
-                (char *) malloc(sizeof(char) *
-                                (strlen(inet_ntoa(to->sin_addr)) + 1));
-            if (StorageTmp->traceRouteResultsIpTgtAddr == NULL) {
-                DEBUGMSGTL(("traceRouteCtlTable",
-                            "traceRouteResultsIpTgtAddr malloc %s\n",
-                            strerror(errno)));
-                exit(1);
-            }
-
-            memcpy(StorageTmp->traceRouteResultsIpTgtAddr,
-                   inet_ntoa(to->sin_addr),
-                   strlen(inet_ntoa(to->sin_addr)) + 1);
-            StorageTmp->
-                traceRouteResultsIpTgtAddr[strlen(inet_ntoa(to->sin_addr))]
-                = '\0';
-            StorageTmp->traceRouteResultsIpTgtAddrLen =
-                strlen(inet_ntoa(to->sin_addr));
-        }
-    }
-    if (item->traceRouteCtlTargetAddressType == 2) {
-
-        struct sockaddr_in6 whereto;    /* Who to try to reach */
-        register struct sockaddr_in6 *to =
-            (struct sockaddr_in6 *) &whereto;
-        struct hostent *hp = NULL;
-        /* struct hostenv hp; */
-        char            pa[64];
-        memset(pa, '\0', 64);
-
-        to->sin6_family = AF_INET6;
-        to->sin6_port = htons(33434);
-
-        if (inet_pton(AF_INET6, host, &to->sin6_addr) > 0) {
-            StorageTmp->traceRouteResultsIpTgtAddrType = 2;
-            StorageTmp->traceRouteResultsIpTgtAddr =
-                (char *) malloc(sizeof(char) * (strlen(host) + 1));
-            if (StorageTmp->traceRouteResultsIpTgtAddr == NULL) {
-                DEBUGMSGTL(("traceRouteCtlTable",
-                            "traceRouteResultsIpTgtAddr malloc %s\n",
-                            strerror(errno)));
-                exit(1);
-            }
-            memset(StorageTmp->traceRouteResultsIpTgtAddr, '\0',
-                  sizeof(char) * (strlen(host) + 1));
-            memcpy(StorageTmp->traceRouteResultsIpTgtAddr, host,
-                   strlen(host) + 1);
-            StorageTmp->traceRouteResultsIpTgtAddr[strlen(host)] = '\0';
-            StorageTmp->traceRouteResultsIpTgtAddrLen = strlen(host);
-        } else {
-            hp = gethostbyname2(host, AF_INET6);
-            if (hp != NULL) {
-                const char     *hostname;
-                memmove((caddr_t) & to->sin6_addr, hp->h_addr, 16);
-                hostname = inet_ntop(AF_INET6, &to->sin6_addr, pa, 64);
-                StorageTmp->traceRouteResultsIpTgtAddrType = 2;
-                StorageTmp->traceRouteResultsIpTgtAddr =
-                    (char *) malloc(sizeof(char) * (strlen(hostname) + 1));
-                if (StorageTmp->traceRouteResultsIpTgtAddr == NULL) {
-                    DEBUGMSGTL(("traceRouteCtlTable",
-                                "traceRouteResultsIpTgtAddr malloc %s\n",
-                                strerror(errno)));
-                    exit(1);
-                }
-                memset(StorageTmp->traceRouteResultsIpTgtAddr, '\0',
-                      sizeof(char) * (strlen(host) + 1));
-                memcpy(StorageTmp->traceRouteResultsIpTgtAddr, hostname,
-                       strlen(hostname) + 1);
-                StorageTmp->traceRouteResultsIpTgtAddr[strlen(hostname)] =
-                    '\0';
-                StorageTmp->traceRouteResultsIpTgtAddrLen =
-                    strlen(hostname);
-            } else {
-                DEBUGMSGTL(("traceRouteCtlTable",
-                            "traceroute: unknown host %s\n", host));
-
-                StorageTmp->traceRouteResultsIpTgtAddrType = 0;
-                StorageTmp->traceRouteResultsIpTgtAddr = strdup("");
-                StorageTmp->traceRouteResultsIpTgtAddrLen = 0;
-            }
-        }
+    switch (item->traceRouteCtlTargetAddressType) {
+    case 1:
+    case 16:
+        init_trResultsTable_ipv4(host, StorageTmp);
+        break;
+    case 2:
+        init_trResultsTable_ipv6(host, StorageTmp);
+        break;
     }
 
     StorageTmp->traceRouteResultsCurHopCount = 0;
@@ -327,7 +339,7 @@ init_trResultsTable(struct traceRouteCtlTable_data *item)
                         "init an entry error\n"));
         }
     }
-
+    free(host);
 }
 
 
@@ -755,33 +767,25 @@ traceRouteProbeHistoryTable_delLast(struct traceRouteCtlTable_data
 void
 traceRouteCtlTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr = NULL;
-    struct traceRouteCtlTable_data *StorageDel = NULL;
+    struct header_complex_index *hciptr, *nhciptr;
+    struct traceRouteCtlTable_data *StorageDel;
+
     DEBUGMSGTL(("traceRouteCtlTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
+    for (hciptr = thestuff; hciptr; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
         StorageDel =
             header_complex_extract_entry(&traceRouteCtlTableStorage,
                                          hciptr);
         if (StorageDel != NULL) {
             free(StorageDel->traceRouteCtlOwnerIndex);
-            StorageDel->traceRouteCtlOwnerIndex = NULL;
             free(StorageDel->traceRouteCtlTestName);
-            StorageDel->traceRouteCtlTestName = NULL;
             free(StorageDel->traceRouteCtlTargetAddress);
-            StorageDel->traceRouteCtlTargetAddress = NULL;
             free(StorageDel->traceRouteCtlSourceAddress);
-            StorageDel->traceRouteCtlSourceAddress = NULL;
             free(StorageDel->traceRouteCtlMiscOptions);
-            StorageDel->traceRouteCtlMiscOptions = NULL;
             free(StorageDel->traceRouteCtlDescr);
-            StorageDel->traceRouteCtlDescr = NULL;
             free(StorageDel->traceRouteCtlTrapGeneration);
-            StorageDel->traceRouteCtlTrapGeneration = NULL;
             free(StorageDel->traceRouteCtlType);
-            StorageDel->traceRouteCtlType = NULL;
             free(StorageDel);
-            StorageDel = NULL;
-
         }
         DEBUGMSGTL(("traceRouteCtlTable", "cleaner  "));
     }
@@ -814,6 +818,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlOwnerIndexLen);
     if (StorageTmp->traceRouteCtlOwnerIndex == NULL) {
         config_perror("invalid specification for traceRouteCtlOwnerIndex");
+        free(StorageTmp);
         return;
     }
 
@@ -823,6 +828,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlTestNameLen);
     if (StorageTmp->traceRouteCtlTestName == NULL) {
         config_perror("invalid specification for traceRouteCtlTestName");
+        free(StorageTmp);
         return;
     }
 
@@ -838,6 +844,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
     if (StorageTmp->traceRouteCtlTargetAddress == NULL) {
         config_perror
             ("invalid specification for traceRouteCtlTargetAddress");
+        free(StorageTmp);
         return;
     }
 
@@ -882,6 +889,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
     if (StorageTmp->traceRouteCtlSourceAddress == NULL) {
         config_perror
             ("invalid specification for traceRouteCtlSourceAddress");
+        free(StorageTmp);
         return;
     }
 
@@ -896,6 +904,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
     if (StorageTmp->traceRouteCtlMiscOptions == NULL) {
         config_perror
             ("invalid specification for traceRouteCtlMiscOptions");
+        free(StorageTmp);
         return;
     }
 
@@ -935,6 +944,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlDescrLen);
     if (StorageTmp->traceRouteCtlDescr == NULL) {
         config_perror("invalid specification for traceRouteCtlTrapDescr");
+        free(StorageTmp);
         return;
     }
 
@@ -949,6 +959,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
     if (StorageTmp->traceRouteCtlTrapGeneration == NULL) {
         config_perror
             ("invalid specification for traceRouteCtlTrapGeneration");
+        free(StorageTmp);
         return;
     }
 
@@ -963,6 +974,7 @@ parse_traceRouteCtlTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlTypeLen);
     if (StorageTmp->traceRouteCtlType == NULL) {
         config_perror("invalid specification for traceRouteCtlType");
+        free(StorageTmp);
         return;
     }
 
@@ -1349,7 +1361,7 @@ var_traceRouteCtlTable(struct variable *vp,
 int
 traceRouteResultsTable_del(struct traceRouteCtlTable_data *thedata)
 {
-    struct header_complex_index *hciptr2 = NULL;
+    struct header_complex_index *hciptr2, *nhciptr2;
     netsnmp_variable_list *vars = NULL;
     oid             newoid[MAX_OID_LEN];
     size_t          newoid_len = 0;
@@ -1360,8 +1372,8 @@ traceRouteResultsTable_del(struct traceRouteCtlTable_data *thedata)
     memset(newoid, '\0', sizeof(oid) * MAX_OID_LEN);
     header_complex_generate_oid(newoid, &newoid_len, NULL, 0, vars);
 
-    for (hciptr2 = traceRouteResultsTableStorage; hciptr2 != NULL;
-         hciptr2 = hciptr2->next) {
+    for (hciptr2 = traceRouteResultsTableStorage; hciptr2; hciptr2 = nhciptr2) {
+        nhciptr2 = hciptr2->next;
         if (snmp_oid_compare(newoid, newoid_len, hciptr2->name, newoid_len)
             == 0) {
             header_complex_extract_entry(&traceRouteResultsTableStorage,
@@ -1380,7 +1392,7 @@ traceRouteResultsTable_del(struct traceRouteCtlTable_data *thedata)
 int
 traceRouteProbeHistoryTable_del(struct traceRouteCtlTable_data *thedata)
 {
-    struct header_complex_index *hciptr2 = NULL;
+    struct header_complex_index *hciptr2, *nhciptr2;
     netsnmp_variable_list *vars = NULL;
     oid             newoid[MAX_OID_LEN];
     size_t          newoid_len = 0;
@@ -1392,8 +1404,9 @@ traceRouteProbeHistoryTable_del(struct traceRouteCtlTable_data *thedata)
 
     header_complex_generate_oid(newoid, &newoid_len, NULL, 0, vars);
 
-    for (hciptr2 = traceRouteProbeHistoryTableStorage; hciptr2 != NULL;
-         hciptr2 = hciptr2->next) {
+    for (hciptr2 = traceRouteProbeHistoryTableStorage; hciptr2;
+         hciptr2 = nhciptr2) {
+        nhciptr2 = hciptr2->next;
         if (snmp_oid_compare(newoid, newoid_len, hciptr2->name, newoid_len)
             == 0) {
             header_complex_extract_entry(&traceRouteProbeHistoryTableStorage,
@@ -1411,7 +1424,7 @@ traceRouteProbeHistoryTable_del(struct traceRouteCtlTable_data *thedata)
 int
 traceRouteHopsTable_del(struct traceRouteCtlTable_data *thedata)
 {
-    struct header_complex_index *hciptr2 = NULL;
+    struct header_complex_index *hciptr2, *nhciptr2;
     netsnmp_variable_list *vars = NULL;
     oid             newoid[MAX_OID_LEN];
     size_t          newoid_len = 0;
@@ -1423,13 +1436,12 @@ traceRouteHopsTable_del(struct traceRouteCtlTable_data *thedata)
 
     header_complex_generate_oid(newoid, &newoid_len, NULL, 0, vars);
 
-    for (hciptr2 = traceRouteHopsTableStorage; hciptr2 != NULL;
-         hciptr2 = hciptr2->next) {
+    for (hciptr2 = traceRouteHopsTableStorage; hciptr2; hciptr2 = nhciptr2) {
+        nhciptr2 = hciptr2->next;
         if (snmp_oid_compare(newoid, newoid_len, hciptr2->name, newoid_len)
             == 0) {
             header_complex_extract_entry(&traceRouteHopsTableStorage, hciptr2);
             DEBUGMSGTL(("traceRouteHopsTable", "delete  success!\n"));
-
         }
     }
     vars = NULL;
@@ -4042,1545 +4054,1576 @@ write_traceRouteCtlRowStatus(int action,
 }
 
 
-void
-run_traceRoute(unsigned int clientreg, void *clientarg)
+static void
+run_traceRoute_ipv4(struct traceRouteCtlTable_data *item)
 {
-    struct traceRouteCtlTable_data *item = clientarg;
-    u_short         port = item->traceRouteCtlPort;     /* start udp dest port # for probe packets Ïàµ±ÓÚctlport */
-    int             waittime = item->traceRouteCtlTimeOut;      /* time to wait for response (in seconds) ÏàµÈÓÚctltimeout */
+    u_short         port = item->traceRouteCtlPort;     /* start udp dest port # for probe packets */
+    int             waittime = item->traceRouteCtlTimeOut;      /* time to wait for response (in seconds) */
     int             nprobes = item->traceRouteCtlProbesPerHop;
-
-    if (item->traceRouteCtlInitialTtl > item->traceRouteCtlMaxTtl) {
-        DEBUGMSGTL(("traceRouteCtlTable",
-                    "first ttl (%lu) may not be greater than max ttl (%lu)\n",
-                    item->traceRouteCtlInitialTtl,
-                    item->traceRouteCtlMaxTtl));
-        return;
-    }
-
     char           *old_HopsAddress[255];
     int             count = 0;
     int             flag = 0;
 
-    if (item->traceRouteCtlTargetAddressType == 1
-        || item->traceRouteCtlTargetAddressType == 16) {
-        register int    code, n;
-        const    char  *cp;
-        register const char *err;
-        register u_char *outp;
-        register u_int32_t *ap;
-        struct sockaddr whereto;        /* Who to try to reach */
-        struct sockaddr wherefrom;      /* Who we are */
-
-        register struct sockaddr_in *from =
-            (struct sockaddr_in *) &wherefrom;
-        register struct sockaddr_in *to = (struct sockaddr_in *) &whereto;
-        register struct hostinfo *hi;
-        int             on = 1;
-        register struct protoent *pe;
-        register int    ttl, probe, i;
-        register int    seq = 0;
-        int             tos = 0, settos = 0;
-        register int    lsrr = 0;
-        register u_short off = 0;
-        struct ifaddrlist *al;
-        char            errbuf[132];
-        int             minpacket = 0;  /* min ip packet size */
-
-
-        struct ip      *outip;  /* last output (udp) packet */
-        struct udphdr  *outudp; /* last output (udp) packet */
-        int             packlen = 0;    /* total length of packet */
-        int             optlen = 0;     /* length of ip options */
-        int             options = 0;    /* socket options */
-        int             s;      /* receive (icmp) socket file descriptor */
-        int             sndsock;        /* send (udp/icmp) socket file descriptor */
-
-        u_short         ident;
-        /*
-         * loose source route gateway list (including room for final destination) 
-         */
-        u_int32_t       gwlist[NGATEWAYS + 1];
-        static const char devnull[] = "/dev/null";
-        char           *device = NULL;
-        char           *source = NULL;
-        char           *hostname;
-        u_int           pausemsecs = 0;
-        u_char          packet[512];    /* last inbound (icmp) packet */
-
-        int             pmtu = 0;       /* Path MTU Discovery (RFC1191) */
-
-        struct outdata *outdata;        /* last output (udp) packet */
-
-        minpacket = sizeof(*outip) + sizeof(*outdata) + optlen;
-        minpacket += sizeof(*outudp);
-        packlen = minpacket;    /* minimum sized packet */
-
-        hostname =
-            (char *) malloc(item->traceRouteCtlTargetAddressLen + 1);
-        if (hostname == NULL)
-            return;
-        memcpy(hostname, item->traceRouteCtlTargetAddress,
-               item->traceRouteCtlTargetAddressLen + 1);
-        hostname[item->traceRouteCtlTargetAddressLen] = '\0';
-
-        hi = gethostinfo(hostname);
-        setsin(to, hi->addrs[0]);
-        if (hi->n > 1)
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "Warning: %s has multiple addresses; using %s\n",
-                        hostname, inet_ntoa(to->sin_addr)));
-        hostname = hi->name;
-        hi->name = NULL;
-        freehostinfo(hi);
+    int    code, n, k;
+    const    char  *cp;
+    const char *err;
+    u_char *outp;
+    u_int32_t *ap;
+    struct sockaddr whereto;        /* Who to try to reach */
+    struct sockaddr wherefrom;      /* Who we are */
+
+    struct sockaddr_in *from = (struct sockaddr_in *) &wherefrom;
+    struct sockaddr_in *to = (struct sockaddr_in *) &whereto;
+    struct hostinfo *hi;
+    int             on = 1;
+    struct protoent *pe;
+    int    ttl, probe, i;
+    int    seq = 0;
+    int             tos = 0, settos = 0;
+    int    lsrr = 0;
+    u_short off = 0;
+    struct ifaddrlist *al;
+    char            errbuf[132];
+    int             minpacket = 0;  /* min ip packet size */
 
 
-        netsnmp_set_line_buffering(stdout);
+    struct ip      *outip = NULL;   /* last output (udp) packet */
+    struct udphdr  *outudp;         /* last output (udp) packet */
+    int             packlen = 0;    /* total length of packet */
+    int             optlen = 0;     /* length of ip options */
+    int             options = 0;    /* socket options */
+    int             s = -1;         /* receive (icmp) socket file descriptor */
+    int             sndsock = -1;   /* send (udp/icmp) socket file descriptor */
+    int             fd[3] = { -1, -1, -1 };
 
-        outip = (struct ip *) malloc(packlen);
-        if (outip == NULL) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "malloc: %s\n", strerror(errno)));
-            exit(1);
-        }
-        memset((char *) outip, 0, packlen);
+    u_short         ident;
+    /*
+     * loose source route gateway list (including room for final destination) 
+     */
+    u_int32_t       gwlist[NGATEWAYS + 1];
+    static const char devnull[] = "/dev/null";
+    char           *device = NULL;
+    char           *source = NULL;
+    char           *hostname;
+    u_int           pausemsecs = 0;
+    u_char          packet[512];    /* last inbound (icmp) packet */
+
+    int             pmtu = 0;       /* Path MTU Discovery (RFC1191) */
+
+    struct outdata *outdata;        /* last output (udp) packet */
+
+    minpacket = sizeof(*outip) + sizeof(*outdata) + optlen;
+    minpacket += sizeof(*outudp);
+    packlen = minpacket;    /* minimum sized packet */
+
+    hostname = malloc(item->traceRouteCtlTargetAddressLen + 1);
+    if (hostname == NULL)
+        goto out;
+    memcpy(hostname, item->traceRouteCtlTargetAddress,
+           item->traceRouteCtlTargetAddressLen + 1);
+    hostname[item->traceRouteCtlTargetAddressLen] = '\0';
+
+    hi = gethostinfo(hostname);
+    setsin(to, hi->addrs[0]);
+    if (hi->n > 1)
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "Warning: %s has multiple addresses; using %s\n",
+                    hostname, inet_ntoa(to->sin_addr)));
+    free(hostname);
+    hostname = strdup(hi->name);
+    freehostinfo(hi);
+
+
+    netsnmp_set_line_buffering(stdout);
 
-        outip->ip_v = IPVERSION;
-        if (settos)
-            outip->ip_tos = tos;
+    outip = (struct ip *) malloc(packlen);
+    if (outip == NULL) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "malloc: %s\n", strerror(errno)));
+        exit(1);
+    }
+    memset((char *) outip, 0, packlen);
+
+    outip->ip_v = IPVERSION;
+    if (settos)
+        outip->ip_tos = tos;
 #ifdef BYTESWAP_IP_HDR
-        outip->ip_len = htons(packlen);
-        outip->ip_off = htons(off);
+    outip->ip_len = htons(packlen);
+    outip->ip_off = htons(off);
 #else
-        outip->ip_len = packlen;
-        outip->ip_off = off;
+    outip->ip_len = packlen;
+    outip->ip_off = off;
 #endif
-        outp = (u_char *) (outip + 1);
+    outp = (u_char *) (outip + 1);
 #ifdef HAVE_RAW_OPTIONS
-        if (lsrr > 0) {
-            register u_char *optlist;
+    if (lsrr > 0) {
+        u_char *optlist;
 
-            optlist = outp;
-            outp += optlen;
+        optlist = outp;
+        outp += optlen;
 
-            /*
-             * final hop 
-             */
-            gwlist[lsrr] = to->sin_addr.s_addr;
+        /*
+         * final hop 
+         */
+        gwlist[lsrr] = to->sin_addr.s_addr;
 
-            outip->ip_dst.s_addr = gwlist[0];
+        outip->ip_dst.s_addr = gwlist[0];
 
-            /*
-             * force 4 byte alignment 
-             */
-            optlist[0] = IPOPT_NOP;
-            /*
-             * loose source route option 
-             */
-            optlist[1] = IPOPT_LSRR;
-            i = lsrr * sizeof(gwlist[0]);
-            optlist[2] = i + 3;
-            /*
-             * Pointer to LSRR addresses 
-             */
-            optlist[3] = IPOPT_MINOFF;
-            memcpy(optlist + 4, gwlist + 1, i);
-        } else
+        /*
+         * force 4 byte alignment 
+         */
+        optlist[0] = IPOPT_NOP;
+        /*
+         * loose source route option 
+         */
+        optlist[1] = IPOPT_LSRR;
+        i = lsrr * sizeof(gwlist[0]);
+        optlist[2] = i + 3;
+        /*
+         * Pointer to LSRR addresses 
+         */
+        optlist[3] = IPOPT_MINOFF;
+        memcpy(optlist + 4, gwlist + 1, i);
+    } else
 #endif
-            outip->ip_dst = to->sin_addr;
-        outip->ip_hl = (outp - (u_char *) outip) >> 2;
-        ident = (getpid() & 0xffff) | 0x8000;
+        outip->ip_dst = to->sin_addr;
+    outip->ip_hl = (outp - (u_char *) outip) >> 2;
+    ident = (getpid() & 0xffff) | 0x8000;
 
-        outip->ip_p = IPPROTO_UDP;
+    outip->ip_p = IPPROTO_UDP;
 
-        outudp = (struct udphdr *) outp;
-        outudp->source = htons(ident);
-        outudp->len =
-            htons((u_short) (packlen - (sizeof(*outip) + optlen)));
-        outdata = (struct outdata *) (outudp + 1);
+    outudp = (struct udphdr *) outp;
+    outudp->source = htons(ident);
+    outudp->len =
+        htons((u_short) (packlen - (sizeof(*outip) + optlen)));
+    outdata = (struct outdata *) (outudp + 1);
 
-        cp = "icmp";
-        if ((pe = getprotobyname(cp)) == NULL) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "unknown protocol %s\n", cp));
-            exit(1);
-        }
+    cp = "icmp";
+    if ((pe = getprotobyname(cp)) == NULL) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "unknown protocol %s\n", cp));
+        exit(1);
+    }
 
-        /*
-         * Insure the socket fds won't be 0, 1 or 2 
-         */
-        if (open(devnull, O_RDONLY) < 0 ||
-            open(devnull, O_RDONLY) < 0 || open(devnull, O_RDONLY) < 0) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "open \"%s\": %s\n", devnull, strerror(errno)));
-            exit(1);
-        }
-        if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "icmp socket: %s\n", strerror(errno)));
-            exit(1);
-        }
-        if (options & SO_DEBUG)
-            (void) setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *) &on,
-                              sizeof(on));
-        if (options & SO_DONTROUTE)
-            (void) setsockopt(s, SOL_SOCKET, SO_DONTROUTE, (char *) &on,
-                              sizeof(on));
+    /*
+     * Insure the socket fds won't be 0, 1 or 2 
+     */
+    if ((fd[0] = open(devnull, O_RDONLY)) < 0 ||
+        (fd[1] = open(devnull, O_RDONLY)) < 0 ||
+        (fd[2] = open(devnull, O_RDONLY)) < 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "open \"%s\": %s\n", devnull, strerror(errno)));
+        exit(1);
+    }
+    if ((s = socket(AF_INET, SOCK_RAW, pe->p_proto)) < 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "icmp socket: %s\n", strerror(errno)));
+        exit(1);
+    }
+    if (options & SO_DEBUG)
+        (void) setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *) &on,
+                          sizeof(on));
+    if (options & SO_DONTROUTE)
+        (void) setsockopt(s, SOL_SOCKET, SO_DONTROUTE, (char *) &on,
+                          sizeof(on));
 #ifndef __hpux
-        printf("raw\n");
-        sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+    printf("raw\n");
+    sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
 #else
-        printf("udp\n");
-        sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
+    printf("udp\n");
+    sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
 #endif
-        if (sndsock < 0) {
+    if (sndsock < 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "raw socket: %s\n", strerror(errno)));
+        exit(1);
+    }
+#if defined(IP_OPTIONS) && !defined(HAVE_RAW_OPTIONS)
+    if (lsrr > 0) {
+        u_char          optlist[MAX_IPOPTLEN];
+
+        cp = "ip";
+        if ((pe = getprotobyname(cp)) == NULL) {
             DEBUGMSGTL(("traceRouteCtlTable",
-                        "raw socket: %s\n", strerror(errno)));
+                        "unknown protocol %s\n", cp));
             exit(1);
         }
-#if defined(IP_OPTIONS) && !defined(HAVE_RAW_OPTIONS)
-        if (lsrr > 0) {
-            u_char          optlist[MAX_IPOPTLEN];
-
-            cp = "ip";
-            if ((pe = getprotobyname(cp)) == NULL) {
-                DEBUGMSGTL(("traceRouteCtlTable",
-                            "unknown protocol %s\n", cp));
-                exit(1);
-            }
-            /*
-             * final hop 
-             */
-            gwlist[lsrr] = to->sin_addr.s_addr;
-            ++lsrr;
+        /*
+         * final hop 
+         */
+        gwlist[lsrr] = to->sin_addr.s_addr;
+        ++lsrr;
 
-            /*
-             * force 4 byte alignment 
-             */
-            optlist[0] = IPOPT_NOP;
-            /*
-             * loose source route option 
-             */
-            optlist[1] = IPOPT_LSRR;
-            i = lsrr * sizeof(gwlist[0]);
-            optlist[2] = i + 3;
-            /*
-             * Pointer to LSRR addresses 
-             */
-            optlist[3] = IPOPT_MINOFF;
-            memcpy(optlist + 4, gwlist, i);
+        /*
+         * force 4 byte alignment 
+         */
+        optlist[0] = IPOPT_NOP;
+        /*
+         * loose source route option 
+         */
+        optlist[1] = IPOPT_LSRR;
+        i = lsrr * sizeof(gwlist[0]);
+        optlist[2] = i + 3;
+        /*
+         * Pointer to LSRR addresses 
+         */
+        optlist[3] = IPOPT_MINOFF;
+        memcpy(optlist + 4, gwlist, i);
 
-            if ((setsockopt(sndsock, pe->p_proto, IP_OPTIONS,
-                            (char *) optlist,
-                            i + sizeof(gwlist[0]))) < 0) {
-                DEBUGMSGTL(("traceRouteCtlTable", "IP_OPTIONS: %s\n",
-                            strerror(errno)));
-                exit(1);
-            }
+        if ((setsockopt(sndsock, pe->p_proto, IP_OPTIONS,
+                        (char *) optlist,
+                        i + sizeof(gwlist[0]))) < 0) {
+            DEBUGMSGTL(("traceRouteCtlTable", "IP_OPTIONS: %s\n",
+                        strerror(errno)));
+            exit(1);
         }
+    }
 #endif
 #ifdef SO_SNDBUF
-        if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *) &packlen,
-                       sizeof(packlen)) < 0) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "SO_SNDBUF: %s\n", strerror(errno)));
-            exit(1);
-        }
+    if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *) &packlen,
+                   sizeof(packlen)) < 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "SO_SNDBUF: %s\n", strerror(errno)));
+        exit(1);
+    }
 #endif
 #ifdef IP_HDRINCL
-        if (setsockopt(sndsock, IPPROTO_IP, IP_HDRINCL, (char *) &on,
-                       sizeof(on)) < 0) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "IP_HDRINCL: %s\n", strerror(errno)));
-            exit(1);
-        }
+    if (setsockopt(sndsock, IPPROTO_IP, IP_HDRINCL, (char *) &on,
+                   sizeof(on)) < 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "IP_HDRINCL: %s\n", strerror(errno)));
+        exit(1);
+    }
 #else
 #ifdef IP_TOS
-        if (settos && setsockopt(sndsock, IPPROTO_IP, IP_TOS,
-                                 (char *) &tos, sizeof(tos)) < 0) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        "setsockopt tos %d: %s\n", strerror(errno)));
-            exit(1);
-        }
+    if (settos && setsockopt(sndsock, IPPROTO_IP, IP_TOS,
+                             (char *) &tos, sizeof(tos)) < 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "setsockopt tos %d: %s\n", strerror(errno)));
+        exit(1);
+    }
 #endif
 #endif
-        if (options & SO_DEBUG)
-            (void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG, (char *) &on,
-                              sizeof(on));
-        if (options & SO_DONTROUTE)
-            (void) setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE,
-                              (char *) &on, sizeof(on));
-        /*
-         * Get the interface address list 
-         */
-        n = ifaddrlist(&al, errbuf);
-        if (n < 0) {
+    if (options & SO_DEBUG)
+        (void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG, (char *) &on,
+                          sizeof(on));
+    if (options & SO_DONTROUTE)
+        (void) setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE,
+                          (char *) &on, sizeof(on));
+    /*
+     * Get the interface address list 
+     */
+    n = ifaddrlist(&al, errbuf);
+    if (n < 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    " ifaddrlist: %s\n", errbuf));
+        exit(1);
+    }
+    if (n == 0) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    " Can't find any network interfaces\n"));
+
+        exit(1);
+    }
+
+    /*
+     * Look for a specific device 
+     */
+    if (device != NULL) {
+        for (i = n; i > 0; --i, ++al)
+            if (strcmp(device, al->device) == 0)
+                break;
+        if (i <= 0) {
             DEBUGMSGTL(("traceRouteCtlTable",
-                        " ifaddrlist: %s\n", errbuf));
+                        " Can't find interface %.32s\n", device));
+
             exit(1);
         }
-        if (n == 0) {
+    }
+    /*
+     * Determine our source address 
+     */
+    if (source == NULL) {
+        /*
+         * If a device was specified, use the interface address.
+         * Otherwise, try to determine our source address.
+         */
+        if (device != NULL)
+            setsin(from, al->addr);
+        else if ((err = findsaddr(to, from)) != NULL) {
             DEBUGMSGTL(("traceRouteCtlTable",
-                        " Can't find any network interfaces\n"));
-
+                        " findsaddr: %s\n", err));
             exit(1);
         }
 
+    } else {
+        hi = gethostinfo(source);
+        source = hi->name;
+        hi->name = NULL;
         /*
-         * Look for a specific device 
+         * If the device was specified make sure it
+         * corresponds to the source address specified.
+         * Otherwise, use the first address (and warn if
+         * there are more than one).
          */
         if (device != NULL) {
-            for (i = n; i > 0; --i, ++al)
-                if (strcmp(device, al->device) == 0)
+            for (i = hi->n, ap = hi->addrs; i > 0; --i, ++ap)
+                if (*ap == al->addr)
                     break;
             if (i <= 0) {
                 DEBUGMSGTL(("traceRouteCtlTable",
-                            " Can't find interface %.32s\n", device));
+                            " %s is not on interface %.32s\n",
+                            source, device));
 
                 exit(1);
             }
-        }
-        /*
-         * Determine our source address 
-         */
-        if (source == NULL) {
-            /*
-             * If a device was specified, use the interface address.
-             * Otherwise, try to determine our source address.
-             */
-            if (device != NULL)
-                setsin(from, al->addr);
-            else if ((err = findsaddr(to, from)) != NULL) {
+            setsin(from, *ap);
+        } else {
+            setsin(from, hi->addrs[0]);
+            if (hi->n > 1)
                 DEBUGMSGTL(("traceRouteCtlTable",
-                            " findsaddr: %s\n", err));
-                exit(1);
-            }
-
-        } else {
-            hi = gethostinfo(source);
-            source = hi->name;
-            hi->name = NULL;
-            /*
-             * If the device was specified make sure it
-             * corresponds to the source address specified.
-             * Otherwise, use the first address (and warn if
-             * there are more than one).
-             */
-            if (device != NULL) {
-                for (i = hi->n, ap = hi->addrs; i > 0; --i, ++ap)
-                    if (*ap == al->addr)
-                        break;
-                if (i <= 0) {
-                    DEBUGMSGTL(("traceRouteCtlTable",
-                                " %s is not on interface %.32s\n",
-                                source, device));
-
-                    exit(1);
-                }
-                setsin(from, *ap);
-            } else {
-                setsin(from, hi->addrs[0]);
-                if (hi->n > 1)
-                    DEBUGMSGTL(("traceRouteCtlTable",
-                                " Warning: %s has multiple addresses; using %s\n",
-                                source, inet_ntoa(from->sin_addr)));
+                            " Warning: %s has multiple addresses; using %s\n",
+                            source, inet_ntoa(from->sin_addr)));
 
-            }
-            freehostinfo(hi);
         }
-        /*
-         * Revert to non-privileged user after opening sockets 
-         */
-        setgid(getgid());
-        setuid(getuid());
+        freehostinfo(hi);
+    }
+    /*
+     * Revert to non-privileged user after opening sockets 
+     */
+    setgid(getgid());
+    setuid(getuid());
 
-        outip->ip_src = from->sin_addr;
+    outip->ip_src = from->sin_addr;
 #ifndef IP_HDRINCL
-        if (bind(sndsock, (struct sockaddr *) from, sizeof(*from)) < 0) {
-            DEBUGMSGTL(("traceRouteCtlTable",
-                        " bind: %s\n", strerror(errno)));
-            exit(1);
-        }
-#endif
+    if (bind(sndsock, (struct sockaddr *) from, sizeof(*from)) < 0) {
         DEBUGMSGTL(("traceRouteCtlTable",
-                    " to %s (%s)", hostname, inet_ntoa(to->sin_addr)));
-
-        if (source)
-            DEBUGMSGTL(("traceRouteCtlTable", " from %s", source));
-
-        DEBUGMSGTL(("traceRouteCtlTable",
-                    ", %lu hops max, %d byte packets\n",
-                    item->traceRouteCtlMaxTtl, packlen));
-        (void) fflush(stderr);
-
-        struct traceRouteResultsTable_data *StorageResults = NULL;
-        netsnmp_variable_list *vars_results = NULL;
-
-        struct traceRouteHopsTable_data *temp = NULL;
-        struct traceRouteHopsTable_data *current_temp = NULL;
-        struct traceRouteHopsTable_data *current = NULL;
+                    " bind: %s\n", strerror(errno)));
+        exit(1);
+    }
+#endif
+    DEBUGMSGTL(("traceRouteCtlTable",
+                " to %s (%s)", hostname, inet_ntoa(to->sin_addr)));
 
-        unsigned long   index = 0;
+    if (source)
+        DEBUGMSGTL(("traceRouteCtlTable", " from %s", source));
 
-        struct traceRouteProbeHistoryTable_data *temp_his = NULL;
-        struct traceRouteProbeHistoryTable_data *current_temp_his = NULL;
+    DEBUGMSGTL(("traceRouteCtlTable",
+                ", %lu hops max, %d byte packets\n",
+                item->traceRouteCtlMaxTtl, packlen));
+    (void) fflush(stderr);
 
-        snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);     /*  traceRouteCtlOwnerIndex  */
-        snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen); /*  traceRouteCtlTestName  */
-        if ((StorageResults =
-             header_complex_get(traceRouteResultsTableStorage,
-                                vars_results)) == NULL)
-            return;
-        snmp_free_varbind(vars_results);
-        vars_results = NULL;
+    struct traceRouteResultsTable_data *StorageResults = NULL;
+    netsnmp_variable_list *vars_results = NULL;
 
+    struct traceRouteHopsTable_data *temp = NULL;
+    struct traceRouteHopsTable_data *current_temp = NULL;
+    struct traceRouteHopsTable_data *current = NULL;
 
-        for (ttl = item->traceRouteCtlInitialTtl;
-             ttl <= item->traceRouteCtlMaxTtl; ++ttl) {
+    unsigned long   index = 0;
 
-            u_int32_t       lastaddr = 0;
-            int             gotlastaddr = 0;
-            int             got_there = 0;
-            int             unreachable = 0;
-            int             sentfirst = 0;
-            time_t          timep = 0;
+    struct traceRouteProbeHistoryTable_data *temp_his = NULL;
+    struct traceRouteProbeHistoryTable_data *current_temp_his = NULL;
 
-            StorageResults->traceRouteResultsCurHopCount = ttl;
-            if (item->traceRouteCtlCreateHopsEntries == 1) {
-                if (ttl == item->traceRouteCtlInitialTtl) {
-                    int             k = 0;
-                    count = traceRouteHopsTable_count(item);
-
-
-                    struct traceRouteHopsTable_data *StorageTmp = NULL;
-                    struct header_complex_index *hciptr2 = NULL;
-                    netsnmp_variable_list *vars = NULL;
-                    oid             newoid[MAX_OID_LEN];
-                    size_t          newoid_len;
-
-                    snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen); /* traceRouteCtlOwnerIndex */
-                    snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);     /* traceRouteCtlTestName */
-
-                    header_complex_generate_oid(newoid, &newoid_len, NULL,
-                                                0, vars);
-
-                    for (hciptr2 = traceRouteHopsTableStorage;
-                         hciptr2 != NULL; hciptr2 = hciptr2->next) {
-                        if (snmp_oid_compare
-                            (newoid, newoid_len, hciptr2->name,
-                             newoid_len) == 0) {
-                            StorageTmp =
-                                header_complex_extract_entry
-                                (&traceRouteHopsTableStorage, hciptr2);
-
-                            old_HopsAddress[k] =
-                                (char *) malloc(StorageTmp->
-                                                traceRouteHopsIpTgtAddressLen
-                                                + 1);
-                            if (old_HopsAddress[k] == NULL) {
-                                exit(1);
-                            }
-                            old_HopsAddress[k] = netsnmp_memdup(
-                                   StorageTmp->traceRouteHopsIpTgtAddress,
-                                   StorageTmp->
-                                   traceRouteHopsIpTgtAddressLen + 1);
-                            old_HopsAddress[k][StorageTmp->
-                                               traceRouteHopsIpTgtAddressLen]
-                                = '\0';
-
-                            k++;
-                            StorageTmp = NULL;
+    snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);     /*  traceRouteCtlOwnerIndex  */
+    snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen); /*  traceRouteCtlTestName  */
+    if ((StorageResults =
+         header_complex_get(traceRouteResultsTableStorage,
+                            vars_results)) == NULL) {
+        goto out;
+    }
+    snmp_free_varbind(vars_results);
+    vars_results = NULL;
+
+
+    for (ttl = item->traceRouteCtlInitialTtl;
+         ttl <= item->traceRouteCtlMaxTtl; ++ttl) {
+
+        u_int32_t       lastaddr = 0;
+        int             gotlastaddr = 0;
+        int             got_there = 0;
+        int             unreachable = 0;
+        int             sentfirst = 0;
+        time_t          timep = 0;
+
+        StorageResults->traceRouteResultsCurHopCount = ttl;
+        if (item->traceRouteCtlCreateHopsEntries == 1) {
+            if (ttl == item->traceRouteCtlInitialTtl) {
+                int             k = 0;
+                count = traceRouteHopsTable_count(item);
+
+
+                struct traceRouteHopsTable_data *StorageTmp = NULL;
+                struct header_complex_index *hciptr2, *nhciptr2;
+                netsnmp_variable_list *vars = NULL;
+                oid             newoid[MAX_OID_LEN];
+                size_t          newoid_len;
+
+                snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen); /* traceRouteCtlOwnerIndex */
+                snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);     /* traceRouteCtlTestName */
+
+                header_complex_generate_oid(newoid, &newoid_len, NULL,
+                                            0, vars);
+
+                for (hciptr2 = traceRouteHopsTableStorage; hciptr2;
+                     hciptr2 = nhciptr2) {
+                    nhciptr2 = hciptr2->next;
+                    if (snmp_oid_compare
+                        (newoid, newoid_len, hciptr2->name,
+                         newoid_len) == 0) {
+                        StorageTmp =
+                            header_complex_extract_entry
+                            (&traceRouteHopsTableStorage, hciptr2);
+
+                        old_HopsAddress[k] =
+                            (char *) malloc(StorageTmp->
+                                            traceRouteHopsIpTgtAddressLen
+                                            + 1);
+                        if (old_HopsAddress[k] == NULL) {
+                            exit(1);
                         }
+                        old_HopsAddress[k] = netsnmp_memdup(
+                                                            StorageTmp->traceRouteHopsIpTgtAddress,
+                                                            StorageTmp->
+                                                            traceRouteHopsIpTgtAddressLen + 1);
+                        old_HopsAddress[k][StorageTmp->
+                                           traceRouteHopsIpTgtAddressLen]
+                            = '\0';
+
+                        k++;
+                        StorageTmp = NULL;
                     }
-                    traceRouteHopsTable_del(item);
-                    index = 0;
                 }
+                traceRouteHopsTable_del(item);
+                index = 0;
+            }
 
-                temp = SNMP_MALLOC_STRUCT(traceRouteHopsTable_data);
-                temp->traceRouteCtlOwnerIndex =
-                    (char *) malloc(item->traceRouteCtlOwnerIndexLen + 1);
-                memcpy(temp->traceRouteCtlOwnerIndex,
-                       item->traceRouteCtlOwnerIndex,
-                       item->traceRouteCtlOwnerIndexLen + 1);
-                temp->traceRouteCtlOwnerIndex[item->
-                                              traceRouteCtlOwnerIndexLen] =
-                    '\0';
-                temp->traceRouteCtlOwnerIndexLen =
-                    item->traceRouteCtlOwnerIndexLen;
+            temp = SNMP_MALLOC_STRUCT(traceRouteHopsTable_data);
+            temp->traceRouteCtlOwnerIndex =
+                (char *) malloc(item->traceRouteCtlOwnerIndexLen + 1);
+            memcpy(temp->traceRouteCtlOwnerIndex,
+                   item->traceRouteCtlOwnerIndex,
+                   item->traceRouteCtlOwnerIndexLen + 1);
+            temp->traceRouteCtlOwnerIndex[item->
+                                          traceRouteCtlOwnerIndexLen] =
+                '\0';
+            temp->traceRouteCtlOwnerIndexLen =
+                item->traceRouteCtlOwnerIndexLen;
+
+            temp->traceRouteCtlTestName =
+                (char *) malloc(item->traceRouteCtlTestNameLen + 1);
+            memcpy(temp->traceRouteCtlTestName,
+                   item->traceRouteCtlTestName,
+                   item->traceRouteCtlTestNameLen + 1);
+            temp->traceRouteCtlTestName[item->
+                                        traceRouteCtlTestNameLen] =
+                '\0';
+            temp->traceRouteCtlTestNameLen =
+                item->traceRouteCtlTestNameLen;
+
+            /* add lock to protect */
+            pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;
+            pthread_mutex_lock(&counter_mutex);
+            temp->traceRouteHopsHopIndex = ++index;
+            pthread_mutex_unlock(&counter_mutex);
+            /* endsadsadsad */
+
+
+            temp->traceRouteHopsIpTgtAddressType = 0;
+            temp->traceRouteHopsIpTgtAddress = strdup("");
+            temp->traceRouteHopsIpTgtAddressLen = 0;
+            temp->traceRouteHopsMinRtt = 0;
+            temp->traceRouteHopsMaxRtt = 0;
+            temp->traceRouteHopsAverageRtt = 0;
+            temp->traceRouteHopsRttSumOfSquares = 0;
+            temp->traceRouteHopsSentProbes = 0;
+            temp->traceRouteHopsProbeResponses = 0;
+
+            temp->traceRouteHopsLastGoodProbeLen = 0;
+            if (index == 1)
+                item->traceRouteHops = temp;
+            else {
+                (current_temp)->next = temp;
+            }
 
-                temp->traceRouteCtlTestName =
-                    (char *) malloc(item->traceRouteCtlTestNameLen + 1);
-                memcpy(temp->traceRouteCtlTestName,
-                       item->traceRouteCtlTestName,
-                       item->traceRouteCtlTestNameLen + 1);
-                temp->traceRouteCtlTestName[item->
-                                            traceRouteCtlTestNameLen] =
-                    '\0';
-                temp->traceRouteCtlTestNameLen =
-                    item->traceRouteCtlTestNameLen;
+            current_temp = temp;
 
-                /* add lock to protect */
-                pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;
-                pthread_mutex_lock(&counter_mutex);
-                temp->traceRouteHopsHopIndex = ++index;
-                pthread_mutex_unlock(&counter_mutex);
-                /* endsadsadsad */
+            if (index + 1 >= item->traceRouteCtlMaxTtl) {
+                current_temp->next = NULL;
+            }
 
+            if (item->traceRouteHops != NULL)
 
-                temp->traceRouteHopsIpTgtAddressType = 0;
-                temp->traceRouteHopsIpTgtAddress = strdup("");
-                temp->traceRouteHopsIpTgtAddressLen = 0;
-                temp->traceRouteHopsMinRtt = 0;
-                temp->traceRouteHopsMaxRtt = 0;
-                temp->traceRouteHopsAverageRtt = 0;
-                temp->traceRouteHopsRttSumOfSquares = 0;
-                temp->traceRouteHopsSentProbes = 0;
-                temp->traceRouteHopsProbeResponses = 0;
+                if (traceRouteHopsTable_add(current_temp) !=
+                    SNMPERR_SUCCESS)
+                    DEBUGMSGTL(("traceRouteHopsTable",
+                                "registered an entry error\n"));
 
-                temp->traceRouteHopsLastGoodProbeLen = 0;
-                if (index == 1)
-                    item->traceRouteHops = temp;
-                else {
-                    (current_temp)->next = temp;
-                }
+        }
+        unsigned long maxRtt = 0;
+        unsigned long minRtt = 0;
+        unsigned long averageRtt = 0;
+        unsigned long sumRtt = 0;
+        unsigned long responseProbe = 0;
+        unsigned long sumOfSquare = 0;
+        for (probe = 0; probe < nprobes; ++probe) {
+            int    cc;
+            struct timeval  t1, t2;
+            struct timezone tz;
+            struct ip *ip = NULL;
+            unsigned long Rtt = 0;
+
+            if (sentfirst && pausemsecs > 0)
+                usleep(pausemsecs * 1000);
+            (void) gettimeofday(&t1, &tz);
+            send_probe(to, ++seq, ttl, &t1, outip, outudp, packlen,
+                       optlen, hostname, ident, sndsock, port,
+                       outdata);
+            ++sentfirst;
+            while ((cc =
+                    wait_for_reply(s, from, &t1, packet,
+                                   waittime)) != 0) {
+                (void) gettimeofday(&t2, &tz);
+                timep = 0;
+                time(&timep);
+                i = packet_ok(packet, cc, from, seq, ident, pmtu,
+                              port);
+                /*
+                 * Skip short packet 
+                 */
+                if (i == 0)
+                    continue;
+                if (!gotlastaddr || from->sin_addr.s_addr != lastaddr) {
+                    struct ip *ip;
+                    int    hlen;
+                    ip = (struct ip *) packet;
+                    hlen = ip->ip_hl << 2;
+                    cc -= hlen;
+                    DEBUGMSGTL(("traceRouteCtlTable",
+                                " %s", inet_ntoa(from->sin_addr)));
 
-                current_temp = temp;
 
-                if (index + 1 >= item->traceRouteCtlMaxTtl) {
-                    current_temp->next = NULL;
+                    lastaddr = from->sin_addr.s_addr;
+                    ++gotlastaddr;
                 }
-
-                if (item->traceRouteHops != NULL)
-
-                    if (traceRouteHopsTable_add(current_temp) !=
-                        SNMPERR_SUCCESS)
-                        DEBUGMSGTL(("traceRouteHopsTable",
-                                    "registered an entry error\n"));
-
-            }
-            register unsigned long maxRtt = 0;
-            register unsigned long minRtt = 0;
-            register unsigned long averageRtt = 0;
-            register unsigned long sumRtt = 0;
-            register unsigned long responseProbe = 0;
-            register unsigned long sumOfSquare = 0;
-            for (probe = 0; probe < nprobes; ++probe) {
-                register int    cc;
-                struct timeval  t1, t2;
-                struct timezone tz;
-                register struct ip *ip = NULL;
-                register unsigned long Rtt = 0;
-
-                if (sentfirst && pausemsecs > 0)
-                    usleep(pausemsecs * 1000);
-                (void) gettimeofday(&t1, &tz);
-                send_probe(to, ++seq, ttl, &t1, outip, outudp, packlen,
-                           optlen, hostname, ident, sndsock, port,
-                           outdata);
-                ++sentfirst;
-                while ((cc =
-                        wait_for_reply(s, from, &t1, packet,
-                                       waittime)) != 0) {
-                    (void) gettimeofday(&t2, &tz);
-                    timep = 0;
-                    time(&timep);
-                    i = packet_ok(packet, cc, from, seq, ident, pmtu,
-                                  port);
-                    /*
-                     * Skip short packet 
-                     */
-                    if (i == 0)
-                        continue;
-                    if (!gotlastaddr || from->sin_addr.s_addr != lastaddr) {
-                        register struct ip *ip;
-                        register int    hlen;
-                        ip = (struct ip *) packet;
-                        hlen = ip->ip_hl << 2;
-                        cc -= hlen;
-                        DEBUGMSGTL(("traceRouteCtlTable",
-                                    " %s", inet_ntoa(from->sin_addr)));
-
-
-                        lastaddr = from->sin_addr.s_addr;
-                        ++gotlastaddr;
-                    }
-                    Rtt = deltaT(&t1, &t2);
-                    responseProbe = responseProbe + 1;
-                    if (probe == 0) {
+                Rtt = deltaT(&t1, &t2);
+                responseProbe = responseProbe + 1;
+                if (probe == 0) {
+                    minRtt = Rtt;
+                    maxRtt = Rtt;
+                    averageRtt = Rtt;
+                    sumRtt = Rtt;
+                    sumOfSquare = Rtt * Rtt;
+                } else {
+                    if (Rtt < minRtt)
                         minRtt = Rtt;
+                    if (Rtt > maxRtt)
                         maxRtt = Rtt;
-                        averageRtt = Rtt;
-                        sumRtt = Rtt;
-                        sumOfSquare = Rtt * Rtt;
-                    } else {
-                        if (Rtt < minRtt)
-                            minRtt = Rtt;
-                        if (Rtt > maxRtt)
-                            maxRtt = Rtt;
-                        sumRtt = (sumRtt) + Rtt;
-                        averageRtt =
-                            round((double) (sumRtt) /
-                                  (double) responseProbe);
-                        sumOfSquare = sumOfSquare + Rtt * Rtt;
-                    }
+                    sumRtt = (sumRtt) + Rtt;
+                    averageRtt =
+                        round((double) (sumRtt) /
+                              (double) responseProbe);
+                    sumOfSquare = sumOfSquare + Rtt * Rtt;
+                }
 
-                    StorageResults->traceRouteResultsCurProbeCount =
-                        probe + 1;
-                    if (i == -2) {
+                StorageResults->traceRouteResultsCurProbeCount =
+                    probe + 1;
+                if (i == -2) {
 #ifndef ARCHAIC
-                        ip = (struct ip *) packet;
-                        if (ip->ip_ttl <= 1)
-                            Printf(" !");
+                    ip = (struct ip *) packet;
+                    if (ip->ip_ttl <= 1)
+                        Printf(" !");
 #endif
-                        ++got_there;
-                        break;
-                    }
-                    /*
-                     * time exceeded in transit 
-                     */
-                    if (i == -1)
-                        break;
-                    code = i - 1;
-                    switch (code) {
+                    ++got_there;
+                    break;
+                }
+                /*
+                 * time exceeded in transit 
+                 */
+                if (i == -1)
+                    break;
+                code = i - 1;
+                switch (code) {
 
-                    case ICMP_UNREACH_PORT:
+                case ICMP_UNREACH_PORT:
 #ifndef ARCHAIC
-                        ip = (struct ip *) packet;
-                        if (ip->ip_ttl <= 1)
-                            Printf(" !");
+                    ip = (struct ip *) packet;
+                    if (ip->ip_ttl <= 1)
+                        Printf(" !");
 #endif
-                        ++got_there;
-                        break;
+                    ++got_there;
+                    break;
 
-                    case ICMP_UNREACH_NET:
-                        ++unreachable;
-                        Printf(" !N");
-                        break;
+                case ICMP_UNREACH_NET:
+                    ++unreachable;
+                    Printf(" !N");
+                    break;
 
-                    case ICMP_UNREACH_HOST:
-                        ++unreachable;
-                        Printf(" !H");
-                        break;
+                case ICMP_UNREACH_HOST:
+                    ++unreachable;
+                    Printf(" !H");
+                    break;
 
-                    case ICMP_UNREACH_PROTOCOL:
-                        ++got_there;
-                        Printf(" !P");
-                        break;
+                case ICMP_UNREACH_PROTOCOL:
+                    ++got_there;
+                    Printf(" !P");
+                    break;
 
-                    case ICMP_UNREACH_NEEDFRAG:
-                        ++unreachable;
-                        Printf(" !F-%d", pmtu);
-                        break;
+                case ICMP_UNREACH_NEEDFRAG:
+                    ++unreachable;
+                    Printf(" !F-%d", pmtu);
+                    break;
 
-                    case ICMP_UNREACH_SRCFAIL:
-                        ++unreachable;
-                        Printf(" !S");
-                        break;
+                case ICMP_UNREACH_SRCFAIL:
+                    ++unreachable;
+                    Printf(" !S");
+                    break;
 
-                    case ICMP_UNREACH_FILTER_PROHIB:
-                        ++unreachable;
-                        Printf(" !X");
-                        break;
+                case ICMP_UNREACH_FILTER_PROHIB:
+                    ++unreachable;
+                    Printf(" !X");
+                    break;
 
-                    case ICMP_UNREACH_HOST_PRECEDENCE:
-                        ++unreachable;
-                        Printf(" !V");
-                        break;
+                case ICMP_UNREACH_HOST_PRECEDENCE:
+                    ++unreachable;
+                    Printf(" !V");
+                    break;
 
-                    case ICMP_UNREACH_PRECEDENCE_CUTOFF:
-                        ++unreachable;
-                        Printf(" !C");
-                        break;
+                case ICMP_UNREACH_PRECEDENCE_CUTOFF:
+                    ++unreachable;
+                    Printf(" !C");
+                    break;
 
-                    default:
-                        ++unreachable;
-                        Printf(" !<%d>", code);
-                        break;
-                    }
+                default:
+                    ++unreachable;
+                    Printf(" !<%d>", code);
                     break;
                 }
-                if (cc == 0) {
-                    timep = 0;
-                    time(&timep);
-                    Printf(" *");
-                    Rtt = (item->traceRouteCtlTimeOut) * 1000;
-                }
-                if (item->traceRouteCtlMaxRows != 0) {
-
-                    temp_his =
-                        SNMP_MALLOC_STRUCT
-                        (traceRouteProbeHistoryTable_data);
-                    temp_his->traceRouteCtlOwnerIndex =
-                        (char *) malloc(item->traceRouteCtlOwnerIndexLen +
-                                        1);
-                    memcpy(temp_his->traceRouteCtlOwnerIndex,
-                           item->traceRouteCtlOwnerIndex,
-                           item->traceRouteCtlOwnerIndexLen + 1);
-                    temp_his->traceRouteCtlOwnerIndex[item->
-                                                      traceRouteCtlOwnerIndexLen]
-                        = '\0';
-                    temp_his->traceRouteCtlOwnerIndexLen =
-                        item->traceRouteCtlOwnerIndexLen;
-
-                    temp_his->traceRouteCtlTestName =
-                        (char *) malloc(item->traceRouteCtlTestNameLen +
-                                        1);
-                    memcpy(temp_his->traceRouteCtlTestName,
-                           item->traceRouteCtlTestName,
-                           item->traceRouteCtlTestNameLen + 1);
-                    temp_his->traceRouteCtlTestName[item->
-                                                    traceRouteCtlTestNameLen]
-                        = '\0';
-                    temp_his->traceRouteCtlTestNameLen =
-                        item->traceRouteCtlTestNameLen;
-
-                    /* add lock to protect */
-                    pthread_mutex_t counter_mutex =
-                        PTHREAD_MUTEX_INITIALIZER;
-                    pthread_mutex_lock(&counter_mutex);
-                    if (item->traceRouteProbeHistoryMaxIndex >=
-                        (unsigned long) (2147483647))
-                        item->traceRouteProbeHistoryMaxIndex = 0;
-                    temp_his->traceRouteProbeHistoryIndex =
-                        ++(item->traceRouteProbeHistoryMaxIndex);
-                    pthread_mutex_unlock(&counter_mutex);
-                    /* endsadsadsad */
-                    temp_his->traceRouteProbeHistoryHopIndex = ttl;
-                    temp_his->traceRouteProbeHistoryProbeIndex = probe + 1;
-
-                    temp_his->traceRouteProbeHistoryHAddrType = 1;
-                    temp_his->traceRouteProbeHistoryHAddr =
-                        (char *) malloc(strlen(inet_ntoa(from->sin_addr)) +
-                                        1);
-                    strcpy(temp_his->traceRouteProbeHistoryHAddr,
-                           (inet_ntoa(from->sin_addr)));
-                    temp_his->
-                        traceRouteProbeHistoryHAddr[strlen
-                                                    (inet_ntoa
-                                                     (from->sin_addr))] =
-                        '\0';
-                    temp_his->traceRouteProbeHistoryHAddrLen =
-                        strlen(inet_ntoa(from->sin_addr));
-
-                    temp_his->traceRouteProbeHistoryResponse = Rtt;
-                    temp_his->traceRouteProbeHistoryStatus = 1;
-                    temp_his->traceRouteProbeHistoryLastRC = 0;
-
-		    temp_his->traceRouteProbeHistoryTime_time = timep;
-                    temp_his->traceRouteProbeHistoryTime =
-                        netsnmp_memdup(date_n_time(&timep,
-                                      &temp_his->traceRouteProbeHistoryTimeLen),
-                                       11);
-                    if (probe == 0)
-                        item->traceRouteProbeHis = temp_his;
-                    else {
-                        (current_temp_his)->next = temp_his;
-                    }
-
-                    current_temp_his = temp_his;
+                break;
+            }
+            if (cc == 0) {
+                timep = 0;
+                time(&timep);
+                Printf(" *");
+                Rtt = (item->traceRouteCtlTimeOut) * 1000;
+            }
+            if (item->traceRouteCtlMaxRows != 0) {
+
+                temp_his =
+                    SNMP_MALLOC_STRUCT
+                    (traceRouteProbeHistoryTable_data);
+                temp_his->traceRouteCtlOwnerIndex =
+                    (char *) malloc(item->traceRouteCtlOwnerIndexLen +
+                                    1);
+                memcpy(temp_his->traceRouteCtlOwnerIndex,
+                       item->traceRouteCtlOwnerIndex,
+                       item->traceRouteCtlOwnerIndexLen + 1);
+                temp_his->traceRouteCtlOwnerIndex[item->
+                                                  traceRouteCtlOwnerIndexLen]
+                    = '\0';
+                temp_his->traceRouteCtlOwnerIndexLen =
+                    item->traceRouteCtlOwnerIndexLen;
 
-                    if (probe + 1 >= nprobes) {
-                        current_temp_his->next = NULL;
+                temp_his->traceRouteCtlTestName =
+                    (char *) malloc(item->traceRouteCtlTestNameLen +
+                                    1);
+                memcpy(temp_his->traceRouteCtlTestName,
+                       item->traceRouteCtlTestName,
+                       item->traceRouteCtlTestNameLen + 1);
+                temp_his->traceRouteCtlTestName[item->
+                                                traceRouteCtlTestNameLen]
+                    = '\0';
+                temp_his->traceRouteCtlTestNameLen =
+                    item->traceRouteCtlTestNameLen;
 
-                    }
+                /* add lock to protect */
+                pthread_mutex_t counter_mutex =
+                    PTHREAD_MUTEX_INITIALIZER;
+                pthread_mutex_lock(&counter_mutex);
+                if (item->traceRouteProbeHistoryMaxIndex >=
+                    (unsigned long) (2147483647))
+                    item->traceRouteProbeHistoryMaxIndex = 0;
+                temp_his->traceRouteProbeHistoryIndex =
+                    ++(item->traceRouteProbeHistoryMaxIndex);
+                pthread_mutex_unlock(&counter_mutex);
+                /* endsadsadsad */
+                temp_his->traceRouteProbeHistoryHopIndex = ttl;
+                temp_his->traceRouteProbeHistoryProbeIndex = probe + 1;
+
+                temp_his->traceRouteProbeHistoryHAddrType = 1;
+                temp_his->traceRouteProbeHistoryHAddr =
+                    (char *) malloc(strlen(inet_ntoa(from->sin_addr)) +
+                                    1);
+                strcpy(temp_his->traceRouteProbeHistoryHAddr,
+                       (inet_ntoa(from->sin_addr)));
+                temp_his->
+                    traceRouteProbeHistoryHAddr[strlen
+                                                (inet_ntoa
+                                                 (from->sin_addr))] =
+                    '\0';
+                temp_his->traceRouteProbeHistoryHAddrLen =
+                    strlen(inet_ntoa(from->sin_addr));
+
+                temp_his->traceRouteProbeHistoryResponse = Rtt;
+                temp_his->traceRouteProbeHistoryStatus = 1;
+                temp_his->traceRouteProbeHistoryLastRC = 0;
+
+                temp_his->traceRouteProbeHistoryTime_time = timep;
+                temp_his->traceRouteProbeHistoryTime =
+                    netsnmp_memdup(date_n_time(&timep,
+                                               &temp_his->traceRouteProbeHistoryTimeLen),
+                                   11);
+                if (probe == 0)
+                    item->traceRouteProbeHis = temp_his;
+                else {
+                    (current_temp_his)->next = temp_his;
+                }
 
-                    if (item->traceRouteProbeHis != NULL) {
-                        if (traceRouteProbeHistoryTable_count(item) <
-                            item->traceRouteCtlMaxRows) {
-                            if (traceRouteProbeHistoryTable_add
-                                (current_temp_his) != SNMPERR_SUCCESS)
-                                DEBUGMSGTL(("traceRouteProbeHistoryTable",
-                                            "registered an entry error\n"));
-                        } else {
-                            traceRouteProbeHistoryTable_delLast(item);
-                            if (traceRouteProbeHistoryTable_add
-                                (current_temp_his) != SNMPERR_SUCCESS)
-                                DEBUGMSGTL(("traceRouteProbeHistoryTable",
-                                            "registered an entry error\n"));
+                current_temp_his = temp_his;
 
-                        }
-		    }
+                if (probe + 1 >= nprobes) {
+                    current_temp_his->next = NULL;
 
                 }
 
-                if (item->traceRouteCtlCreateHopsEntries == 1) {
-                    netsnmp_variable_list *vars_hops = NULL;
-                    snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);    /*  traceRouteCtlOwnerIndex  */
-                    snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);        /*  traceRouteCtlTestName  */
-                    snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_UNSIGNED, (char *) &index, sizeof(index));       /*  traceRouteHopsIndex  */
-                    if ((current =
-                         header_complex_get(traceRouteHopsTableStorage,
-                                            vars_hops)) == NULL)
-                        return;
-                    snmp_free_varbind(vars_hops);
-                    vars_hops = NULL;
-
-                    current->traceRouteHopsIpTgtAddressType = 1;
-                    current->traceRouteHopsIpTgtAddress =
-                        (char *) malloc(strlen(inet_ntoa(from->sin_addr)) +
-                                        1);
-                    current->traceRouteHopsIpTgtAddress =
-                        strdup(inet_ntoa(from->sin_addr));
-                    current->
-                        traceRouteHopsIpTgtAddress[strlen
-                                                   (inet_ntoa
-                                                    (from->sin_addr))] =
-                        '\0';
-                    current->traceRouteHopsIpTgtAddressLen =
-                        strlen(inet_ntoa(from->sin_addr));
-                    if (count != 0) {
-                        if (strcmp
-                            (old_HopsAddress[index - 1],
-                             current->traceRouteHopsIpTgtAddress) != 0)
-                            flag = 1;
+                if (item->traceRouteProbeHis != NULL) {
+                    if (traceRouteProbeHistoryTable_count(item) <
+                        item->traceRouteCtlMaxRows) {
+                        if (traceRouteProbeHistoryTable_add
+                            (current_temp_his) != SNMPERR_SUCCESS)
+                            DEBUGMSGTL(("traceRouteProbeHistoryTable",
+                                        "registered an entry error\n"));
+                    } else {
+                        traceRouteProbeHistoryTable_delLast(item);
+                        if (traceRouteProbeHistoryTable_add
+                            (current_temp_his) != SNMPERR_SUCCESS)
+                            DEBUGMSGTL(("traceRouteProbeHistoryTable",
+                                        "registered an entry error\n"));
+
                     }
+                }
+
+            }
 
-                    current->traceRouteHopsIpTgtAddressLen =
-                        strlen(inet_ntoa(from->sin_addr));
-                    current->traceRouteHopsMinRtt = minRtt;
-                    current->traceRouteHopsMaxRtt = maxRtt;
-                    current->traceRouteHopsAverageRtt = averageRtt;
-                    current->traceRouteHopsRttSumOfSquares = sumOfSquare;
-                    current->traceRouteHopsSentProbes = probe + 1;
-                    current->traceRouteHopsProbeResponses = responseProbe;
-		    current->traceRouteHopsLastGoodProbe_time = timep;
-                    current->traceRouteHopsLastGoodProbe =
-                        netsnmp_memdup(date_n_time(&timep,
-                                      &current->traceRouteHopsLastGoodProbeLen),
-                                       11);
+            if (item->traceRouteCtlCreateHopsEntries == 1) {
+                netsnmp_variable_list *vars_hops = NULL;
+                snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);    /*  traceRouteCtlOwnerIndex  */
+                snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);        /*  traceRouteCtlTestName  */
+                snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_UNSIGNED, (char *) &index, sizeof(index));       /*  traceRouteHopsIndex  */
+                if ((current =
+                     header_complex_get(traceRouteHopsTableStorage,
+                                        vars_hops)) == NULL) {
+                    goto out;
+                }
+                snmp_free_varbind(vars_hops);
+                vars_hops = NULL;
+
+                current->traceRouteHopsIpTgtAddressType = 1;
+                current->traceRouteHopsIpTgtAddress =
+                    (char *) malloc(strlen(inet_ntoa(from->sin_addr)) +
+                                    1);
+                current->traceRouteHopsIpTgtAddress =
+                    strdup(inet_ntoa(from->sin_addr));
+                current->
+                    traceRouteHopsIpTgtAddress[strlen
+                                               (inet_ntoa
+                                                (from->sin_addr))] =
+                    '\0';
+                current->traceRouteHopsIpTgtAddressLen =
+                    strlen(inet_ntoa(from->sin_addr));
+                if (count != 0) {
+                    if (strcmp
+                        (old_HopsAddress[index - 1],
+                         current->traceRouteHopsIpTgtAddress) != 0)
+                        flag = 1;
                 }
 
-                (void) fflush(stdout);
+                current->traceRouteHopsIpTgtAddressLen =
+                    strlen(inet_ntoa(from->sin_addr));
+                current->traceRouteHopsMinRtt = minRtt;
+                current->traceRouteHopsMaxRtt = maxRtt;
+                current->traceRouteHopsAverageRtt = averageRtt;
+                current->traceRouteHopsRttSumOfSquares = sumOfSquare;
+                current->traceRouteHopsSentProbes = probe + 1;
+                current->traceRouteHopsProbeResponses = responseProbe;
+                current->traceRouteHopsLastGoodProbe_time = timep;
+                current->traceRouteHopsLastGoodProbe =
+                    netsnmp_memdup(date_n_time(&timep,
+                                               &current->traceRouteHopsLastGoodProbeLen),
+                                   11);
             }
-            putchar('\n');
 
+            (void) fflush(stdout);
+        }
+        putchar('\n');
 
-            if (got_there
-                || (unreachable > 0 && unreachable >= nprobes - 1)) {
 
-                if (got_there != 0) {
-                    StorageResults->traceRouteResultsTestAttempts =
-                        StorageResults->traceRouteResultsTestAttempts + 1;
+        if (got_there
+            || (unreachable > 0 && unreachable >= nprobes - 1)) {
 
-                    StorageResults->traceRouteResultsTestSuccesses =
-                        StorageResults->traceRouteResultsTestSuccesses + 1;
+            if (got_there != 0) {
+                StorageResults->traceRouteResultsTestAttempts =
+                    StorageResults->traceRouteResultsTestAttempts + 1;
 
-		    StorageResults->traceRouteResultsLastGoodPath_time = timep;
-                    StorageResults->traceRouteResultsLastGoodPath =
-                        netsnmp_memdup(date_n_time(&timep,
-                                              &StorageResults->
-                                              traceRouteResultsLastGoodPathLen),
-                                       11);
-                    if ((item->
-                         traceRouteCtlTrapGeneration[0] &
-                         TRACEROUTETRAPGENERATION_TESTCOMPLETED) != 0) {
-                        DEBUGMSGTL(("traceRouteProbeHistoryTable",
-                                    "TEST completed!\n"));
-                        send_traceRoute_trap(item, traceRouteTestCompleted,
-                                             sizeof
-                                             (traceRouteTestCompleted) /
-                                             sizeof(oid));
-                    }
-                }
+                StorageResults->traceRouteResultsTestSuccesses =
+                    StorageResults->traceRouteResultsTestSuccesses + 1;
 
-                else {
-                    StorageResults->traceRouteResultsTestAttempts =
-                        StorageResults->traceRouteResultsTestAttempts + 1;
-                    if ((item->
-                         traceRouteCtlTrapGeneration[0] &
-                         TRACEROUTETRAPGENERATION_TESTFAILED) != 0) {
-                        DEBUGMSGTL(("traceRouteProbeHistoryTable",
-                                    "test Failed!\n"));
-                        send_traceRoute_trap(item, traceRouteTestFailed,
-                                       sizeof(traceRouteTestFailed) /
-                                       sizeof(oid));
-                    }
+                StorageResults->traceRouteResultsLastGoodPath_time = timep;
+                StorageResults->traceRouteResultsLastGoodPath =
+                    netsnmp_memdup(date_n_time(&timep,
+                                               &StorageResults->
+                                               traceRouteResultsLastGoodPathLen),
+                                   11);
+                if ((item->
+                     traceRouteCtlTrapGeneration[0] &
+                     TRACEROUTETRAPGENERATION_TESTCOMPLETED) != 0) {
+                    DEBUGMSGTL(("traceRouteProbeHistoryTable",
+                                "TEST completed!\n"));
+                    send_traceRoute_trap(item, traceRouteTestCompleted,
+                                         sizeof
+                                         (traceRouteTestCompleted) /
+                                         sizeof(oid));
                 }
-                break;
+            }
 
-            } else if (ttl == item->traceRouteCtlMaxTtl
-                       && (probe + 1) == nprobes) {
+            else {
                 StorageResults->traceRouteResultsTestAttempts =
                     StorageResults->traceRouteResultsTestAttempts + 1;
-
                 if ((item->
                      traceRouteCtlTrapGeneration[0] &
                      TRACEROUTETRAPGENERATION_TESTFAILED) != 0) {
                     DEBUGMSGTL(("traceRouteProbeHistoryTable",
                                 "test Failed!\n"));
                     send_traceRoute_trap(item, traceRouteTestFailed,
-                                   sizeof(traceRouteTestFailed) /
-                                   sizeof(oid));
+                                         sizeof(traceRouteTestFailed) /
+                                         sizeof(oid));
                 }
             }
+            break;
+
+        } else if (ttl == item->traceRouteCtlMaxTtl
+                   && (probe + 1) == nprobes) {
+            StorageResults->traceRouteResultsTestAttempts =
+                StorageResults->traceRouteResultsTestAttempts + 1;
 
+            if ((item->
+                 traceRouteCtlTrapGeneration[0] &
+                 TRACEROUTETRAPGENERATION_TESTFAILED) != 0) {
+                DEBUGMSGTL(("traceRouteProbeHistoryTable",
+                            "test Failed!\n"));
+                send_traceRoute_trap(item, traceRouteTestFailed,
+                                     sizeof(traceRouteTestFailed) /
+                                     sizeof(oid));
+            }
         }
 
+    }
+
+    if (flag == 1) {
+        DEBUGMSGTL(("traceRouteProbeHistoryTable", "path changed!\n"));
+        send_traceRoute_trap(item, traceRoutePathChange,
+                             sizeof(traceRoutePathChange) /
+                             sizeof(oid));
+    }
+
+out:
+    for (k = 0; k < count; k++)
+        free(old_HopsAddress[k]);
+    for (k = 0; k < 3; k++)
+        if (fd[k] >= 0)
+            close(fd[k]);
+    if (s >= 0)
+        close(s);
+    if (sndsock >= 0)
         close(sndsock);
+    free(outip);
+    free(hostname);
+}
 
-        if (flag == 1) {
-            DEBUGMSGTL(("traceRouteProbeHistoryTable", "path changed!\n"));
-            send_traceRoute_trap(item, traceRoutePathChange,
-                                 sizeof(traceRoutePathChange) /
-                                 sizeof(oid));
-        }
+static void
+run_traceRoute_ipv6(struct traceRouteCtlTable_data *item)
+{
+    int             nprobes = item->traceRouteCtlProbesPerHop;
+    char           *old_HopsAddress[255];
+    int             count = 0;
+    int             flag = 0;
 
-        int             k = 0;
-        for (k = 0; k < count; k++) {
-            free(old_HopsAddress[k]);
-            old_HopsAddress[k] = NULL;
-        }
-    }
-    if (item->traceRouteCtlTargetAddressType == 2) {
-        int             icmp_sock = 0;  /* receive (icmp) socket file descriptor */
-        int             sndsock = 0;    /* send (udp) socket file descriptor */
+    int             icmp_sock = -1;  /* receive (icmp) socket file descriptor */
+    int             sndsock = -1;    /* send (udp) socket file descriptor */
 
-        struct sockaddr_in6 whereto;    /* Who to try to reach */
+    struct sockaddr_in6 whereto;    /* Who to try to reach */
 
-        struct sockaddr_in6 saddr;
-        struct sockaddr_in6 firsthop;
-        char           *source = NULL;
-        char           *device = NULL;
-        char           *hostname = NULL;
+    struct sockaddr_in6 saddr;
+    struct sockaddr_in6 firsthop;
+    char           *source = NULL;
+    char           *device = NULL;
+    char           *hostname;
 
-        pid_t           ident = 0;
-        u_short         port = 32768 + 666;     /* start udp dest port # for probe packets */
-        int             options = 0;    /* socket options */
-        int             waittime = 5;   /* time to wait for response (in seconds) */
+    pid_t           ident = 0;
+    u_short         port = 32768 + 666;     /* start udp dest port # for probe packets */
+    int             options = 0;    /* socket options */
+    int             waittime = 5;   /* time to wait for response (in seconds) */
 
-        char           *sendbuff = NULL;
-        int             datalen = sizeof(struct pkt_format);
+    char           *sendbuff = NULL;
+    int             datalen = sizeof(struct pkt_format);
 
-        u_char          packet[512];    /* last inbound (icmp) packet */
+    u_char          packet[512];    /* last inbound (icmp) packet */
 
-        char            pa[64];
-        struct hostent *hp = NULL;
-        struct sockaddr_in6 from, *to = NULL;
-        int             i = 0, on = 0, probe = 0, seq = 0, tos =
-            0, ttl = 0;
-        int             socket_errno = 0;
+    char            pa[64];
+    struct hostent *hp = NULL;
+    struct sockaddr_in6 from, *to = NULL;
+    int             i = 0, k, on = 0, probe = 0, seq = 0, tos = 0, ttl = 0;
+    int             socket_errno = 0;
 
-        icmp_sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
-        socket_errno = errno;
+    icmp_sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
+    socket_errno = errno;
 
-        setuid(getuid());
+    setuid(getuid());
 
-        on = 1;
-        seq = tos = 0;
-        to = (struct sockaddr_in6 *) &whereto;
+    on = 1;
+    seq = tos = 0;
+    to = (struct sockaddr_in6 *) &whereto;
 
-        hostname =
-            (char *) malloc(item->traceRouteCtlTargetAddressLen + 1);
-        memcpy(hostname, item->traceRouteCtlTargetAddress,
-               item->traceRouteCtlTargetAddressLen + 1);
-        hostname[item->traceRouteCtlTargetAddressLen] = '\0';
+    hostname = malloc(item->traceRouteCtlTargetAddressLen + 1);
+    if (!hostname)
+        goto out;
+    memcpy(hostname, item->traceRouteCtlTargetAddress,
+           item->traceRouteCtlTargetAddressLen + 1);
+    hostname[item->traceRouteCtlTargetAddressLen] = '\0';
 
-        setlinebuf(stdout);
+    setlinebuf(stdout);
 
-        memset(&whereto, '\0', sizeof(struct sockaddr_in6));
+    memset(&whereto, '\0', sizeof(struct sockaddr_in6));
 
-        to->sin6_family = AF_INET6;
-        to->sin6_port = htons(port);
+    to->sin6_family = AF_INET6;
+    to->sin6_port = htons(port);
 
-        if (inet_pton(AF_INET6, hostname, &to->sin6_addr) <= 0) {
-            hp = gethostbyname2(hostname, AF_INET6);
-            if (hp != NULL) {
-                memmove((caddr_t) & to->sin6_addr, hp->h_addr, 16);
-                hostname = (char *) hp->h_name;
-            } else {
-                (void) fprintf(stderr,
-                               "traceroute: unknown host %s\n", hostname);
-                return;
-            }
-        }
-        firsthop = *to;
-
-        datalen = item->traceRouteCtlDataSize;
-        if (datalen < (int) sizeof(struct pkt_format)
-            || datalen >= MAXPACKET) {
-            Fprintf(stderr,
-                    "traceroute: packet size must be %d <= s < %d.\n",
-                    (int) sizeof(struct pkt_format), MAXPACKET);
-            datalen = 16;
+    if (inet_pton(AF_INET6, hostname, &to->sin6_addr) <= 0) {
+        hp = gethostbyname2(hostname, AF_INET6);
+        free(hostname);
+        hostname = NULL;
+        if (hp != NULL) {
+            memmove((caddr_t) & to->sin6_addr, hp->h_addr, 16);
+            hostname = strdup((char *) hp->h_name);
+        } else {
+            (void) fprintf(stderr,
+                           "traceroute: unknown host %s\n", hostname);
+            goto out;
         }
+    }
+    firsthop = *to;
 
-        ident = getpid();
+    datalen = item->traceRouteCtlDataSize;
+    if (datalen < (int) sizeof(struct pkt_format)
+        || datalen >= MAXPACKET) {
+        Fprintf(stderr,
+                "traceroute: packet size must be %d <= s < %d.\n",
+                (int) sizeof(struct pkt_format), MAXPACKET);
+        datalen = 16;
+    }
 
-        sendbuff = malloc(datalen);
-        if (sendbuff == NULL) {
-            fprintf(stderr, "malloc failed\n");
-            return;
-        }
+    ident = getpid();
 
-        if (icmp_sock < 0) {
-            errno = socket_errno;
-            perror("traceroute6: icmp socket");
-            return;
-        }
+    sendbuff = malloc(datalen);
+    if (sendbuff == NULL) {
+        fprintf(stderr, "malloc failed\n");
+        goto out;
+    }
 
-        if (options & SO_DEBUG)
-            setsockopt(icmp_sock, SOL_SOCKET, SO_DEBUG,
-                       (char *) &on, sizeof(on));
-        if (options & SO_DONTROUTE)
-            setsockopt(icmp_sock, SOL_SOCKET, SO_DONTROUTE,
-                       (char *) &on, sizeof(on));
+    if (icmp_sock < 0) {
+        errno = socket_errno;
+        perror("traceroute6: icmp socket");
+        goto out;
+    }
 
-        if ((sndsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
-            perror("traceroute: UDP socket");
-            return;
-        }
+    if (options & SO_DEBUG)
+        setsockopt(icmp_sock, SOL_SOCKET, SO_DEBUG,
+                   (char *) &on, sizeof(on));
+    if (options & SO_DONTROUTE)
+        setsockopt(icmp_sock, SOL_SOCKET, SO_DONTROUTE,
+                   (char *) &on, sizeof(on));
+
+    if ((sndsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
+        perror("traceroute: UDP socket");
+        goto out;
+    }
 #ifdef SO_SNDBUF
-        if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *) &datalen,
-                       sizeof(datalen)) < 0) {
-            perror("traceroute: SO_SNDBUF");
-            return;
-        }
+    if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *) &datalen,
+                   sizeof(datalen)) < 0) {
+        perror("traceroute: SO_SNDBUF");
+        goto out;
+    }
 #endif                          /* SO_SNDBUF */
 
-        if (options & SO_DEBUG)
-            (void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG,
-                              (char *) &on, sizeof(on));
-        if (options & SO_DONTROUTE)
-            (void) setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE,
-                              (char *) &on, sizeof(on));
+    if (options & SO_DEBUG)
+        (void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG,
+                          (char *) &on, sizeof(on));
+    if (options & SO_DONTROUTE)
+        (void) setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE,
+                          (char *) &on, sizeof(on));
 
-        if (source == NULL) {
-            socklen_t       alen;
-            int             probe_fd = socket(AF_INET6, SOCK_DGRAM, 0);
+    if (source == NULL) {
+        socklen_t       alen;
+        int             probe_fd = socket(AF_INET6, SOCK_DGRAM, 0);
 
-            if (probe_fd < 0) {
-                perror("socket");
-                return;
-            }
-            if (device) {
-                if (setsockopt
-                    (probe_fd, SOL_SOCKET, SO_BINDTODEVICE, device,
-                     strlen(device) + 1) == -1)
-                    perror("WARNING: interface is ignored");
-            }
-            firsthop.sin6_port = htons(1025);
-            if (connect
-                (probe_fd, (struct sockaddr *) &firsthop,
-                 sizeof(firsthop)) == -1) {
-                perror("connect");
-                return;
-            }
-            alen = sizeof(saddr);
-            if (getsockname(probe_fd, (struct sockaddr *) &saddr, &alen) ==
-                -1) {
-                perror("getsockname");
-                return;
-            }
-            saddr.sin6_port = 0;
+        if (probe_fd < 0) {
+            perror("socket");
             close(probe_fd);
-        } else {
-            memset(&saddr, '\0', sizeof(struct sockaddr_in6));
-            saddr.sin6_family = AF_INET6;
-            if (inet_pton(AF_INET6, source, &saddr.sin6_addr) < 0) {
-                Printf("traceroute: unknown addr %s\n", source);
-                return;
-            }
+            goto out;
         }
-
-        if (bind(sndsock, (struct sockaddr *) &saddr, sizeof(saddr)) < 0) {
-            perror("traceroute: bind sending socket");
-            return;
+        if (device) {
+            if (setsockopt(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, device,
+                           strlen(device) + 1) == -1)
+                perror("WARNING: interface is ignored");
         }
-        if (bind(icmp_sock, (struct sockaddr *) &saddr, sizeof(saddr)) < 0) {
-            perror("traceroute: bind icmp6 socket");
-            return;
+        firsthop.sin6_port = htons(1025);
+        if (connect(probe_fd, (struct sockaddr *) &firsthop,
+                    sizeof(firsthop)) == -1) {
+            perror("connect");
+            close(probe_fd);
+            goto out;
         }
+        alen = sizeof(saddr);
+        if (getsockname(probe_fd, (struct sockaddr *) &saddr, &alen) == -1) {
+            perror("getsockname");
+            close(probe_fd);
+            goto out;
+        }
+        saddr.sin6_port = 0;
+        close(probe_fd);
+    } else {
+        memset(&saddr, '\0', sizeof(struct sockaddr_in6));
+        saddr.sin6_family = AF_INET6;
+        if (inet_pton(AF_INET6, source, &saddr.sin6_addr) < 0) {
+            Printf("traceroute: unknown addr %s\n", source);
+            goto out;
+        }
+    }
 
-        Fprintf(stderr, "traceroute to %s (%s)", hostname,
-                inet_ntop(AF_INET6, &to->sin6_addr, pa, 64));
-
-        Fprintf(stderr, " from %s",
-                inet_ntop(AF_INET6, &saddr.sin6_addr, pa, 64));
-        Fprintf(stderr, ", %lu hops max, %d byte packets\n",
-                item->traceRouteCtlMaxTtl, datalen);
-        (void) fflush(stderr);
-
+    if (bind(sndsock, (struct sockaddr *) &saddr, sizeof(saddr)) < 0) {
+        perror("traceroute: bind sending socket");
+        goto out;
+    }
+    if (bind(icmp_sock, (struct sockaddr *) &saddr, sizeof(saddr)) < 0) {
+        perror("traceroute: bind icmp6 socket");
+        goto out;
+    }
 
-        struct traceRouteResultsTable_data *StorageResults = NULL;
-        netsnmp_variable_list *vars_results = NULL;
+    Fprintf(stderr, "traceroute to %s (%s)", hostname,
+            inet_ntop(AF_INET6, &to->sin6_addr, pa, 64));
 
-        struct traceRouteHopsTable_data *temp = NULL;
-        struct traceRouteHopsTable_data *current_temp = NULL;
-        struct traceRouteHopsTable_data *current = NULL;
+    Fprintf(stderr, " from %s",
+            inet_ntop(AF_INET6, &saddr.sin6_addr, pa, 64));
+    Fprintf(stderr, ", %lu hops max, %d byte packets\n",
+            item->traceRouteCtlMaxTtl, datalen);
+    (void) fflush(stderr);
 
-        unsigned long   index = 0;
 
-        struct traceRouteProbeHistoryTable_data *temp_his = NULL;
-        struct traceRouteProbeHistoryTable_data *current_temp_his = NULL;
+    struct traceRouteResultsTable_data *StorageResults = NULL;
+    netsnmp_variable_list *vars_results = NULL;
 
-        snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);     /*  traceRouteCtlOwnerIndex  */
-        snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen); /*  traceRouteCtlTestName  */
-        if ((StorageResults =
-             header_complex_get(traceRouteResultsTableStorage,
-                                vars_results)) == NULL)
-            return;
-        snmp_free_varbind(vars_results);
-        vars_results = NULL;
+    struct traceRouteHopsTable_data *temp = NULL;
+    struct traceRouteHopsTable_data *current_temp = NULL;
+    struct traceRouteHopsTable_data *current = NULL;
 
-        for (ttl = item->traceRouteCtlInitialTtl;
-             ttl <= item->traceRouteCtlMaxTtl; ++ttl) {
-            struct in6_addr lastaddr = { {{0,}} };
-            int             got_there = 0;
-            int             unreachable = 0;
-            time_t          timep = 0;
-            Printf("%2d ", ttl);
+    unsigned long   index = 0;
 
+    struct traceRouteProbeHistoryTable_data *temp_his = NULL;
+    struct traceRouteProbeHistoryTable_data *current_temp_his = NULL;
 
-            StorageResults->traceRouteResultsCurHopCount = ttl;
-            if (item->traceRouteCtlCreateHopsEntries == 1) {
-                if (ttl == item->traceRouteCtlInitialTtl) {
-
-                    int             k = 0;
-                    count = traceRouteHopsTable_count(item);
-                    struct traceRouteHopsTable_data *StorageTmp = NULL;
-                    struct header_complex_index *hciptr2 = NULL;
-                    netsnmp_variable_list *vars = NULL;
-                    oid             newoid[MAX_OID_LEN];
-                    size_t          newoid_len;
-
-                    snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen); /* traceRouteCtlOwnerIndex */
-                    snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);     /* traceRouteCtlTestName */
-
-                    header_complex_generate_oid(newoid, &newoid_len, NULL,
-                                                0, vars);
-
-                    snmp_free_varbind(vars);
-                    vars = NULL;
-
-                    for (hciptr2 = traceRouteHopsTableStorage;
-                         hciptr2 != NULL; hciptr2 = hciptr2->next) {
-                        if (snmp_oid_compare
-                            (newoid, newoid_len, hciptr2->name,
-                             newoid_len) == 0) {
-                            StorageTmp =
-                                header_complex_extract_entry
-                                (&traceRouteHopsTableStorage, hciptr2);
-
-                            old_HopsAddress[k] =
-                                (char *) malloc(StorageTmp->
-                                                traceRouteHopsIpTgtAddressLen
-                                                + 1);
-                            if (old_HopsAddress[k] == NULL) {
-                                exit(1);
-                            }
-                            old_HopsAddress[k] = netsnmp_memdup(
-                                   StorageTmp->traceRouteHopsIpTgtAddress,
-                                   StorageTmp->
-                                   traceRouteHopsIpTgtAddressLen + 1);
-                            old_HopsAddress[k][StorageTmp->
-                                               traceRouteHopsIpTgtAddressLen]
-                                = '\0';
-
-                            k++;
+    snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);     /*  traceRouteCtlOwnerIndex  */
+    snmp_varlist_add_variable(&vars_results, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen); /*  traceRouteCtlTestName  */
+    if ((StorageResults =
+         header_complex_get(traceRouteResultsTableStorage,
+                            vars_results)) == NULL) {
+        goto out;
+    }
+    snmp_free_varbind(vars_results);
+    vars_results = NULL;
+
+    for (ttl = item->traceRouteCtlInitialTtl;
+         ttl <= item->traceRouteCtlMaxTtl; ++ttl) {
+        struct in6_addr lastaddr = { {{0,}} };
+        int             got_there = 0;
+        int             unreachable = 0;
+        time_t          timep = 0;
+        Printf("%2d ", ttl);
+
+
+        StorageResults->traceRouteResultsCurHopCount = ttl;
+        if (item->traceRouteCtlCreateHopsEntries == 1) {
+            if (ttl == item->traceRouteCtlInitialTtl) {
+
+                int             k = 0;
+                count = traceRouteHopsTable_count(item);
+                struct traceRouteHopsTable_data *StorageTmp;
+                struct header_complex_index *hciptr2, *nhciptr2;
+                netsnmp_variable_list *vars = NULL;
+                oid             newoid[MAX_OID_LEN];
+                size_t          newoid_len;
+
+                snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen); /* traceRouteCtlOwnerIndex */
+                snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);     /* traceRouteCtlTestName */
+
+                header_complex_generate_oid(newoid, &newoid_len, NULL,
+                                            0, vars);
+
+                snmp_free_varbind(vars);
+                vars = NULL;
+
+                for (hciptr2 = traceRouteHopsTableStorage; hciptr2;
+                     hciptr2 = nhciptr2) {
+                    nhciptr2 = hciptr2->next;
+                    if (snmp_oid_compare
+                        (newoid, newoid_len, hciptr2->name,
+                         newoid_len) == 0) {
+                        StorageTmp =
+                            header_complex_extract_entry
+                            (&traceRouteHopsTableStorage, hciptr2);
+
+                        old_HopsAddress[k] =
+                            (char *) malloc(StorageTmp->
+                                            traceRouteHopsIpTgtAddressLen
+                                            + 1);
+                        if (old_HopsAddress[k] == NULL) {
+                            exit(1);
                         }
+                        old_HopsAddress[k] = netsnmp_memdup(
+                                                            StorageTmp->traceRouteHopsIpTgtAddress,
+                                                            StorageTmp->
+                                                            traceRouteHopsIpTgtAddressLen + 1);
+                        old_HopsAddress[k][StorageTmp->
+                                           traceRouteHopsIpTgtAddressLen]
+                            = '\0';
+
+                        k++;
                     }
-                    traceRouteHopsTable_del(item);
-                    index = 0;
                 }
+                traceRouteHopsTable_del(item);
+                index = 0;
+            }
+
+            temp = SNMP_MALLOC_STRUCT(traceRouteHopsTable_data);
+            temp->traceRouteCtlOwnerIndex =
+                (char *) malloc(item->traceRouteCtlOwnerIndexLen + 1);
+            memcpy(temp->traceRouteCtlOwnerIndex,
+                   item->traceRouteCtlOwnerIndex,
+                   item->traceRouteCtlOwnerIndexLen + 1);
+            temp->traceRouteCtlOwnerIndex[item->
+                                          traceRouteCtlOwnerIndexLen] =
+                '\0';
+            temp->traceRouteCtlOwnerIndexLen =
+                item->traceRouteCtlOwnerIndexLen;
+
+            temp->traceRouteCtlTestName =
+                (char *) malloc(item->traceRouteCtlTestNameLen + 1);
+            memcpy(temp->traceRouteCtlTestName,
+                   item->traceRouteCtlTestName,
+                   item->traceRouteCtlTestNameLen + 1);
+            temp->traceRouteCtlTestName[item->
+                                        traceRouteCtlTestNameLen] =
+                '\0';
+            temp->traceRouteCtlTestNameLen =
+                item->traceRouteCtlTestNameLen;
+
+            /* add lock to protect */
+            pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;
+            pthread_mutex_lock(&counter_mutex);
+            temp->traceRouteHopsHopIndex = ++index;
+            pthread_mutex_unlock(&counter_mutex);
+            /* endsadsadsad */
+
+
+            temp->traceRouteHopsIpTgtAddressType = 0;
+            temp->traceRouteHopsIpTgtAddress = strdup("");
+            temp->traceRouteHopsIpTgtAddressLen = 0;
+            temp->traceRouteHopsMinRtt = 0;
+            temp->traceRouteHopsMaxRtt = 0;
+            temp->traceRouteHopsAverageRtt = 0;
+            temp->traceRouteHopsRttSumOfSquares = 0;
+            temp->traceRouteHopsSentProbes = 0;
+            temp->traceRouteHopsProbeResponses = 0;
+
+            temp->traceRouteHopsLastGoodProbeLen = 0;
+            if (index == 1)
+                item->traceRouteHops = temp;
+            else {
+                (current_temp)->next = temp;
+            }
+
+            current_temp = temp;
+
+            if (index >= item->traceRouteCtlMaxTtl) {
+                current_temp->next = NULL;
+            }
+
+            if (item->traceRouteHops != NULL)
+
+                if (traceRouteHopsTable_add(current_temp) !=
+                    SNMPERR_SUCCESS)
+                    DEBUGMSGTL(("traceRouteHopsTable",
+                                "registered an entry error\n"));
+
+        }
+
+        unsigned long maxRtt = 0;
+        unsigned long minRtt = 0;
+        unsigned long averageRtt = 0;
+        unsigned long sumRtt = 0;
+        unsigned long responseProbe = 0;
+        unsigned long sumOfSquare = 0;
+        for (probe = 0; probe < nprobes; ++probe) {
+            int             cc = 0, reset_timer = 0;
+            struct timeval  t1, t2;
+            struct timezone tz;
+            unsigned long Rtt = 0;
+
+            gettimeofday(&t1, &tz);
+
+            send_probe_v6(++seq, ttl, sendbuff, ident, &tz, sndsock,
+                          datalen, &whereto, hostname);
+            reset_timer = 1;
+
+            while ((cc =
+                    wait_for_reply_v6(icmp_sock, &from, reset_timer,
+                                      waittime, icmp_sock,
+                                      packet)) != 0) {
+                gettimeofday(&t2, &tz);
+                timep = 0;
+                time(&timep);
+                if ((i =
+                     packet_ok_v6(packet, cc, &from, seq, &t1,
+                                  ident))) {
+                    reset_timer = 1;
+                    if (memcmp
+                        (&from.sin6_addr, &lastaddr,
+                         sizeof(struct in6_addr))) {
+
+                        memcpy(&lastaddr,
+                               &from.sin6_addr,
+                               sizeof(struct in6_addr));
+                    }
+
+                    Rtt = deltaT(&t1, &t2);
+                    responseProbe = responseProbe + 1;
+                    if (probe == 0) {
+                        minRtt = Rtt;
+                        maxRtt = Rtt;
+                        averageRtt = Rtt;
+                        sumRtt = Rtt;
+                        sumOfSquare = Rtt * Rtt;
+                    } else {
+                        if (Rtt < minRtt)
+                            minRtt = Rtt;
+                        if (Rtt > maxRtt)
+                            maxRtt = Rtt;
+                        sumRtt = (sumRtt) + Rtt;
+                        averageRtt =
+                            round((double) (sumRtt) /
+                                  (double) responseProbe);
+                        sumOfSquare = sumOfSquare + Rtt * Rtt;
+                    }
+
+                    StorageResults->traceRouteResultsCurProbeCount =
+                        probe + 1;
+
+
+                    switch (i - 1) {
+                    case ICMP6_DST_UNREACH_NOPORT:
+                        ++got_there;
+                        break;
+
+                    case ICMP6_DST_UNREACH_NOROUTE:
+                        ++unreachable;
+                        Printf(" !N");
+                        break;
+                    case ICMP6_DST_UNREACH_ADDR:
+                        ++unreachable;
+                        Printf(" !H");
+                        break;
+
+                    case ICMP6_DST_UNREACH_ADMIN:
+                        ++unreachable;
+                        Printf(" !S");
+                        break;
+                    }
+                    break;
+                } else
+                    reset_timer = 0;
+            }
+            if (cc == 0) {
+                timep = 0;
+                time(&timep);
+                Printf(" *");
+                Rtt = (item->traceRouteCtlTimeOut) * 1000;
+            }
+
+            if (item->traceRouteCtlMaxRows != 0) {
 
-                temp = SNMP_MALLOC_STRUCT(traceRouteHopsTable_data);
-                temp->traceRouteCtlOwnerIndex =
-                    (char *) malloc(item->traceRouteCtlOwnerIndexLen + 1);
-                memcpy(temp->traceRouteCtlOwnerIndex,
+                temp_his =
+                    SNMP_MALLOC_STRUCT
+                    (traceRouteProbeHistoryTable_data);
+                temp_his->traceRouteCtlOwnerIndex =
+                    (char *) malloc(item->traceRouteCtlOwnerIndexLen +
+                                    1);
+                memcpy(temp_his->traceRouteCtlOwnerIndex,
                        item->traceRouteCtlOwnerIndex,
                        item->traceRouteCtlOwnerIndexLen + 1);
-                temp->traceRouteCtlOwnerIndex[item->
-                                              traceRouteCtlOwnerIndexLen] =
-                    '\0';
-                temp->traceRouteCtlOwnerIndexLen =
+                temp_his->traceRouteCtlOwnerIndex[item->
+                                                  traceRouteCtlOwnerIndexLen]
+                    = '\0';
+                temp_his->traceRouteCtlOwnerIndexLen =
                     item->traceRouteCtlOwnerIndexLen;
 
-                temp->traceRouteCtlTestName =
-                    (char *) malloc(item->traceRouteCtlTestNameLen + 1);
-                memcpy(temp->traceRouteCtlTestName,
+                temp_his->traceRouteCtlTestName =
+                    (char *) malloc(item->traceRouteCtlTestNameLen +
+                                    1);
+                memcpy(temp_his->traceRouteCtlTestName,
                        item->traceRouteCtlTestName,
                        item->traceRouteCtlTestNameLen + 1);
-                temp->traceRouteCtlTestName[item->
-                                            traceRouteCtlTestNameLen] =
-                    '\0';
-                temp->traceRouteCtlTestNameLen =
+                temp_his->traceRouteCtlTestName[item->
+                                                traceRouteCtlTestNameLen]
+                    = '\0';
+                temp_his->traceRouteCtlTestNameLen =
                     item->traceRouteCtlTestNameLen;
 
                 /* add lock to protect */
-                pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;
+                pthread_mutex_t counter_mutex =
+                    PTHREAD_MUTEX_INITIALIZER;
                 pthread_mutex_lock(&counter_mutex);
-                temp->traceRouteHopsHopIndex = ++index;
+                if (item->traceRouteProbeHistoryMaxIndex >=
+                    (unsigned long) (2147483647))
+                    item->traceRouteProbeHistoryMaxIndex = 0;
+                temp_his->traceRouteProbeHistoryIndex =
+                    ++(item->traceRouteProbeHistoryMaxIndex);
                 pthread_mutex_unlock(&counter_mutex);
                 /* endsadsadsad */
-
-
-                temp->traceRouteHopsIpTgtAddressType = 0;
-                temp->traceRouteHopsIpTgtAddress = strdup("");
-                temp->traceRouteHopsIpTgtAddressLen = 0;
-                temp->traceRouteHopsMinRtt = 0;
-                temp->traceRouteHopsMaxRtt = 0;
-                temp->traceRouteHopsAverageRtt = 0;
-                temp->traceRouteHopsRttSumOfSquares = 0;
-                temp->traceRouteHopsSentProbes = 0;
-                temp->traceRouteHopsProbeResponses = 0;
-
-                temp->traceRouteHopsLastGoodProbeLen = 0;
-                if (index == 1)
-                    item->traceRouteHops = temp;
+                temp_his->traceRouteProbeHistoryHopIndex = ttl;
+                temp_his->traceRouteProbeHistoryProbeIndex = probe + 1;
+
+                temp_his->traceRouteProbeHistoryHAddrType = 2;
+                temp_his->traceRouteProbeHistoryHAddr =
+                    (char *)
+                    malloc(strlen
+                           (inet_ntop
+                            (AF_INET6, &from.sin6_addr, pa, 64)) + 1);
+                temp_his->traceRouteProbeHistoryHAddr =
+                    strdup(inet_ntop
+                           (AF_INET6, &from.sin6_addr, pa, 64));
+                temp_his->
+                    traceRouteProbeHistoryHAddr[strlen
+                                                (inet_ntop
+                                                 (AF_INET6,
+                                                  &from.sin6_addr, pa,
+                                                  64))] = '\0';
+                temp_his->traceRouteProbeHistoryHAddrLen =
+                    strlen(inet_ntop
+                           (AF_INET6, &from.sin6_addr, pa, 64));
+
+                temp_his->traceRouteProbeHistoryResponse = Rtt;
+                temp_his->traceRouteProbeHistoryStatus = 1;
+                temp_his->traceRouteProbeHistoryLastRC = 0;
+
+                temp_his->traceRouteProbeHistoryTime_time = timep;
+                temp_his->traceRouteProbeHistoryTime = netsnmp_memdup(
+                                                                      date_n_time(&timep,
+                                                                                  &temp_his->traceRouteProbeHistoryTimeLen), 11);
+
+                if (probe == 0)
+                    item->traceRouteProbeHis = temp_his;
                 else {
-                    (current_temp)->next = temp;
+                    (current_temp_his)->next = temp_his;
                 }
 
-                current_temp = temp;
+                current_temp_his = temp_his;
 
-                if (index >= item->traceRouteCtlMaxTtl) {
-                    current_temp->next = NULL;
+                if (probe + 1 >= nprobes) {
+                    current_temp_his->next = NULL;
                 }
 
-                if (item->traceRouteHops != NULL)
+                if (item->traceRouteProbeHis != NULL) {
+                    if (traceRouteProbeHistoryTable_count(item) <
+                        item->traceRouteCtlMaxRows) {
+                        if (traceRouteProbeHistoryTable_add
+                            (current_temp_his) != SNMPERR_SUCCESS)
+                            DEBUGMSGTL(("traceRouteProbeHistoryTable",
+                                        "registered an entry error\n"));
+                    } else {
+                        traceRouteProbeHistoryTable_delLast(item);
+                        if (traceRouteProbeHistoryTable_add
+                            (current_temp_his) != SNMPERR_SUCCESS)
+                            DEBUGMSGTL(("traceRouteProbeHistoryTable",
+                                        "registered an entry error\n"));
 
-                    if (traceRouteHopsTable_add(current_temp) !=
-                        SNMPERR_SUCCESS)
-                        DEBUGMSGTL(("traceRouteHopsTable",
-                                    "registered an entry error\n"));
+                    }
+                }
 
             }
-
-            register unsigned long maxRtt = 0;
-            register unsigned long minRtt = 0;
-            register unsigned long averageRtt = 0;
-            register unsigned long sumRtt = 0;
-            register unsigned long responseProbe = 0;
-            register unsigned long sumOfSquare = 0;
-            for (probe = 0; probe < nprobes; ++probe) {
-                int             cc = 0, reset_timer = 0;
-                struct timeval  t1, t2;
-                struct timezone tz;
-                register unsigned long Rtt = 0;
-
-                gettimeofday(&t1, &tz);
-
-                send_probe_v6(++seq, ttl, sendbuff, ident, &tz, sndsock,
-                              datalen, &whereto, hostname);
-                reset_timer = 1;
-
-                while ((cc =
-                        wait_for_reply_v6(icmp_sock, &from, reset_timer,
-                                          waittime, icmp_sock,
-                                          packet)) != 0) {
-                    gettimeofday(&t2, &tz);
-                    timep = 0;
-                    time(&timep);
-                    if ((i =
-                         packet_ok_v6(packet, cc, &from, seq, &t1,
-                                      ident))) {
-                        reset_timer = 1;
-                        if (memcmp
-                            (&from.sin6_addr, &lastaddr,
-                             sizeof(struct in6_addr))) {
-
-                            memcpy(&lastaddr,
-                                   &from.sin6_addr,
-                                   sizeof(struct in6_addr));
-                        }
-
-                        Rtt = deltaT(&t1, &t2);
-                        responseProbe = responseProbe + 1;
-                        if (probe == 0) {
-                            minRtt = Rtt;
-                            maxRtt = Rtt;
-                            averageRtt = Rtt;
-                            sumRtt = Rtt;
-                            sumOfSquare = Rtt * Rtt;
-                        } else {
-                            if (Rtt < minRtt)
-                                minRtt = Rtt;
-                            if (Rtt > maxRtt)
-                                maxRtt = Rtt;
-                            sumRtt = (sumRtt) + Rtt;
-                            averageRtt =
-                                round((double) (sumRtt) /
-                                      (double) responseProbe);
-                            sumOfSquare = sumOfSquare + Rtt * Rtt;
-                        }
-
-                        StorageResults->traceRouteResultsCurProbeCount =
-                            probe + 1;
-
-
-                        switch (i - 1) {
-                        case ICMP6_DST_UNREACH_NOPORT:
-                            ++got_there;
-                            break;
-
-                        case ICMP6_DST_UNREACH_NOROUTE:
-                            ++unreachable;
-                            Printf(" !N");
-                            break;
-                        case ICMP6_DST_UNREACH_ADDR:
-                            ++unreachable;
-                            Printf(" !H");
-                            break;
-
-                        case ICMP6_DST_UNREACH_ADMIN:
-                            ++unreachable;
-                            Printf(" !S");
-                            break;
-                        }
-                        break;
-                    } else
-                        reset_timer = 0;
-                }
-                if (cc == 0) {
-                    timep = 0;
-                    time(&timep);
-                    Printf(" *");
-                    Rtt = (item->traceRouteCtlTimeOut) * 1000;
+            if (item->traceRouteCtlCreateHopsEntries == 1) {
+                netsnmp_variable_list *vars_hops = NULL;
+                snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);    /*  traceRouteCtlOwnerIndex  */
+                snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);        /*  traceRouteCtlTestName  */
+                snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_UNSIGNED, (char *) &index, sizeof(index));       /*  traceRouteHopsIndex  */
+                if ((current =
+                     header_complex_get(traceRouteHopsTableStorage,
+                                        vars_hops)) == NULL)
+                    goto out;
+                current->traceRouteHopsIpTgtAddressType = 2;
+                current->traceRouteHopsIpTgtAddress =
+                    (char *)
+                    malloc(strlen
+                           (inet_ntop
+                            (AF_INET6, &from.sin6_addr, pa, 64)) + 1);
+                current->traceRouteHopsIpTgtAddress =
+                    strdup(inet_ntop
+                           (AF_INET6, &from.sin6_addr, pa, 64));
+                current->
+                    traceRouteHopsIpTgtAddress[strlen
+                                               (inet_ntop
+                                                (AF_INET6,
+                                                 &from.sin6_addr, pa,
+                                                 64))] = '\0';
+
+                if (count != 0) {
+                    if (strcmp
+                        (old_HopsAddress[index - 1],
+                         current->traceRouteHopsIpTgtAddress) != 0)
+                        flag = 1;
                 }
 
-                if (item->traceRouteCtlMaxRows != 0) {
-
-                    temp_his =
-                        SNMP_MALLOC_STRUCT
-                        (traceRouteProbeHistoryTable_data);
-                    temp_his->traceRouteCtlOwnerIndex =
-                        (char *) malloc(item->traceRouteCtlOwnerIndexLen +
-                                        1);
-                    memcpy(temp_his->traceRouteCtlOwnerIndex,
-                           item->traceRouteCtlOwnerIndex,
-                           item->traceRouteCtlOwnerIndexLen + 1);
-                    temp_his->traceRouteCtlOwnerIndex[item->
-                                                      traceRouteCtlOwnerIndexLen]
-                        = '\0';
-                    temp_his->traceRouteCtlOwnerIndexLen =
-                        item->traceRouteCtlOwnerIndexLen;
-
-                    temp_his->traceRouteCtlTestName =
-                        (char *) malloc(item->traceRouteCtlTestNameLen +
-                                        1);
-                    memcpy(temp_his->traceRouteCtlTestName,
-                           item->traceRouteCtlTestName,
-                           item->traceRouteCtlTestNameLen + 1);
-                    temp_his->traceRouteCtlTestName[item->
-                                                    traceRouteCtlTestNameLen]
-                        = '\0';
-                    temp_his->traceRouteCtlTestNameLen =
-                        item->traceRouteCtlTestNameLen;
-
-                    /* add lock to protect */
-                    pthread_mutex_t counter_mutex =
-                        PTHREAD_MUTEX_INITIALIZER;
-                    pthread_mutex_lock(&counter_mutex);
-                    if (item->traceRouteProbeHistoryMaxIndex >=
-                        (unsigned long) (2147483647))
-                        item->traceRouteProbeHistoryMaxIndex = 0;
-                    temp_his->traceRouteProbeHistoryIndex =
-                        ++(item->traceRouteProbeHistoryMaxIndex);
-                    pthread_mutex_unlock(&counter_mutex);
-                    /* endsadsadsad */
-                    temp_his->traceRouteProbeHistoryHopIndex = ttl;
-                    temp_his->traceRouteProbeHistoryProbeIndex = probe + 1;
-
-                    temp_his->traceRouteProbeHistoryHAddrType = 2;
-                    temp_his->traceRouteProbeHistoryHAddr =
-                        (char *)
-                        malloc(strlen
-                               (inet_ntop
-                                (AF_INET6, &from.sin6_addr, pa, 64)) + 1);
-                    temp_his->traceRouteProbeHistoryHAddr =
-                        strdup(inet_ntop
-                               (AF_INET6, &from.sin6_addr, pa, 64));
-                    temp_his->
-                        traceRouteProbeHistoryHAddr[strlen
-                                                    (inet_ntop
-                                                     (AF_INET6,
-                                                      &from.sin6_addr, pa,
-                                                      64))] = '\0';
-                    temp_his->traceRouteProbeHistoryHAddrLen =
-                        strlen(inet_ntop
-                               (AF_INET6, &from.sin6_addr, pa, 64));
-
-                    temp_his->traceRouteProbeHistoryResponse = Rtt;
-                    temp_his->traceRouteProbeHistoryStatus = 1;
-                    temp_his->traceRouteProbeHistoryLastRC = 0;
-
-		    temp_his->traceRouteProbeHistoryTime_time = timep;
-                    temp_his->traceRouteProbeHistoryTime = netsnmp_memdup(
-                        date_n_time(&timep,
-			    &temp_his->traceRouteProbeHistoryTimeLen), 11);
-
-                    if (probe == 0)
-                        item->traceRouteProbeHis = temp_his;
-                    else {
-                        (current_temp_his)->next = temp_his;
-                    }
-
-                    current_temp_his = temp_his;
-
-                    if (probe + 1 >= nprobes) {
-                        current_temp_his->next = NULL;
-                    }
+                current->traceRouteHopsIpTgtAddressLen =
+                    strlen(inet_ntop
+                           (AF_INET6, &from.sin6_addr, pa, 64));
+                current->traceRouteHopsMinRtt = minRtt;
+                current->traceRouteHopsMaxRtt = maxRtt;
+                current->traceRouteHopsAverageRtt = averageRtt;
+                current->traceRouteHopsRttSumOfSquares = sumOfSquare;
+                current->traceRouteHopsSentProbes = probe + 1;
+                current->traceRouteHopsProbeResponses = responseProbe;
+                current->traceRouteHopsLastGoodProbe_time = timep;
+                current->traceRouteHopsLastGoodProbe = 
+                    netsnmp_memdup(date_n_time(&timep,
+                                               &current->traceRouteHopsLastGoodProbeLen), 11);
+
+                snmp_free_varbind(vars_hops);
+                vars_hops = NULL;
+            }
 
-                    if (item->traceRouteProbeHis != NULL) {
-                        if (traceRouteProbeHistoryTable_count(item) <
-                            item->traceRouteCtlMaxRows) {
-                            if (traceRouteProbeHistoryTable_add
-                                (current_temp_his) != SNMPERR_SUCCESS)
-                                DEBUGMSGTL(("traceRouteProbeHistoryTable",
-                                            "registered an entry error\n"));
-                        } else {
-                            traceRouteProbeHistoryTable_delLast(item);
-                            if (traceRouteProbeHistoryTable_add
-                                (current_temp_his) != SNMPERR_SUCCESS)
-                                DEBUGMSGTL(("traceRouteProbeHistoryTable",
-                                            "registered an entry error\n"));
 
-                        }
-		    }
+            (void) fflush(stdout);
+        }
+        putchar('\n');
 
-                }
-                if (item->traceRouteCtlCreateHopsEntries == 1) {
-                    netsnmp_variable_list *vars_hops = NULL;
-                    snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlOwnerIndex, item->traceRouteCtlOwnerIndexLen);    /*  traceRouteCtlOwnerIndex  */
-                    snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_OCTET_STR, (char *) item->traceRouteCtlTestName, item->traceRouteCtlTestNameLen);        /*  traceRouteCtlTestName  */
-                    snmp_varlist_add_variable(&vars_hops, NULL, 0, ASN_UNSIGNED, (char *) &index, sizeof(index));       /*  traceRouteHopsIndex  */
-                    if ((current =
-                         header_complex_get(traceRouteHopsTableStorage,
-                                            vars_hops)) == NULL)
-                        return;
-                    current->traceRouteHopsIpTgtAddressType = 2;
-                    current->traceRouteHopsIpTgtAddress =
-                        (char *)
-                        malloc(strlen
-                               (inet_ntop
-                                (AF_INET6, &from.sin6_addr, pa, 64)) + 1);
-                    current->traceRouteHopsIpTgtAddress =
-                        strdup(inet_ntop
-                               (AF_INET6, &from.sin6_addr, pa, 64));
-                    current->
-                        traceRouteHopsIpTgtAddress[strlen
-                                                   (inet_ntop
-                                                    (AF_INET6,
-                                                     &from.sin6_addr, pa,
-                                                     64))] = '\0';
-
-                    if (count != 0) {
-                        if (strcmp
-                            (old_HopsAddress[index - 1],
-                             current->traceRouteHopsIpTgtAddress) != 0)
-                            flag = 1;
-                    }
 
-                    current->traceRouteHopsIpTgtAddressLen =
-                        strlen(inet_ntop
-                               (AF_INET6, &from.sin6_addr, pa, 64));
-                    current->traceRouteHopsMinRtt = minRtt;
-                    current->traceRouteHopsMaxRtt = maxRtt;
-                    current->traceRouteHopsAverageRtt = averageRtt;
-                    current->traceRouteHopsRttSumOfSquares = sumOfSquare;
-                    current->traceRouteHopsSentProbes = probe + 1;
-                    current->traceRouteHopsProbeResponses = responseProbe;
-		    current->traceRouteHopsLastGoodProbe_time = timep;
-                    current->traceRouteHopsLastGoodProbe = 
-                        netsnmp_memdup(date_n_time(&timep,
-			    &current->traceRouteHopsLastGoodProbeLen), 11);
-
-                    snmp_free_varbind(vars_hops);
-                    vars_hops = NULL;
-                }
+        if (got_there || unreachable >= nprobes - 1) {
 
 
-                (void) fflush(stdout);
-            }
-            putchar('\n');
-
-
-            if (got_there || unreachable >= nprobes - 1) {
-
-
-                if (got_there != 0) {
-                    StorageResults->traceRouteResultsTestAttempts =
-                        StorageResults->traceRouteResultsTestAttempts + 1;
-
-                    StorageResults->traceRouteResultsTestSuccesses =
-                        StorageResults->traceRouteResultsTestSuccesses + 1;
-		    StorageResults->traceRouteResultsLastGoodPath_time = timep;
-                    StorageResults->traceRouteResultsLastGoodPath =
-                        netsnmp_memdup(date_n_time(&timep,
-                                                   &StorageResults->
-                                              traceRouteResultsLastGoodPathLen),
-                                       11);
-                    if ((item->
-                         traceRouteCtlTrapGeneration[0] &
-                         TRACEROUTETRAPGENERATION_TESTCOMPLETED) != 0) {
-                        printf("TEST completed!\n");
-                        send_traceRoute_trap(item, traceRouteTestCompleted,
-                                             sizeof
-                                             (traceRouteTestCompleted) /
-                                             sizeof(oid));
-                    }
-                }
+            if (got_there != 0) {
+                StorageResults->traceRouteResultsTestAttempts =
+                    StorageResults->traceRouteResultsTestAttempts + 1;
 
-                else {
-                    StorageResults->traceRouteResultsTestAttempts =
-                        StorageResults->traceRouteResultsTestAttempts + 1;
-                    if ((item->
-                         traceRouteCtlTrapGeneration[0] &
-                         TRACEROUTETRAPGENERATION_TESTFAILED) != 0) {
-                        printf("test Failed!\n");
-                        send_traceRoute_trap(item, traceRouteTestFailed,
-                                             sizeof(traceRouteTestFailed) /
-                                             sizeof(oid));
-                    }
+                StorageResults->traceRouteResultsTestSuccesses =
+                    StorageResults->traceRouteResultsTestSuccesses + 1;
+                StorageResults->traceRouteResultsLastGoodPath_time = timep;
+                StorageResults->traceRouteResultsLastGoodPath =
+                    netsnmp_memdup(date_n_time(&timep,
+                                               &StorageResults->
+                                               traceRouteResultsLastGoodPathLen),
+                                   11);
+                if ((item->
+                     traceRouteCtlTrapGeneration[0] &
+                     TRACEROUTETRAPGENERATION_TESTCOMPLETED) != 0) {
+                    printf("TEST completed!\n");
+                    send_traceRoute_trap(item, traceRouteTestCompleted,
+                                         sizeof
+                                         (traceRouteTestCompleted) /
+                                         sizeof(oid));
                 }
-                break;
+            }
 
-            } else if (ttl == item->traceRouteCtlMaxTtl
-                       && (probe + 1) == nprobes) {
+            else {
                 StorageResults->traceRouteResultsTestAttempts =
                     StorageResults->traceRouteResultsTestAttempts + 1;
-
                 if ((item->
                      traceRouteCtlTrapGeneration[0] &
                      TRACEROUTETRAPGENERATION_TESTFAILED) != 0) {
                     printf("test Failed!\n");
                     send_traceRoute_trap(item, traceRouteTestFailed,
-                                   sizeof(traceRouteTestFailed) /
-                                   sizeof(oid));
+                                         sizeof(traceRouteTestFailed) /
+                                         sizeof(oid));
                 }
             }
+            break;
 
+        } else if (ttl == item->traceRouteCtlMaxTtl
+                   && (probe + 1) == nprobes) {
+            StorageResults->traceRouteResultsTestAttempts =
+                StorageResults->traceRouteResultsTestAttempts + 1;
+
+            if ((item->
+                 traceRouteCtlTrapGeneration[0] &
+                 TRACEROUTETRAPGENERATION_TESTFAILED) != 0) {
+                printf("test Failed!\n");
+                send_traceRoute_trap(item, traceRouteTestFailed,
+                                     sizeof(traceRouteTestFailed) /
+                                     sizeof(oid));
+            }
         }
 
+    }
+
+    if (flag == 1) {
+        printf("path changed!\n");
+        send_traceRoute_trap(item, traceRoutePathChange,
+                             sizeof(traceRoutePathChange) /
+                             sizeof(oid));
+    }
+
+out:
+    for (k = 0; k < count; k++)
+        free(old_HopsAddress[k]);
+
+    free(sendbuff);
+    if (sndsock >= 0)
         close(sndsock);
+    if (icmp_sock >= 0)
+        close(icmp_sock);
+    free(hostname);
+}
 
-        if (flag == 1) {
-            printf("path changed!\n");
-            send_traceRoute_trap(item, traceRoutePathChange,
-                                 sizeof(traceRoutePathChange) /
-                                 sizeof(oid));
-        }
+void
+run_traceRoute(unsigned int clientreg, void *clientarg)
+{
+    struct traceRouteCtlTable_data *item = clientarg;
 
-        int             k = 0;
-        for (k = 0; k < count; k++) {
-            free(old_HopsAddress[k]);
-            old_HopsAddress[k] = NULL;
-        }
+    if (item->traceRouteCtlInitialTtl > item->traceRouteCtlMaxTtl) {
+        DEBUGMSGTL(("traceRouteCtlTable",
+                    "first ttl (%lu) may not be greater than max ttl (%lu)\n",
+                    item->traceRouteCtlInitialTtl,
+                    item->traceRouteCtlMaxTtl));
+        return;
+    }
 
+    switch (item->traceRouteCtlTargetAddressType) {
+    case 1:
+    case 16:
+        run_traceRoute_ipv4(item);
+        break;
+    case 2:
+        run_traceRoute_ipv6(item);
+        break;
     }
-    return;
 }
 
-
 int
-wait_for_reply(register int sock, register struct sockaddr_in *fromp,
-               register const struct timeval *tp, u_char * packet,
+wait_for_reply(int sock, struct sockaddr_in *fromp,
+               const struct timeval *tp, u_char * packet,
                int waittime)
 {
     fd_set          fds;
     struct timeval  now, wait;
     struct timezone tz;
-    register int    cc = 0;
+    int    cc = 0;
     socklen_t       fromlen = sizeof(*fromp);
 
     FD_ZERO(&fds);
@@ -5646,14 +5689,14 @@ struct udpiphdr {
 #define ui_len ui_i.tot_len
 
 void
-send_probe(struct sockaddr_in *whereto, register int seq, int ttl,
-           register struct timeval *tp, register struct ip *outip,
-           register struct udphdr *outudp, int packlen, int optlen,
+send_probe(struct sockaddr_in *whereto, int seq, int ttl,
+           struct timeval *tp, struct ip *outip,
+           struct udphdr *outudp, int packlen, int optlen,
            char *hostname, u_short ident, int sndsock, u_short port,
            struct outdata *outdata)
 {
-    register int    cc = 0;
-    register struct udpiphdr *ui = NULL, *oui = NULL;
+    int    cc = 0;
+    struct udpiphdr *ui = NULL, *oui = NULL;
     struct ip       tip;
 
     outip->ip_ttl = ttl;
@@ -5783,7 +5826,7 @@ send_probe_v6(int seq, int ttl, char *sendbuff, pid_t ident,
 unsigned long
 deltaT(struct timeval *t1p, struct timeval *t2p)
 {
-    register unsigned long dt;
+    unsigned long dt;
 
     dt = (unsigned long) ((long) (t2p->tv_sec - t1p->tv_sec) * 1000 +
                           (long) (t2p->tv_usec - t1p->tv_usec) / 1000);
@@ -5792,14 +5835,14 @@ deltaT(struct timeval *t1p, struct timeval *t2p)
 
 
 int
-packet_ok(register u_char * buf, int cc, register struct sockaddr_in *from,
-          register int seq, u_short ident, int pmtu, u_short port)
+packet_ok(u_char * buf, int cc, struct sockaddr_in *from,
+          int seq, u_short ident, int pmtu, u_short port)
 {
-    register struct icmp *icp = NULL;
-    register u_char type, code;
-    register int    hlen = 0;
+    struct icmp *icp = NULL;
+    u_char type, code;
+    int    hlen = 0;
 #ifndef ARCHAIC
-    register struct ip *ip = NULL;
+    struct ip *ip = NULL;
 
     ip = (struct ip *) buf;
     hlen = ip->ip_hl << 2;
@@ -5828,8 +5871,8 @@ packet_ok(register u_char * buf, int cc, register struct sockaddr_in *from,
     }
     if ((type == ICMP_TIMXCEED && code == ICMP_TIMXCEED_INTRANS) ||
         type == ICMP_UNREACH || type == ICMP_ECHOREPLY) {
-        register struct ip *hip;
-        register struct udphdr *up;
+        struct ip *hip;
+        struct udphdr *up;
 
         hip = &icp->icmp_ip;
         hlen = hip->ip_hl << 2;
@@ -5898,12 +5941,12 @@ packet_ok_v6(u_char * buf, int cc, struct sockaddr_in6 *from, int seq,
  */
 
 u_short
-in_checksum(register u_short * addr, register int len)
+in_checksum(u_short * addr, int len)
 {
-    register int    nleft = len;
-    register u_short *w = addr;
-    register u_short answer;
-    register int    sum = 0;
+    int    nleft = len;
+    u_short *w = addr;
+    u_short answer;
+    int    sum = 0;
 
     /*
      *  Our algorithm is simple, using a 32 bit accumulator (sum),
@@ -5936,7 +5979,7 @@ in_checksum(register u_short * addr, register int len)
  * Out is assumed to be >= in.
  */
 void
-tvsub(register struct timeval *out, register struct timeval *in)
+tvsub(struct timeval *out, struct timeval *in)
 {
 
     if ((out->tv_usec -= in->tv_usec) < 0) {
@@ -5948,13 +5991,13 @@ tvsub(register struct timeval *out, register struct timeval *in)
 
 
 struct hostinfo *
-gethostinfo(register char *hostname)
+gethostinfo(char *hostname)
 {
-    register int    n;
-    register struct hostent *hp = NULL;
-    register struct hostinfo *hi = NULL;
-    register char **p = NULL;
-    register u_int32_t addr, *ap = NULL;
+    int    n;
+    struct hostent *hp = NULL;
+    struct hostinfo *hi = NULL;
+    char **p = NULL;
+    u_int32_t addr, *ap = NULL;
 
     if (strlen(hostname) > 64) {
         Fprintf(stderr, "%s: hostname \"%.32s...\" is too long\n",
@@ -6004,7 +6047,7 @@ gethostinfo(register char *hostname)
 }
 
 void
-freehostinfo(register struct hostinfo *hi)
+freehostinfo(struct hostinfo *hi)
 {
     if (hi->name != NULL) {
         free(hi->name);
@@ -6015,7 +6058,7 @@ freehostinfo(register struct hostinfo *hi)
 }
 
 void
-setsin(register struct sockaddr_in *sin, register u_int32_t addr)
+setsin(struct sockaddr_in *sin, u_int32_t addr)
 {
 
     memset(sin, 0, sizeof(*sin));
@@ -6031,12 +6074,12 @@ setsin(register struct sockaddr_in *sin, register u_int32_t addr)
  * Return the source address for the given destination address
  */
 const char     *
-findsaddr(register const struct sockaddr_in *to,
-          register struct sockaddr_in *from)
+findsaddr(const struct sockaddr_in *to,
+          struct sockaddr_in *from)
 {
-    register int    i, n;
-    register FILE  *f;
-    register u_int32_t mask;
+    int    i, n;
+    FILE  *f;
+    u_int32_t mask;
     u_int32_t       dest, tmask;
     struct ifaddrlist *al;
     char            buf[256], tdevice[256], device[256];
@@ -6059,8 +6102,10 @@ findsaddr(register const struct sockaddr_in *to,
         if (n == 1 && strncmp(buf, "Iface", 5) == 0)
             continue;
         if ((i = sscanf(buf, "%s %x %*s %*s %*s %*s %*s %x",
-                        tdevice, &dest, &tmask)) != 3)
-            return ("junk in buffer");
+                        tdevice, &dest, &tmask)) != 3) {
+            fclose(f);
+            return "junk in buffer";
+        }
         if ((to->sin_addr.s_addr & tmask) == dest &&
             (tmask > mask || mask == 0)) {
             mask = tmask;
@@ -6097,15 +6142,15 @@ findsaddr(register const struct sockaddr_in *to,
 }
 
 int
-ifaddrlist(register struct ifaddrlist **ipaddrp, register char *errbuf)
+ifaddrlist(struct ifaddrlist **ipaddrp, char *errbuf)
 {
-    register int    fd, nipaddr;
+    int    fd, nipaddr;
 #ifdef HAVE_SOCKADDR_SA_LEN
-    register int    n;
+    int    n;
 #endif
-    register struct ifreq *ifrp, *ifend, *ifnext;
-    register struct sockaddr_in *sin;
-    register struct ifaddrlist *al;
+    struct ifreq *ifrp, *ifend, *ifnext;
+    struct sockaddr_in *sin;
+    struct ifaddrlist *al;
     struct ifconf   ifc;
     struct ifreq    ibuf[(32 * 1024) / sizeof(struct ifreq)], ifr;
 #define MAX_IPADDR (sizeof(ibuf) / sizeof(ibuf[0]))
diff --git a/agent/mibgroup/disman/traceroute/traceRouteCtlTable.h b/agent/mibgroup/disman/traceroute/traceRouteCtlTable.h
index 0711978..2fdab7a 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteCtlTable.h
+++ b/agent/mibgroup/disman/traceroute/traceRouteCtlTable.h
@@ -580,7 +580,6 @@ void            freehostinfo(struct hostinfo *);
 void            getaddr(u_int32_t *, char *);
 struct hostinfo *gethostinfo(char *);
 u_short         in_checksum(u_short *, int);
-char           *inetname(struct in_addr);
 void            run_traceRoute(unsigned int, void *);
 int             packet_ok(u_char *, int, struct sockaddr_in *, int,
                           u_short, int, u_short);
diff --git a/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c b/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c
index 763757d..19d9211 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c
+++ b/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c
@@ -61,41 +61,30 @@ struct variable2 traceRouteHopsTable_variables[] = {
 };
 
 
-
-
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-
-extern struct header_complex_index *traceRouteCtlTableStorage;
-extern struct header_complex_index *traceRouteHopsTableStorage;
 void
 traceRouteHopsTable_inadd(struct traceRouteHopsTable_data *thedata);
 
 void
 traceRouteHopsTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr = NULL;
-    struct traceRouteHopsTable_data *StorageDel = NULL;
+    struct header_complex_index *hciptr, *nhciptr;
+    struct traceRouteHopsTable_data *StorageDel;
+
     DEBUGMSGTL(("traceRouteHopsTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
-        StorageDel =
-            header_complex_extract_entry(&traceRouteHopsTableStorage,
-                                         hciptr);
+    for (hciptr = thestuff; hciptr; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
+        StorageDel = header_complex_extract_entry(&traceRouteHopsTableStorage,
+                                                  hciptr);
         if (StorageDel != NULL) {
             free(StorageDel->traceRouteCtlOwnerIndex);
-            StorageDel->traceRouteCtlOwnerIndex = NULL;
             free(StorageDel->traceRouteCtlTestName);
-            StorageDel->traceRouteCtlTestName = NULL;
             free(StorageDel->traceRouteHopsLastGoodProbe);
-            StorageDel->traceRouteHopsLastGoodProbe = NULL;
             free(StorageDel);
-            StorageDel = NULL;
         }
         DEBUGMSGTL(("traceRouteHopsTable", "cleaner  "));
     }
-
 }
+
 void
 init_traceRouteHopsTable(void)
 {
@@ -151,6 +140,7 @@ parse_traceRouteHopsTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlOwnerIndexLen);
     if (StorageTmp->traceRouteCtlOwnerIndex == NULL) {
         config_perror("invalid specification for traceRouteCtlOwnerIndex");
+        free(StorageTmp);
         return;
     }
 
@@ -160,6 +150,7 @@ parse_traceRouteHopsTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlTestNameLen);
     if (StorageTmp->traceRouteCtlTestName == NULL) {
         config_perror("invalid specification for traceRouteCtlTestName");
+        free(StorageTmp);
         return;
     }
 
@@ -178,6 +169,7 @@ parse_traceRouteHopsTable(const char *token, char *line)
     if (StorageTmp->traceRouteHopsIpTgtAddress == NULL) {
         config_perror
             ("invalid specification for traceRouteHopsIpTgtAddress");
+        free(StorageTmp);
         return;
     }
 
@@ -211,6 +203,7 @@ parse_traceRouteHopsTable(const char *token, char *line)
     if (StorageTmp->traceRouteHopsLastGoodProbe == NULL) {
         config_perror
             ("invalid specification for traceRouteHopsLastGoodProbe");
+        free(StorageTmp);
         return;
     }
 
diff --git a/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c b/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c
index 0b410c5..70107e9 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c
+++ b/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c
@@ -54,12 +54,6 @@ struct variable2 traceRouteProbeHistoryTable_variables[] = {
 };
 
 
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-
-extern struct header_complex_index *traceRouteCtlTableStorage;
-extern struct header_complex_index *traceRouteProbeHistoryTableStorage;
 void
 traceRouteProbeHistoryTable_inadd(struct traceRouteProbeHistoryTable_data
                                   *thedata);
@@ -67,29 +61,25 @@ traceRouteProbeHistoryTable_inadd(struct traceRouteProbeHistoryTable_data
 void
 traceRouteProbeHistoryTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr = NULL;
-    struct traceRouteProbeHistoryTable_data *StorageDel = NULL;
+    struct header_complex_index *hciptr, *nhciptr;
+    struct traceRouteProbeHistoryTable_data *StorageDel;
+
     DEBUGMSGTL(("traceRouteProbeHistoryTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
-        StorageDel =
-            header_complex_extract_entry
+    for (hciptr = thestuff; hciptr != NULL; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
+        StorageDel = header_complex_extract_entry
             (&traceRouteProbeHistoryTableStorage, hciptr);
         if (StorageDel != NULL) {
             free(StorageDel->traceRouteCtlOwnerIndex);
-            StorageDel->traceRouteCtlOwnerIndex = NULL;
             free(StorageDel->traceRouteCtlTestName);
-            StorageDel->traceRouteCtlTestName = NULL;
             free(StorageDel->traceRouteProbeHistoryHAddr);
-            StorageDel->traceRouteProbeHistoryHAddr = NULL;
             free(StorageDel->traceRouteProbeHistoryTime);
-            StorageDel->traceRouteProbeHistoryTime = NULL;
             free(StorageDel);
-            StorageDel = NULL;
         }
         DEBUGMSGTL(("traceRouteProbeHistoryTable", "cleaner  "));
     }
-
 }
+
 void
 init_traceRouteProbeHistoryTable(void)
 {
@@ -147,6 +137,7 @@ parse_traceRouteProbeHistoryTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlOwnerIndexLen);
     if (StorageTmp->traceRouteCtlOwnerIndex == NULL) {
         config_perror("invalid specification for traceRouteCtlOwnerIndex");
+        free(StorageTmp);
         return;
     }
 
@@ -156,6 +147,7 @@ parse_traceRouteProbeHistoryTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlTestNameLen);
     if (StorageTmp->traceRouteCtlTestName == NULL) {
         config_perror("invalid specification for traceRouteCtlTestName");
+        free(StorageTmp);
         return;
     }
 
@@ -182,6 +174,7 @@ parse_traceRouteProbeHistoryTable(const char *token, char *line)
     if (StorageTmp->traceRouteProbeHistoryHAddr == NULL) {
         config_perror
             ("invalid specification for traceRouteProbeHistoryHAddr");
+        free(StorageTmp);
         return;
     }
 
@@ -204,6 +197,7 @@ parse_traceRouteProbeHistoryTable(const char *token, char *line)
     if (StorageTmp->traceRouteProbeHistoryTime == NULL) {
         config_perror
             ("invalid specification for traceRouteProbeHistoryTime");
+        free(StorageTmp);
         return;
     }
 
diff --git a/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c b/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c
index aba6cf1..f2265dc 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c
+++ b/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c
@@ -71,42 +71,30 @@ struct variable2 traceRouteResultsTable_variables[] = {
 };
 
 
-
-/*
- * global storage of our data, saved in and configured by header_complex() 
- */
-
-extern struct header_complex_index *traceRouteCtlTableStorage;
-extern struct header_complex_index *traceRouteResultsTableStorage;
 void
 traceRouteResultsTable_inadd(struct traceRouteResultsTable_data *thedata);
 
 void
 traceRouteResultsTable_cleaner(struct header_complex_index *thestuff)
 {
-    struct header_complex_index *hciptr = NULL;
-    struct traceRouteResultsTable_data *StorageDel = NULL;
+    struct header_complex_index *hciptr, *nhciptr;
+    struct traceRouteResultsTable_data *StorageDel;
+
     DEBUGMSGTL(("traceRouteResultsTable", "cleanerout  "));
-    for (hciptr = thestuff; hciptr != NULL; hciptr = hciptr->next) {
+    for (hciptr = thestuff; hciptr; hciptr = nhciptr) {
+        nhciptr = hciptr->next;
         StorageDel =
             header_complex_extract_entry(&traceRouteResultsTableStorage,
                                          hciptr);
         if (StorageDel != NULL) {
             free(StorageDel->traceRouteCtlOwnerIndex);
-            StorageDel->traceRouteCtlOwnerIndex = NULL;
             free(StorageDel->traceRouteCtlTestName);
-            StorageDel->traceRouteCtlTestName = NULL;
             free(StorageDel->traceRouteResultsIpTgtAddr);
-            StorageDel->traceRouteResultsIpTgtAddr = NULL;
             free(StorageDel->traceRouteResultsLastGoodPath);
-            StorageDel->traceRouteResultsLastGoodPath = NULL;
             free(StorageDel);
-            StorageDel = NULL;
-
         }
         DEBUGMSGTL(("traceRouteResultsTable", "cleaner  "));
     }
-
 }
 
 void
@@ -166,6 +154,7 @@ parse_traceRouteResultsTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlOwnerIndexLen);
     if (StorageTmp->traceRouteCtlOwnerIndex == NULL) {
         config_perror("invalid specification for traceRouteCtlOwnerIndex");
+        free(StorageTmp);
         return;
     }
 
@@ -175,6 +164,7 @@ parse_traceRouteResultsTable(const char *token, char *line)
                               &StorageTmp->traceRouteCtlTestNameLen);
     if (StorageTmp->traceRouteCtlTestName == NULL) {
         config_perror("invalid specification for traceRouteCtlTestName");
+        free(StorageTmp);
         return;
     }
 
@@ -201,6 +191,7 @@ parse_traceRouteResultsTable(const char *token, char *line)
     if (StorageTmp->traceRouteResultsIpTgtAddr == NULL) {
         config_perror
             ("invalid specification for traceRouteResultsIpTgtAddr");
+        free(StorageTmp);
         return;
     }
 
@@ -220,6 +211,7 @@ parse_traceRouteResultsTable(const char *token, char *line)
     if (StorageTmp->traceRouteResultsLastGoodPath == NULL) {
         config_perror
             ("invalid specification for traceRouteResultsLastGoodPath!");
+        free(StorageTmp);
         return;
     }
 
diff --git a/agent/mibgroup/disman/traceroute/traceRouteResultsTable.h b/agent/mibgroup/disman/traceroute/traceRouteResultsTable.h
index f31ffbf..6a42c87 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteResultsTable.h
+++ b/agent/mibgroup/disman/traceroute/traceRouteResultsTable.h
@@ -17,6 +17,11 @@
 
 config_require(header_complex);
 
+extern struct header_complex_index *traceRouteCtlTableStorage;
+extern struct header_complex_index *traceRouteResultsTableStorage;
+extern struct header_complex_index *traceRouteProbeHistoryTableStorage;
+extern struct header_complex_index *traceRouteHopsTableStorage;
+
 /*
  * function declarations 
  */
diff --git a/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c b/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c
index 6eb69f7..97d00f4 100644
--- a/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c
+++ b/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c
@@ -154,7 +154,7 @@ struct rtnl_handle {
 
 struct ifstat_ent {
     struct ifstat_ent *next;
-    const char *name;
+    char *name;
     int ifindex;
     struct rtnl_link_stats stats;
 };
@@ -465,6 +465,7 @@ _dot3Stats_netlink_get_errorcntrs(dot3StatsTable_rowreq_ctx *rowreq_ctx, const c
             done = 1;
         }
         kern_db = ke->next;
+        free(ke->name);
         free(ke);
     }
 
diff --git a/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c b/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c
index 74f33bf..be29e72 100644
--- a/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c
+++ b/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c
@@ -286,6 +286,7 @@ dot3StatsTable_container_load(netsnmp_container * container)
         rowreq_ctx = dot3StatsTable_allocate_rowreq_ctx(NULL);
         if (NULL == rowreq_ctx) {
             snmp_log(LOG_ERR, "memory allocation for dot3StatsTable failed\n");
+            dot3stats_interface_name_list_free(list_head);
             close(fd);
             return MFD_RESOURCE_UNAVAILABLE;
         }
diff --git a/agent/mibgroup/examples/example.c b/agent/mibgroup/examples/example.c
index dd97daf..a6d754d 100644
--- a/agent/mibgroup/examples/example.c
+++ b/agent/mibgroup/examples/example.c
@@ -719,7 +719,7 @@ write_exampletrap2(int action,
         var_obj.name = example_string_oid;
         var_obj.name_length = sizeof(example_string_oid) / sizeof(oid); /* number of sub-ids */
         var_obj.type = ASN_OCTET_STR;   /* type of variable */
-        var_obj.val.string = (unsigned char *) example_str;       /* value */
+        var_obj.val.string = (u_char *)example_str;       /* value */
         var_obj.val_len = strlen(example_str);
         DEBUGMSGTL(("example", "write_exampletrap2 sending the v2 trap\n"));
         send_v2trap(&var_trap);
diff --git a/agent/mibgroup/examples/netSnmpHostsTable.c b/agent/mibgroup/examples/netSnmpHostsTable.c
index 8ea2d03..9033a54 100644
--- a/agent/mibgroup/examples/netSnmpHostsTable.c
+++ b/agent/mibgroup/examples/netSnmpHostsTable.c
@@ -65,6 +65,8 @@ initialize_table_netSnmpHostsTable(void)
     if (!my_handler || !table_info || !iinfo) {
         snmp_log(LOG_ERR,
                  "malloc failed in initialize_table_netSnmpHostsTable");
+        free(iinfo);
+        free(table_info);
         return; /** Serious error. */
     }
 
diff --git a/agent/mibgroup/examples/netSnmpHostsTable_access.c b/agent/mibgroup/examples/netSnmpHostsTable_access.c
index 3d2e5fb..d72d10f 100644
--- a/agent/mibgroup/examples/netSnmpHostsTable_access.c
+++ b/agent/mibgroup/examples/netSnmpHostsTable_access.c
@@ -225,8 +225,10 @@ netSnmpHostsTable_commit_row(void **my_data_context, int new_or_del)
     if ((out = fopen(HOSTS_FILE ".snmp", "w")) == NULL)
         return SNMP_ERR_COMMITFAILED;
     
-    if ((in = fopen(HOSTS_FILE, "r")) == NULL)
+    if ((in = fopen(HOSTS_FILE, "r")) == NULL) {
+        fclose(out);
         return SNMP_ERR_COMMITFAILED;
+    }
 
     while(fgets(line, sizeof(line), in)) {
         copy_nword(line,myaddr,sizeof(myaddr));
diff --git a/agent/mibgroup/examples/netSnmpHostsTable_checkfns_local.c b/agent/mibgroup/examples/netSnmpHostsTable_checkfns_local.c
index a29360d..78c9939 100644
--- a/agent/mibgroup/examples/netSnmpHostsTable_checkfns_local.c
+++ b/agent/mibgroup/examples/netSnmpHostsTable_checkfns_local.c
@@ -10,6 +10,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include "netSnmpHostsTable_checkfns.h"
 #include "netSnmpHostsTable_enums.h"
+#include "netSnmpHostsTable_checkfns_local.h"
 
 /** Decides if an incoming value for the netSnmpHostAddressType mib node is legal, from a local implementation specific viewpoint.
  *  @param type    The incoming data type.
diff --git a/agent/mibgroup/examples/ucdDemoPublic.c b/agent/mibgroup/examples/ucdDemoPublic.c
index 8e9e66a..be11ad7 100644
--- a/agent/mibgroup/examples/ucdDemoPublic.c
+++ b/agent/mibgroup/examples/ucdDemoPublic.c
@@ -107,11 +107,11 @@ var_ucdDemoPublic(struct variable *vp,
     static char     string[MYMAX + 1], *cp;
     int             i;
 
-    *write_method = 0;          /* assume it isnt writable for the time being */
+    *write_method = NULL;       /* assume it isnt writable for the time being */
     *var_len = sizeof(long_ret);        /* assume an integer and change later if not */
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
-        return 0;
+        return NULL;
 
     /*
      * this is where we do the value assignments for the mib results. 
@@ -146,7 +146,7 @@ var_ucdDemoPublic(struct variable *vp,
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ucdDemoPublic\n",
                     vp->magic));
     }
-    return 0;
+    return NULL;
 }
 
 int
diff --git a/agent/mibgroup/hardware/cpu/cpu.c b/agent/mibgroup/hardware/cpu/cpu.c
index 2772001..4d4fa83 100644
--- a/agent/mibgroup/hardware/cpu/cpu.c
+++ b/agent/mibgroup/hardware/cpu/cpu.c
@@ -3,6 +3,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/cpu.h>
+#include "cpu.h"
 
 netsnmp_feature_child_of(hardware_cpu, libnetsnmpmibs)
 
@@ -11,7 +12,6 @@ netsnmp_feature_child_of(hardware_cpu_load, hardware_cpu)
 netsnmp_feature_child_of(hardware_cpu_get_cache, hardware_cpu)
 netsnmp_feature_child_of(hardware_cpu_get_byName, hardware_cpu)
 
-extern NetsnmpCacheLoad netsnmp_cpu_arch_load;
 static void _cpu_update_stats( unsigned int, void* );
 
 static int _cpuAutoUpdate =  5;
diff --git a/agent/mibgroup/hardware/cpu/cpu_linux.c b/agent/mibgroup/hardware/cpu/cpu_linux.c
index b1dc308..06d8a4d 100644
--- a/agent/mibgroup/hardware/cpu/cpu_linux.c
+++ b/agent/mibgroup/hardware/cpu/cpu_linux.c
@@ -2,6 +2,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/cpu.h>
+#include "cpu_linux.h"
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -53,7 +54,7 @@ void init_cpu_linux( void ) {
             cpu->status = 2;  /* running */
             sprintf( cpu->name, "cpu%d", i );
 #if defined(__s390__) || defined(__s390x__)
-            strcat( cpu->descr, "An S/390 CPU" );
+            strlcat(cpu->descr, "An S/390 CPU", sizeof(cpu->descr));
 #endif
         }
 #if defined(__s390__) || defined(__s390x__)
@@ -63,8 +64,8 @@ void init_cpu_linux( void ) {
                 n++;
                 cpu = netsnmp_cpu_get_byIdx( i, 1 );
                 cpu->status = 2;  /* running */
-                sprintf( cpu->name, "cpu%d", i );
-                strcat( cpu->descr, "An S/390 CPU" );
+                sprintf(cpu->name, "cpu%d", i);
+                strlcat(cpu->descr, "An S/390 CPU", sizeof(cpu->descr));
             }
         }
 #endif
@@ -80,7 +81,7 @@ void init_cpu_linux( void ) {
 #ifdef DESCR2_FIELD
         if (!strncmp( buf, DESCR2_FIELD, strlen(DESCR2_FIELD))) {
             cp = strchr( buf, ':' );
-            strcat( cpu->descr, cp );
+            strlcat(cpu->descr, cp, sizeof(cpu->descr));
             cp = strchr( cpu->descr, '\n' );
             *cp = 0;
         }
@@ -114,6 +115,9 @@ int netsnmp_cpu_arch_load( netsnmp_cache *cache, void *magic ) {
     if (bsize == 0) {
         bsize = getpagesize()-1;
         buff = (char*)malloc(bsize+1);
+        if (buff == NULL) {
+            return -1;
+        }
     }
     while ((bytes_read = read(statfd, buff, bsize)) == bsize) {
         bsize += BUFSIZ;
@@ -332,4 +336,3 @@ void _cpu_load_swap_etc( char *buff, netsnmp_cpu_info *cpu ) {
     }
     first = 0;
 }
-
diff --git a/agent/mibgroup/hardware/cpu/cpu_sysctl.c b/agent/mibgroup/hardware/cpu/cpu_sysctl.c
index 5ecb68e..386984a 100644
--- a/agent/mibgroup/hardware/cpu/cpu_sysctl.c
+++ b/agent/mibgroup/hardware/cpu/cpu_sysctl.c
@@ -30,6 +30,9 @@
 #ifdef HAVE_VM_VM_EXTERN_H
 #include <vm/vm_extern.h>
 #endif
+#ifdef HAVE_UVM_UVM_EXTERN_H
+#include <uvm/uvm_extern.h>
+#endif
 
 netsnmp_feature_require(hardware_cpu_copy_stats)
 
@@ -85,7 +88,7 @@ void init_cpu_sysctl( void ) {
 #elif defined(KERN_CPTIME2)                /* OpenBSD */
 #define NETSNMP_KERN_CPU  KERN_CPTIME
 #define NETSNMP_KERN_MCPU
-#define NETSNMP_KERN_MCPU_TYPE u_int64_t
+#define NETSNMP_KERN_MCPU_TYPE NETSNMP_CPU_STATS
 #elif defined(KERN_CPTIME)                /* OpenBSD */
 #define NETSNMP_KERN_CPU  KERN_CPTIME
 
diff --git a/agent/mibgroup/hardware/fsys/fsys_getfsstats.c b/agent/mibgroup/hardware/fsys/fsys_getfsstats.c
index 05027f4..dbeb1f6 100644
--- a/agent/mibgroup/hardware/fsys/fsys_getfsstats.c
+++ b/agent/mibgroup/hardware/fsys/fsys_getfsstats.c
@@ -3,6 +3,7 @@
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/fsys.h>
 #include "hardware/fsys/hw_fsys.h"
+#include "hardware/fsys/hw_fsys_private.h"
 
 #if HAVE_SYS_PARAM_H
 #include <sys/param.h>
@@ -67,6 +68,8 @@ _fs_type( char *typename )
        return NETSNMP_FS_TYPE_NTFS;
     else if ( !strcmp(typename, MOUNT_ZFS) )
        return NETSNMP_FS_TYPE_OTHER;
+    else if ( !strcmp(typename, MOUNT_NVMFS) )
+       return NETSNMP_FS_TYPE_OTHER;
     else if ( !strcmp(typename, MOUNT_ACFS) )
        return NETSNMP_FS_TYPE_OTHER;
 
diff --git a/agent/mibgroup/hardware/fsys/fsys_mntent.c b/agent/mibgroup/hardware/fsys/fsys_mntent.c
index 94d23db..c00b961 100644
--- a/agent/mibgroup/hardware/fsys/fsys_mntent.c
+++ b/agent/mibgroup/hardware/fsys/fsys_mntent.c
@@ -2,6 +2,8 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/fsys.h>
+#include "hw_fsys.h"
+#include "hardware/fsys/hw_fsys_private.h"
 
 #include <stdio.h>
 #if HAVE_MNTENT_H
@@ -142,6 +144,7 @@ _fsys_type( char *typename )
               !strcmp(typename, MNTTYPE_SIMFS) ||
               !strcmp(typename, MNTTYPE_BTRFS) ||
               !strcmp(typename, MNTTYPE_ZFS) ||
+              !strcmp(typename, MNTTYPE_NVMFS) ||
               !strcmp(typename, MNTTYPE_ACFS) ||
               !strcmp(typename, MNTTYPE_LOFS))
        return NETSNMP_FS_TYPE_OTHER;
@@ -209,6 +212,8 @@ netsnmp_fsys_arch_load( void )
 #if HAVE_HASMNTOPT
         if (hasmntopt( m, "ro" ))
             entry->flags |= NETSNMP_FS_FLAG_RONLY;
+        else
+            entry->flags &= ~NETSNMP_FS_FLAG_RONLY;
 #endif
         /*
          *  The root device is presumably bootable.
@@ -240,6 +245,13 @@ netsnmp_fsys_arch_load( void )
         {
             snprintf( tmpbuf, sizeof(tmpbuf), "Cannot statfs %s", entry->path );
             snmp_log_perror( tmpbuf );
+            entry->units = stat_buf.NSFS_SIZE;
+            entry->size  = 0;
+            entry->used  = 0;
+            entry->avail = 0;
+            entry->inums_total = stat_buf.f_files;
+            entry->inums_avail = stat_buf.f_ffree;
+            netsnmp_fsys_calculate32(entry);
             continue;
         }
         entry->units =  stat_buf.NSFS_SIZE;
@@ -259,4 +271,3 @@ netsnmp_fsys_arch_load( void )
     }
     fclose( fp );
 }
-
diff --git a/agent/mibgroup/hardware/fsys/hw_fsys.c b/agent/mibgroup/hardware/fsys/hw_fsys.c
index a6cd94d..4fe0fff 100644
--- a/agent/mibgroup/hardware/fsys/hw_fsys.c
+++ b/agent/mibgroup/hardware/fsys/hw_fsys.c
@@ -3,14 +3,14 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/fsys.h>
+#include "hw_fsys.h"
+#include "hardware/fsys/hw_fsys_private.h"
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 
 netsnmp_feature_child_of(hw_fsys_get_container, netsnmp_unused)
 
-extern void             netsnmp_fsys_arch_load( void );
-extern void             netsnmp_fsys_arch_init( void );
 static int  _fsys_load( void );
 static void _fsys_free( void );
 
diff --git a/agent/mibgroup/hardware/fsys/hw_fsys_private.h b/agent/mibgroup/hardware/fsys/hw_fsys_private.h
new file mode 100644
index 0000000..1e05d6e
--- /dev/null
+++ b/agent/mibgroup/hardware/fsys/hw_fsys_private.h
@@ -0,0 +1,2 @@
+void netsnmp_fsys_arch_init(void);
+void netsnmp_fsys_arch_load(void);
diff --git a/agent/mibgroup/hardware/fsys/mnttypes.h b/agent/mibgroup/hardware/fsys/mnttypes.h
index 37ed4fb..bb1b401 100644
--- a/agent/mibgroup/hardware/fsys/mnttypes.h
+++ b/agent/mibgroup/hardware/fsys/mnttypes.h
@@ -151,6 +151,9 @@
 #ifndef MNTTYPE_ZFS
 #define MNTTYPE_ZFS       "zfs"
 #endif
+#ifndef MNTTYPE_NVMFS
+#define MNTTYPE_NVMFS     "nvmfs"
+#endif
 #ifndef MNTTYPE_ACFS
 #define MNTTYPE_ACFS      "acfs"
 #endif
diff --git a/agent/mibgroup/hardware/fsys/mounts.h b/agent/mibgroup/hardware/fsys/mounts.h
index eab65da..164ad7a 100644
--- a/agent/mibgroup/hardware/fsys/mounts.h
+++ b/agent/mibgroup/hardware/fsys/mounts.h
@@ -59,6 +59,9 @@
 #ifndef MOUNT_ZFS
 #define MOUNT_ZFS    "zfs"
 #endif
+#ifndef MOUNT_NVMFS
+#define MOUNT_NVMFS  "nvmfs"
+#endif
 #ifndef MOUNT_ACFS
 #define MOUNT_ACFS   "acfs"
 #endif
diff --git a/agent/mibgroup/hardware/memory/hw_mem.c b/agent/mibgroup/hardware/memory/hw_mem.c
index 1f4474f..3969f6a 100644
--- a/agent/mibgroup/hardware/memory/hw_mem.c
+++ b/agent/mibgroup/hardware/memory/hw_mem.c
@@ -2,15 +2,13 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/memory.h>
-
 #include <net-snmp/net-snmp-features.h>
+#include "hw_mem.h"
 
 netsnmp_feature_child_of(hardware_memory, netsnmp_unused)
 
 netsnmp_feature_child_of(memory_get_cache, hardware_memory)
 
-extern NetsnmpCacheLoad netsnmp_mem_arch_load;
-
 netsnmp_memory_info *_mem_head  = NULL;
 netsnmp_cache       *_mem_cache = NULL;
 
diff --git a/agent/mibgroup/hardware/memory/memory_linux.c b/agent/mibgroup/hardware/memory/memory_linux.c
index 8c189c5..6c20d95 100644
--- a/agent/mibgroup/hardware/memory/memory_linux.c
+++ b/agent/mibgroup/hardware/memory/memory_linux.c
@@ -70,6 +70,7 @@ int netsnmp_mem_arch_load( netsnmp_cache *cache, void *magic ) {
     close(statfd);
     if (bytes_read <= 0) {
         snmp_log_perror(MEMINFO_FILE);
+        buff[0] = '\0';
     } else {
         buff[bytes_read] = '\0';
     }
diff --git a/agent/mibgroup/hardware/sensors/dummy_sensors.c b/agent/mibgroup/hardware/sensors/dummy_sensors.c
index 8d2555d..3c18fd2 100644
--- a/agent/mibgroup/hardware/sensors/dummy_sensors.c
+++ b/agent/mibgroup/hardware/sensors/dummy_sensors.c
@@ -2,6 +2,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/sensors.h>
+#include "hw_sensors_private.h"
 
 
 void netsnmp_sensor_arch_init( void ) {
diff --git a/agent/mibgroup/hardware/sensors/hw_sensors.c b/agent/mibgroup/hardware/sensors/hw_sensors.c
index 1a01645..698440a 100644
--- a/agent/mibgroup/hardware/sensors/hw_sensors.c
+++ b/agent/mibgroup/hardware/sensors/hw_sensors.c
@@ -2,10 +2,9 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/sensors.h>
+#include "hw_sensors_private.h"
 
 
-extern NetsnmpCacheLoad netsnmp_sensor_arch_load;
-extern void             netsnmp_sensor_arch_init( void );
 static int  _sensor_load( void );
 static void _sensor_free( void );
 
diff --git a/agent/mibgroup/hardware/sensors/hw_sensors_private.h b/agent/mibgroup/hardware/sensors/hw_sensors_private.h
new file mode 100644
index 0000000..1c3b7f0
--- /dev/null
+++ b/agent/mibgroup/hardware/sensors/hw_sensors_private.h
@@ -0,0 +1,2 @@
+NetsnmpCacheLoad netsnmp_sensor_arch_load;
+void             netsnmp_sensor_arch_init(void);
diff --git a/agent/mibgroup/hardware/sensors/kstat_sensors.c b/agent/mibgroup/hardware/sensors/kstat_sensors.c
index 62bbb10..662ce86 100644
--- a/agent/mibgroup/hardware/sensors/kstat_sensors.c
+++ b/agent/mibgroup/hardware/sensors/kstat_sensors.c
@@ -2,6 +2,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/sensors.h>
+#include "hw_sensors_private.h"
 
 #include <time.h>
 
diff --git a/agent/mibgroup/hardware/sensors/lmsensors_v2.c b/agent/mibgroup/hardware/sensors/lmsensors_v2.c
index a63f140..638855c 100644
--- a/agent/mibgroup/hardware/sensors/lmsensors_v2.c
+++ b/agent/mibgroup/hardware/sensors/lmsensors_v2.c
@@ -2,6 +2,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/sensors.h>
+#include "hw_sensors_private.h"
 
 #include <time.h>
 #include <sensors/sensors.h>
diff --git a/agent/mibgroup/hardware/sensors/lmsensors_v3.c b/agent/mibgroup/hardware/sensors/lmsensors_v3.c
index e34da19..02f7413 100644
--- a/agent/mibgroup/hardware/sensors/lmsensors_v3.c
+++ b/agent/mibgroup/hardware/sensors/lmsensors_v3.c
@@ -2,6 +2,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/sensors.h>
+#include "hw_sensors_private.h"
 
 #include <time.h>
 #include <sensors/sensors.h>
@@ -86,7 +87,28 @@ netsnmp_sensor_arch_load(netsnmp_cache *cache, void *vp) {
                  *  (inserting it in the appropriate sub-containers)
                  */
                 sp = sensor_by_name( label, type );
-                if ( sp ) {
+                if ( sp && sp->flags & NETSNMP_SENSOR_FLAG_ACTIVE) {
+                    /*
+                     * Some HW does not have unique sensors labels.
+                     * We already have a sensor with this label, thus
+                     * try to create unique label by adding chip-name prefix
+                     * and try again.
+                     */
+                    char chip_name[64];
+                    char new_label[128];
+                    int ret;
+                    DEBUGMSGTL(("sensors:arch:detail", "Already know label %s, adding prefix\n", label));
+                    ret = sensors_snprintf_chip_name(chip_name, sizeof(chip_name), chip);
+                    if (ret < 0) {
+                        DEBUGMSGTL(("sensors:arch:detail", "Can't get chip name for label %s\n", label));
+                        free(label);
+                        continue;
+                    }
+                    snprintf(new_label, sizeof(new_label), "%s:%s", chip_name, label);
+                    DEBUGMSGTL(("sensors:arch:detail", "New label: %s\n", new_label));
+                    sp = sensor_by_name( new_label, type );
+                }
+                if (sp) {
                     sp->value = val;
                     sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
                 }
diff --git a/agent/mibgroup/hardware/sensors/picld_sensors.c b/agent/mibgroup/hardware/sensors/picld_sensors.c
index a4617b2..82ca656 100644
--- a/agent/mibgroup/hardware/sensors/picld_sensors.c
+++ b/agent/mibgroup/hardware/sensors/picld_sensors.c
@@ -2,6 +2,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/sensors.h>
+#include "hw_sensors_private.h"
 
 #include <time.h>
 
diff --git a/agent/mibgroup/host/data_access/swinst.c b/agent/mibgroup/host/data_access/swinst.c
index 3ef05e9..515b294 100644
--- a/agent/mibgroup/host/data_access/swinst.c
+++ b/agent/mibgroup/host/data_access/swinst.c
@@ -11,9 +11,10 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/swinst.h>
-
 #include <stdlib.h>
 #include <unistd.h>
+#include "swinst.h"
+#include "swinst_private.h"
 
 netsnmp_feature_child_of(software_installed, libnetsnmpmibs)
 
@@ -24,10 +25,6 @@ netsnmp_feature_child_of(swinst_entry_remove, netsnmp_unused)
 
 static void netsnmp_swinst_entry_free_cb(netsnmp_swinst_entry *, void *);
 
-extern void netsnmp_swinst_arch_init(void);
-extern void netsnmp_swinst_arch_shutdown(void);
-extern int netsnmp_swinst_arch_load(netsnmp_container *, u_int);
-
 void init_swinst( void )
 {
     static int initialized = 0;
diff --git a/agent/mibgroup/host/data_access/swinst_apt.c b/agent/mibgroup/host/data_access/swinst_apt.c
index c7606d2..4733279 100644
--- a/agent/mibgroup/host/data_access/swinst_apt.c
+++ b/agent/mibgroup/host/data_access/swinst_apt.c
@@ -28,6 +28,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swinst.h>
+#include "swinst_private.h"
 
 char pkg_directory[SNMP_MAXBUF];
 static char apt_fmt[SNMP_MAXBUF];
diff --git a/agent/mibgroup/host/data_access/swinst_darwin.c b/agent/mibgroup/host/data_access/swinst_darwin.c
index 7a47372..c0f50fa 100644
--- a/agent/mibgroup/host/data_access/swinst_darwin.c
+++ b/agent/mibgroup/host/data_access/swinst_darwin.c
@@ -14,6 +14,7 @@
 #include <net-snmp/library/dir_utils.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swinst.h>
+#include "swinst_private.h"
 
 #include <stdlib.h>
 #include <unistd.h>
diff --git a/agent/mibgroup/host/data_access/swinst_null.c b/agent/mibgroup/host/data_access/swinst_null.c
index e4f9158..fd1c922 100644
--- a/agent/mibgroup/host/data_access/swinst_null.c
+++ b/agent/mibgroup/host/data_access/swinst_null.c
@@ -21,6 +21,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swinst.h>
+#include "swinst_private.h"
 
 /* ---------------------------------------------------------------------
  */
diff --git a/agent/mibgroup/host/data_access/swinst_pkginfo.c b/agent/mibgroup/host/data_access/swinst_pkginfo.c
index a122cb1..861d79f 100644
--- a/agent/mibgroup/host/data_access/swinst_pkginfo.c
+++ b/agent/mibgroup/host/data_access/swinst_pkginfo.c
@@ -42,6 +42,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swinst.h>
+#include "swinst_private.h"
 
 netsnmp_feature_require(date_n_time)
 
@@ -192,7 +193,9 @@ netsnmp_swinst_arch_load( netsnmp_container *container, u_int flags)
 			    ? 2      /* operatingSystem */
 			    : 4;     /*  application    */
 
-	    /* Do we need to free 'v' & 'c' ??? */
+	    /* pkgparam() return values must be freed. */
+	    free(c);
+	    free(v);
 #else
 	    entry->swName_len = snprintf( entry->swName, sizeof(entry->swName),
 					  "%s", dp->d_name );
diff --git a/agent/mibgroup/host/data_access/swinst_private.h b/agent/mibgroup/host/data_access/swinst_private.h
new file mode 100644
index 0000000..e0a372a
--- /dev/null
+++ b/agent/mibgroup/host/data_access/swinst_private.h
@@ -0,0 +1,3 @@
+void netsnmp_swinst_arch_init(void);
+void netsnmp_swinst_arch_shutdown(void);
+int netsnmp_swinst_arch_load(struct netsnmp_container_s *, u_int);
diff --git a/agent/mibgroup/host/data_access/swinst_rpm.c b/agent/mibgroup/host/data_access/swinst_rpm.c
index 71595be..cffb4bb 100644
--- a/agent/mibgroup/host/data_access/swinst_rpm.c
+++ b/agent/mibgroup/host/data_access/swinst_rpm.c
@@ -43,6 +43,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swinst.h>
+#include "swinst_private.h"
 
 netsnmp_feature_require(date_n_time)
 
diff --git a/agent/mibgroup/host/data_access/swrun.c b/agent/mibgroup/host/data_access/swrun.c
index d18ea5f..3613071 100644
--- a/agent/mibgroup/host/data_access/swrun.c
+++ b/agent/mibgroup/host/data_access/swrun.c
@@ -14,6 +14,8 @@
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun.h"
+#include "swrun_private.h"
 
 netsnmp_feature_child_of(software_running, libnetsnmpmibs)
 
@@ -29,26 +31,12 @@ static int _swrun_init = 0;
 static netsnmp_cache     *swrun_cache     = NULL;
 static netsnmp_container *swrun_container = NULL;
 
-netsnmp_container * netsnmp_swrun_container(void);
-netsnmp_cache     * netsnmp_swrun_cache    (void);
-
 /*
  * local static prototypes
  */
 static void _swrun_entry_release(netsnmp_swrun_entry * entry,
                                             void *unused);
 
-/**---------------------------------------------------------------------*/
-/*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-extern void netsnmp_arch_swrun_init(void);
-extern int netsnmp_arch_swrun_container_load(netsnmp_container* container,
-                                             u_int load_flags);
-
 /**
  * initialization
  */
@@ -75,10 +63,27 @@ shutdown_swrun(void)
 }
 
 int
-swrun_count_processes( void )
+swrun_count_processes(int include_kthreads)
 {
+    netsnmp_swrun_entry *entry;
+    netsnmp_iterator  *it;
+    int i = 0;
+
     netsnmp_cache_check_and_reload(swrun_cache);
-    return ( swrun_container ? CONTAINER_SIZE(swrun_container) : 0 );
+    if ( !swrun_container )
+        return 0;    /* or -1 */
+
+    if (include_kthreads)
+        return ( swrun_container ? CONTAINER_SIZE(swrun_container) : 0 );
+
+    it = CONTAINER_ITERATOR( swrun_container );
+    while ((entry = (netsnmp_swrun_entry*)ITERATOR_NEXT( it )) != NULL) {
+        if (4 == entry->hrSWRunType)
+            i++;
+    }
+    ITERATOR_RELEASE( it );
+
+    return i;
 }
 
 #ifndef NETSNMP_FEATURE_REMOVE_SWRUN_MAX_PROCESSES
diff --git a/agent/mibgroup/host/data_access/swrun_cygwin.c b/agent/mibgroup/host/data_access/swrun_cygwin.c
index a1e1475..05ef99f 100644
--- a/agent/mibgroup/host/data_access/swrun_cygwin.c
+++ b/agent/mibgroup/host/data_access/swrun_cygwin.c
@@ -27,6 +27,7 @@
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 /*
  * a lot of this is "stolen" from cygwin ps.cc
diff --git a/agent/mibgroup/host/data_access/swrun_darwin.c b/agent/mibgroup/host/data_access/swrun_darwin.c
index 3b00fe3..699c74b 100644
--- a/agent/mibgroup/host/data_access/swrun_darwin.c
+++ b/agent/mibgroup/host/data_access/swrun_darwin.c
@@ -14,6 +14,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 #include <stdlib.h>
 #include <unistd.h>
diff --git a/agent/mibgroup/host/data_access/swrun_kinfo.c b/agent/mibgroup/host/data_access/swrun_kinfo.c
index 7cce6e7..4a9a2e6 100644
--- a/agent/mibgroup/host/data_access/swrun_kinfo.c
+++ b/agent/mibgroup/host/data_access/swrun_kinfo.c
@@ -47,6 +47,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 extern kvm_t *kd;
 
diff --git a/agent/mibgroup/host/data_access/swrun_kvm_proc.c b/agent/mibgroup/host/data_access/swrun_kvm_proc.c
index 7156cf9..517b12e 100644
--- a/agent/mibgroup/host/data_access/swrun_kvm_proc.c
+++ b/agent/mibgroup/host/data_access/swrun_kvm_proc.c
@@ -46,6 +46,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 #include "kernel.h"
 #include "kernel_sunos5.h"
 
diff --git a/agent/mibgroup/host/data_access/swrun_nlist.c b/agent/mibgroup/host/data_access/swrun_nlist.c
index 5db6c9c..b727bbd 100644
--- a/agent/mibgroup/host/data_access/swrun_nlist.c
+++ b/agent/mibgroup/host/data_access/swrun_nlist.c
@@ -23,6 +23,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 /* ---------------------------------------------------------------------
  */
diff --git a/agent/mibgroup/host/data_access/swrun_null.c b/agent/mibgroup/host/data_access/swrun_null.c
index 343d40e..5e4f9a0 100644
--- a/agent/mibgroup/host/data_access/swrun_null.c
+++ b/agent/mibgroup/host/data_access/swrun_null.c
@@ -21,6 +21,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 /* ---------------------------------------------------------------------
  */
diff --git a/agent/mibgroup/host/data_access/swrun_private.h b/agent/mibgroup/host/data_access/swrun_private.h
new file mode 100644
index 0000000..4558ae8
--- /dev/null
+++ b/agent/mibgroup/host/data_access/swrun_private.h
@@ -0,0 +1,3 @@
+extern void netsnmp_arch_swrun_init(void);
+extern int netsnmp_arch_swrun_container_load(netsnmp_container* container,
+                                             u_int load_flags);
diff --git a/agent/mibgroup/host/data_access/swrun_procfs_psinfo.c b/agent/mibgroup/host/data_access/swrun_procfs_psinfo.c
index ed961ee..44e11c3 100644
--- a/agent/mibgroup/host/data_access/swrun_procfs_psinfo.c
+++ b/agent/mibgroup/host/data_access/swrun_procfs_psinfo.c
@@ -23,21 +23,21 @@
 #include <fcntl.h>
 #endif
 
-#define HAVE_SYS_PROCFS_H    /* XXX - Needs a configure check! */
-#ifdef HAVE_SYS_PROCFS_H
-#define _KERNEL              /* For psinfo_t */
-#include <sys/procfs.h>
-#undef _KERNEL
-#endif
+#include <procfs.h>
 #ifdef HAVE_SYS_PROC_H
 #include <sys/proc.h>
 #endif
 
+#include <sys/processor.h>
+#include <sys/procset.h>
+#include <thread.h>
+
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 /* ---------------------------------------------------------------------
  */
diff --git a/agent/mibgroup/host/data_access/swrun_procfs_status.c b/agent/mibgroup/host/data_access/swrun_procfs_status.c
index ef9e269..7669c18 100644
--- a/agent/mibgroup/host/data_access/swrun_procfs_status.c
+++ b/agent/mibgroup/host/data_access/swrun_procfs_status.c
@@ -29,6 +29,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 static long pagesize;
 static long sc_clk_tck;
diff --git a/agent/mibgroup/host/data_access/swrun_procinfo.c b/agent/mibgroup/host/data_access/swrun_procinfo.c
index 14640e1..f14cea3 100644
--- a/agent/mibgroup/host/data_access/swrun_procinfo.c
+++ b/agent/mibgroup/host/data_access/swrun_procinfo.c
@@ -23,6 +23,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 int avail = 1024;    /* Size of table to allocate */
 
diff --git a/agent/mibgroup/host/data_access/swrun_prpsinfo.c b/agent/mibgroup/host/data_access/swrun_prpsinfo.c
index 6cbbb23..f052d70 100644
--- a/agent/mibgroup/host/data_access/swrun_prpsinfo.c
+++ b/agent/mibgroup/host/data_access/swrun_prpsinfo.c
@@ -25,6 +25,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 /* ---------------------------------------------------------------------
  */
diff --git a/agent/mibgroup/host/data_access/swrun_pstat.c b/agent/mibgroup/host/data_access/swrun_pstat.c
index b85ce77..e8ec8ab 100644
--- a/agent/mibgroup/host/data_access/swrun_pstat.c
+++ b/agent/mibgroup/host/data_access/swrun_pstat.c
@@ -29,6 +29,7 @@
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/data_access/swrun.h>
+#include "swrun_private.h"
 
 /* ---------------------------------------------------------------------
  */
diff --git a/agent/mibgroup/host/hr_disk.c b/agent/mibgroup/host/hr_disk.c
index c4ac52f..9d9c016 100644
--- a/agent/mibgroup/host/hr_disk.c
+++ b/agent/mibgroup/host/hr_disk.c
@@ -130,9 +130,6 @@
 	 *
 	 *********************/
 
-void            Init_HR_Disk(void);
-int             Get_Next_HR_Disk(void);
-int             Get_Next_HR_Disk_Partition(char *, size_t, int);
 #if !(defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7))
 static void     Add_HR_Disk_entry(const char *, int, int, int, int,
                                   const char *, int, int);
diff --git a/agent/mibgroup/host/hr_filesys.c b/agent/mibgroup/host/hr_filesys.c
index b23d322..56c8b20 100644
--- a/agent/mibgroup/host/hr_filesys.c
+++ b/agent/mibgroup/host/hr_filesys.c
@@ -201,12 +201,7 @@ struct mntent  *HRFS_entry;
 #define	FULL_DUMP	0
 #define	PART_DUMP	1
 
-extern void     Init_HR_FileSys(void);
-extern int      Get_Next_HR_FileSys(void);
-char           *cook_device(char *);
 static u_char  *when_dumped(char *filesys, int level, size_t * length);
-int             header_hrfilesys(struct variable *, oid *, size_t *, int,
-                                 size_t *, WriteMethod **);
 
         /*********************
 	 *
diff --git a/agent/mibgroup/host/hr_partition.c b/agent/mibgroup/host/hr_partition.c
index 3b9abd6..14d8071 100644
--- a/agent/mibgroup/host/hr_partition.c
+++ b/agent/mibgroup/host/hr_partition.c
@@ -65,8 +65,6 @@ static void     Save_HR_Partition(int, int);
 
 static void     Init_HR_Partition(void);
 static int      Get_Next_HR_Partition(void);
-int             header_hrpartition(struct variable *, oid *, size_t *, int,
-                                   size_t *, WriteMethod **);
 
 
 #define	HRPART_INDEX		1
diff --git a/agent/mibgroup/host/hr_print.c b/agent/mibgroup/host/hr_print.c
index 4cfa25b..4096979 100644
--- a/agent/mibgroup/host/hr_print.c
+++ b/agent/mibgroup/host/hr_print.c
@@ -28,7 +28,6 @@
 
 void            Init_HR_Print(void);
 int             Get_Next_HR_Print(void);
-void            Save_HR_Print(void);
 const char     *describe_printer(int);
 int             printer_status(int);
 int             printer_detail_status(int);
diff --git a/agent/mibgroup/host/hr_storage.c b/agent/mibgroup/host/hr_storage.c
index 264fecc..a868984 100644
--- a/agent/mibgroup/host/hr_storage.c
+++ b/agent/mibgroup/host/hr_storage.c
@@ -259,10 +259,6 @@ void*           header_hrstoreEntry(struct variable *, oid *, size_t *,
                                     int, size_t *, WriteMethod **);
 Netsnmp_Node_Handler handle_memsize;
 
-#ifdef solaris2
-void            sol_get_swapinfo(int *, int *);
-#endif
-
 #define	HRSTORE_MEMSIZE		1
 #define	HRSTORE_INDEX		2
 #define	HRSTORE_TYPE		3
@@ -288,7 +284,6 @@ struct variable2 hrstore_variables[] = {
     {HRSTORE_FAILS, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
      var_hrstore, 1, {7}}
 };
-oid             hrstore_variables_oid[] = { 1, 3, 6, 1, 2, 1, 25, 2 };
 oid             hrMemorySize_oid[]   = { 1, 3, 6, 1, 2, 1, 25, 2, 2 };
 oid             hrStorageTable_oid[] = { 1, 3, 6, 1, 2, 1, 25, 2, 3, 1 };
 
@@ -697,7 +692,7 @@ Get_Next_HR_Store(void)
 	}
 }
 
-#ifdef solaris2
+#if 0
 void
 sol_get_swapinfo(int *totalP, int *usedP)
 {
diff --git a/agent/mibgroup/host/hr_swinst.c b/agent/mibgroup/host/hr_swinst.c
index 25582bd..c2cf5e5 100644
--- a/agent/mibgroup/host/hr_swinst.c
+++ b/agent/mibgroup/host/hr_swinst.c
@@ -141,18 +141,13 @@ int             header_hrswInstEntry(struct variable *, oid *, size_t *,
 	 *  Initialisation & common implementation functions
 	 *
 	 *********************/
-extern void     Init_HR_SWInst(void);
-extern int      Get_Next_HR_SWInst(void);
-extern void     End_HR_SWInst(void);
-extern int      Save_HR_SW_info(int ix);
+static void     Init_HR_SWInst(void);
+static int      Get_Next_HR_SWInst(void);
+static void     End_HR_SWInst(void);
+static int      Save_HR_SW_info(int ix);
 
-#ifdef HAVE_LIBRPM
 static void     Mark_HRSW_token(void);
 static void     Release_HRSW_token(void);
-#else
-#define	Mark_HRSW_token()
-#define	Release_HRSW_token()
-#endif
 
 
 #define	HRSWINST_CHANGE		1
@@ -705,7 +700,6 @@ Save_HR_SW_info(int ix)
     return 0;
 }
 
-#ifdef	HAVE_LIBRPM
 void
 Mark_HRSW_token(void)
 {
@@ -714,14 +708,15 @@ Mark_HRSW_token(void)
 void
 Release_HRSW_token(void)
 {
+#ifdef	HAVE_LIBRPM
     SWI_t          *swi = &_myswi;      /* XXX static for now */
     if (swi != NULL && swi->swi_h) {
         headerFree(swi->swi_h);
         swi->swi_h = NULL;
         swi->swi_prevx = -1;
     }
-}
 #endif                          /* HAVE_LIBRPM */
+}
 
 void
 End_HR_SWInst(void)
diff --git a/agent/mibgroup/host/hr_system.c b/agent/mibgroup/host/hr_system.c
index d99cc7d..f63fd3c 100644
--- a/agent/mibgroup/host/hr_system.c
+++ b/agent/mibgroup/host/hr_system.c
@@ -24,6 +24,7 @@
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/data_access/swrun.h>
 
 #include "host.h"
 #include "host_res.h"
@@ -114,7 +115,14 @@ static long     get_max_solaris_processes(void);
 static int      get_load_dev(void);
 static int      count_users(void);
 extern int      count_processes(void);
-extern int      swrun_count_processes(void);
+#if USING_HOST_DATA_ACCESS_SWRUN_MODULE
+static int      count_kthreads = 1;
+
+static void parse_count_kthreads(const char *token, const char *line)
+{
+    count_kthreads = atoi(line);
+}
+#endif
 
         /*********************
 	 *
@@ -194,6 +202,11 @@ init_hr_system(void)
 #ifdef NPROC_SYMBOL
     auto_nlist(NPROC_SYMBOL, 0, 0);
 #endif
+#if USING_HOST_DATA_ACCESS_SWRUN_MODULE
+    snmpd_register_const_config_handler("count_kthreads",
+                                        parse_count_kthreads, NULL,
+					"0|1    0 to exclude kernel threads from hrSystemProcesses.0");
+#endif
 
     REGISTER_MIB("host/hr_system", hrsystem_variables, variable2,
                  hrsystem_variables_oid);
@@ -317,7 +330,7 @@ var_hrsys(struct variable * vp,
         return (u_char *) & long_return;
     case HRSYS_PROCS:
 #if USING_HOST_DATA_ACCESS_SWRUN_MODULE
-        long_return = swrun_count_processes();
+        long_return = swrun_count_processes(count_kthreads);
 #elif USING_HOST_HR_SWRUN_MODULE
         long_return = count_processes();
 #else
@@ -671,12 +684,11 @@ count_users(void)
             continue;
 #endif
 #ifndef UTMP_HAS_NO_PID
-            /* This block of code fixes zombie user PIDs in the
+            /* This block of code skips zombie user PIDs in the
                utmp/utmpx file that would otherwise be counted as a
-               current user */
+               current user, but leaves updating the actual
+               utmp/utmpx file to the system. */
             if (kill(utmp_p->ut_pid, 0) == -1 && errno == ESRCH) {
-                utmp_p->ut_type = DEAD_PROCESS;
-                pututline(utmp_p);
                 continue;
             }
 #endif
diff --git a/agent/mibgroup/host/hrh_filesys.c b/agent/mibgroup/host/hrh_filesys.c
index 4aab6a0..5cadf16 100644
--- a/agent/mibgroup/host/hrh_filesys.c
+++ b/agent/mibgroup/host/hrh_filesys.c
@@ -23,6 +23,7 @@
 #include "hrh_filesys.h"
 #include "hrh_storage.h"
 #include "hr_disk.h"
+#include "hr_filesys.h"
 #include <net-snmp/utilities.h>
 
 #if HAVE_MNTENT_H
@@ -77,9 +78,6 @@ netsnmp_fsys_info *HRFS_entry;
 #define	FULL_DUMP	0
 #define	PART_DUMP	1
 
-extern void     Init_HR_FileSys(void);
-extern int      Get_Next_HR_FileSys(void);
-char           *cook_device(char *);
 static u_char  *when_dumped(char *filesys, int level, size_t * length);
 int             header_hrhfilesys(struct variable *, oid *, size_t *, int,
                                  size_t *, WriteMethod **);
@@ -189,7 +187,7 @@ header_hrhfilesys(struct variable *vp,
     memcpy((char *) name, (char *) newname,
            (vp->namelen + 1) * sizeof(oid));
     *length = vp->namelen + 1;
-    *write_method = 0;
+    *write_method = NULL;
     *var_len = sizeof(long);    /* default to 'long' results */
 
     DEBUGMSGTL(("host/hr_filesys", "... get filesys stats "));
diff --git a/agent/mibgroup/host/hrh_storage.c b/agent/mibgroup/host/hrh_storage.c
index ca2f854..8107669 100644
--- a/agent/mibgroup/host/hrh_storage.c
+++ b/agent/mibgroup/host/hrh_storage.c
@@ -12,6 +12,7 @@
 #include "hrh_filesys.h"
 #include "hrh_storage.h"
 #include "hr_disk.h"
+#include "hr_filesys.h"
 #include <net-snmp/utilities.h>
 
 
@@ -75,8 +76,6 @@ static void parse_storage_config(const char *, char *);
 	 *********************/
 int             Get_Next_HR_Store(void);
 void            Init_HR_Store(void);
-int             header_hrstore(struct variable *, oid *, size_t *, int,
-                               size_t *, WriteMethod **);
 void*           header_hrstoreEntry(struct variable *, oid *, size_t *,
                                     int, size_t *, WriteMethod **);
 Netsnmp_Node_Handler handle_memsize;
@@ -384,7 +383,7 @@ really_try_next:
         return (u_char *) & long_return;
     case HRSTORE_TYPE:
         if (store_idx > NETSNMP_MEM_TYPE_MAX)
-            if (HRFS_entry->flags & NETSNMP_FS_FLAG_REMOTE )
+            if (HRFS_entry->flags & NETSNMP_FS_FLAG_REMOTE && storageUseNFS)
                 storage_type_id[storage_type_len - 1] = 10;     /* Network Disk */
             else if (HRFS_entry->flags & NETSNMP_FS_FLAG_REMOVE )
                 storage_type_id[storage_type_len - 1] = 5;      /* Removable Disk */
@@ -421,39 +420,39 @@ really_try_next:
         if (store_idx > NETSNMP_MEM_TYPE_MAX) {
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                     NETSNMP_DS_AGENT_REALSTORAGEUNITS))
-                long_return = HRFS_entry->units & 0xffffffff;
+                long_return = HRFS_entry->units & 0x7fffffff;
             else
                 long_return = HRFS_entry->units_32;
         } else {
             if ( !mem || mem->units == -1 )
                 goto try_next;
-            long_return = mem->units;
+            long_return = mem->units & 0x7fffffff;
         }
         return (u_char *) & long_return;
     case HRSTORE_SIZE:
         if (store_idx > NETSNMP_MEM_TYPE_MAX) {
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                     NETSNMP_DS_AGENT_REALSTORAGEUNITS))
-                long_return = HRFS_entry->size & 0xffffffff;
+                long_return = HRFS_entry->size & 0x7fffffff;
             else
                 long_return = HRFS_entry->size_32;
         } else {
             if ( !mem || mem->size == -1 )
                 goto try_next;
-            long_return = mem->size;
+            long_return = mem->size & 0x7fffffff;
         }
         return (u_char *) & long_return;
     case HRSTORE_USED:
         if (store_idx > NETSNMP_MEM_TYPE_MAX) {
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                     NETSNMP_DS_AGENT_REALSTORAGEUNITS))
-                long_return = HRFS_entry->used & 0xffffffff;
+                long_return = HRFS_entry->used & 0x7fffffff;
             else
                 long_return = HRFS_entry->used_32;
         } else {
             if ( !mem || mem->size == -1 || mem->free == -1 )
                 goto try_next;
-            long_return = mem->size - mem->free;
+            long_return = (mem->size - mem->free) & 0x7fffffff;
         }
         return (u_char *) & long_return;
     case HRSTORE_FAILS:
diff --git a/agent/mibgroup/if-mib/data_access/interface.c b/agent/mibgroup/if-mib/data_access/interface.c
index 26e31fc..a22aa40 100644
--- a/agent/mibgroup/if-mib/data_access/interface.c
+++ b/agent/mibgroup/if-mib/data_access/interface.c
@@ -14,6 +14,7 @@
 #include "mibII/mibII_common.h"
 #include "if-mib/ifTable/ifTable.h"
 #include "if-mib/data_access/interface.h"
+#include "interface_private.h"
 
 netsnmp_feature_child_of(interface_all, libnetsnmpmibs)
 netsnmp_feature_child_of(interface, interface_all)
@@ -45,24 +46,6 @@ static void _access_interface_entry_save_name(const char *name, oid index);
 static void _parse_interface_config(const char *token, char *cptr);
 static void _free_interface_config(void);
 
-/**---------------------------------------------------------------------*/
-/*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-#ifndef NETSNMP_ACCESS_INTERFACE_NOARCH
-extern void netsnmp_arch_interface_init(void);
-extern int
-netsnmp_arch_interface_container_load(netsnmp_container* container,
-                                      u_int load_flags);
-extern int
-netsnmp_arch_set_admin_status(netsnmp_interface_entry * entry,
-                              int ifAdminStatus);
-extern int netsnmp_arch_interface_index_find(const char*name);
-#endif
-
 
 /**
  * initialization
@@ -304,7 +287,8 @@ netsnmp_access_interface_entry_create(const char *name, oid if_index)
         entry->index = if_index;
     _access_interface_entry_save_name(name, entry->index);
 
-    entry->descr = strdup(name);
+    if (name)
+        entry->descr = strdup(name);
 
     /*
      * make some assumptions
diff --git a/agent/mibgroup/if-mib/data_access/interface_linux.c b/agent/mibgroup/if-mib/data_access/interface_linux.c
index f196fc8..d62232d 100644
--- a/agent/mibgroup/if-mib/data_access/interface_linux.c
+++ b/agent/mibgroup/if-mib/data_access/interface_linux.c
@@ -6,6 +6,9 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/snmp_agent.h>
+#include <net-snmp/agent/snmp_vars.h>
+#include "interface_private.h"
 
 netsnmp_feature_require(fd_event_manager)
 netsnmp_feature_require(delete_prefix_info)
@@ -616,7 +619,7 @@ netsnmp_arch_interface_container_load(netsnmp_container* container,
     if (!(devin = fopen("/proc/net/dev", "r"))) {
         DEBUGMSGTL(("access:interface",
                     "Failed to load Interface Table (linux1)\n"));
-        NETSNMP_LOGONCE((LOG_ERR, "cannot open /proc/net/dev ...\n"));
+        snmp_log_perror("interface_linux: cannot open /proc/net/dev");
         return -2;
     }
 
@@ -625,7 +628,7 @@ netsnmp_arch_interface_container_load(netsnmp_container* container,
      */
     fd = socket(AF_INET, SOCK_DGRAM, 0);
     if(fd < 0) {
-        snmp_log(LOG_ERR, "could not create socket\n");
+        snmp_log_perror("interface_linux: could not create socket");
         fclose(devin);
         return -2;
     }
@@ -1064,7 +1067,7 @@ netsnmp_linux_interface_get_if_speed(int fd, const char *name,
 void netsnmp_prefix_process(int fd, void *data);
 
 /* Open netlink socket to watch new ipv6 addresses and prefixes. */
-int netsnmp_prefix_listen()
+int netsnmp_prefix_listen(void)
 {
     struct {
                 struct nlmsghdr n;
diff --git a/agent/mibgroup/if-mib/data_access/interface_openbsd.c b/agent/mibgroup/if-mib/data_access/interface_openbsd.c
index 8340dc6..26cd46c 100644
--- a/agent/mibgroup/if-mib/data_access/interface_openbsd.c
+++ b/agent/mibgroup/if-mib/data_access/interface_openbsd.c
@@ -22,6 +22,7 @@ netsnmp_feature_child_of(interface_arch_set_admin_status, interface_all)
 #include <net-snmp/data_access/interface.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include "if-mib/data_access/interface.h"
+#include "interface_private.h"
 
 #include <sys/types.h>
 #include <sys/time.h>
diff --git a/agent/mibgroup/if-mib/data_access/interface_private.h b/agent/mibgroup/if-mib/data_access/interface_private.h
new file mode 100644
index 0000000..914016a
--- /dev/null
+++ b/agent/mibgroup/if-mib/data_access/interface_private.h
@@ -0,0 +1,12 @@
+struct prefix_info;
+struct netsnmp_container_s;
+struct netsnmp_interface_entry_s;
+
+extern struct prefix_info *prefix_head_list;
+
+void netsnmp_arch_interface_init(void);
+int netsnmp_arch_interface_container_load(struct netsnmp_container_s* container,
+                                          u_int load_flags);
+oid netsnmp_arch_interface_index_find(const char *name);
+int netsnmp_arch_set_admin_status(struct netsnmp_interface_entry_s * entry,
+                                  int ifAdminStatus_val);
diff --git a/agent/mibgroup/if-mib/data_access/interface_solaris2.c b/agent/mibgroup/if-mib/data_access/interface_solaris2.c
index 8aa47f8..a08e59a 100644
--- a/agent/mibgroup/if-mib/data_access/interface_solaris2.c
+++ b/agent/mibgroup/if-mib/data_access/interface_solaris2.c
@@ -12,6 +12,7 @@
 
 #include <net-snmp/data_access/interface.h>
 #include "if-mib/data_access/interface.h"
+#include "interface_private.h"
 #include <sys/ioctl.h>
 #include <sys/sockio.h>
 #include <strings.h>
diff --git a/agent/mibgroup/if-mib/data_access/interface_sysctl.c b/agent/mibgroup/if-mib/data_access/interface_sysctl.c
index 6076d19..e19dc1e 100644
--- a/agent/mibgroup/if-mib/data_access/interface_sysctl.c
+++ b/agent/mibgroup/if-mib/data_access/interface_sysctl.c
@@ -22,6 +22,7 @@
 #include <net-snmp/data_access/interface.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include "if-mib/data_access/interface.h"
+#include "interface_private.h"
 
 #include <sys/types.h>
 #include <sys/time.h>
@@ -241,7 +242,12 @@ netsnmp_sysctl_get_if_speed(char *name, u_int *speed,
 {
     int s;
     struct ifmediareq ifmr;
-    int *media_list, i;
+#if defined(OpenBSD) && OpenBSD >= 201605
+    uint64_t *media_list;
+#else
+    int *media_list;
+#endif
+    int i;
     u_int t_speed, t_speed_high; 
     u_int m_speed, m_speed_high;
 
@@ -272,7 +278,7 @@ netsnmp_sysctl_get_if_speed(char *name, u_int *speed,
     netsnmp_sysctl_ifmedia_to_speed(ifmr.ifm_current, speed, speed_high);
 
     if (*speed == 0 &&
-        (media_list = (int *) malloc(ifmr.ifm_count * sizeof(int))) != NULL ) {
+        (media_list = malloc(ifmr.ifm_count * sizeof(*media_list))) != NULL ) {
 
         ifmr.ifm_ulist = media_list;
 
diff --git a/agent/mibgroup/if-mib/ifXTable/ifXTable.c b/agent/mibgroup/if-mib/ifXTable/ifXTable.c
index bb3e736..9b9055c 100644
--- a/agent/mibgroup/if-mib/ifXTable/ifXTable.c
+++ b/agent/mibgroup/if-mib/ifXTable/ifXTable.c
@@ -704,7 +704,7 @@ The total number of octets received on the interface,
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ifHCInOctets data.
@@ -714,7 +714,7 @@ The total number of octets received on the interface,
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCInOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -722,7 +722,7 @@ The total number of octets received on the interface,
  */
 int
 ifHCInOctets_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                 U64 * ifHCInOctets_val_ptr)
+                 struct counter64 *ifHCInOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCInOctets_val_ptr);
@@ -761,7 +761,7 @@ The number of packets, delivered by this sub-layer to a
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64
  */
 /**
  * Extract the current value of the ifHCInUcastPkts data.
@@ -771,7 +771,7 @@ The number of packets, delivered by this sub-layer to a
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCInUcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -779,7 +779,7 @@ The number of packets, delivered by this sub-layer to a
  */
 int
 ifHCInUcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                    U64 * ifHCInUcastPkts_val_ptr)
+                    struct counter64 *ifHCInUcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCInUcastPkts_val_ptr);
@@ -820,7 +820,7 @@ The number of packets, delivered by this sub-layer to a
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64
  */
 /**
  * Extract the current value of the ifHCInMulticastPkts data.
@@ -830,7 +830,7 @@ The number of packets, delivered by this sub-layer to a
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCInMulticastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -838,7 +838,7 @@ The number of packets, delivered by this sub-layer to a
  */
 int
 ifHCInMulticastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                        U64 * ifHCInMulticastPkts_val_ptr)
+                        struct counter64 *ifHCInMulticastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCInMulticastPkts_val_ptr);
@@ -879,7 +879,7 @@ The number of packets, delivered by this sub-layer to a
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ifHCInBroadcastPkts data.
@@ -889,7 +889,7 @@ The number of packets, delivered by this sub-layer to a
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCInBroadcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -897,7 +897,7 @@ The number of packets, delivered by this sub-layer to a
  */
 int
 ifHCInBroadcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                        U64 * ifHCInBroadcastPkts_val_ptr)
+                        struct counter64 *ifHCInBroadcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCInBroadcastPkts_val_ptr);
@@ -937,7 +937,7 @@ The total number of octets transmitted out of the
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ifHCOutOctets data.
@@ -947,7 +947,7 @@ The total number of octets transmitted out of the
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCOutOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -955,7 +955,7 @@ The total number of octets transmitted out of the
  */
 int
 ifHCOutOctets_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                  U64 * ifHCOutOctets_val_ptr)
+                  struct counter64 *ifHCOutOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCOutOctets_val_ptr);
@@ -995,7 +995,7 @@ The total number of packets that higher-level protocols
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ifHCOutUcastPkts data.
@@ -1005,7 +1005,7 @@ The total number of packets that higher-level protocols
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCOutUcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1013,7 +1013,7 @@ The total number of packets that higher-level protocols
  */
 int
 ifHCOutUcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                     U64 * ifHCOutUcastPkts_val_ptr)
+                     struct counter64 *ifHCOutUcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCOutUcastPkts_val_ptr);
@@ -1056,7 +1056,7 @@ The total number of packets that higher-level protocols
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ifHCOutMulticastPkts data.
@@ -1066,7 +1066,7 @@ The total number of packets that higher-level protocols
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCOutMulticastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1074,7 +1074,7 @@ The total number of packets that higher-level protocols
  */
 int
 ifHCOutMulticastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                         U64 * ifHCOutMulticastPkts_val_ptr)
+                         struct counter64 *ifHCOutMulticastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCOutMulticastPkts_val_ptr);
@@ -1116,7 +1116,7 @@ The total number of packets that higher-level protocols
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ifHCOutBroadcastPkts data.
@@ -1126,7 +1126,7 @@ The total number of packets that higher-level protocols
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ifHCOutBroadcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1134,7 +1134,7 @@ The total number of packets that higher-level protocols
  */
 int
 ifHCOutBroadcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                         U64 * ifHCOutBroadcastPkts_val_ptr)
+                         struct counter64 *ifHCOutBroadcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ifHCOutBroadcastPkts_val_ptr);
diff --git a/agent/mibgroup/if-mib/ifXTable/ifXTable.h b/agent/mibgroup/if-mib/ifXTable/ifXTable.h
index ba22f97..925af13 100644
--- a/agent/mibgroup/if-mib/ifXTable/ifXTable.h
+++ b/agent/mibgroup/if-mib/ifXTable/ifXTable.h
@@ -143,28 +143,28 @@ config_require(if-mib/ifXTable/ifXTable_data_access)
                                            u_long *
                                            ifOutBroadcastPkts_val_ptr);
     int             ifHCInOctets_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                                     U64 * ifHCInOctets_val_ptr);
+                                     struct counter64 *ifHCInOctets_val_ptr);
     int             ifHCInUcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                                        U64 * ifHCInUcastPkts_val_ptr);
+                                        struct counter64 *ifHCInUcastPkts_val_ptr);
     int             ifHCInMulticastPkts_get(ifXTable_rowreq_ctx *
                                             rowreq_ctx,
-                                            U64 *
+                                            struct counter64 *
                                             ifHCInMulticastPkts_val_ptr);
     int             ifHCInBroadcastPkts_get(ifXTable_rowreq_ctx *
                                             rowreq_ctx,
-                                            U64 *
+                                            struct counter64 *
                                             ifHCInBroadcastPkts_val_ptr);
     int             ifHCOutOctets_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                                      U64 * ifHCOutOctets_val_ptr);
+                                      struct counter64 *ifHCOutOctets_val_ptr);
     int             ifHCOutUcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
-                                         U64 * ifHCOutUcastPkts_val_ptr);
+                                         struct counter64 *ifHCOutUcastPkts_val_ptr);
     int             ifHCOutMulticastPkts_get(ifXTable_rowreq_ctx *
                                              rowreq_ctx,
-                                             U64 *
+                                             struct counter64 *
                                              ifHCOutMulticastPkts_val_ptr);
     int             ifHCOutBroadcastPkts_get(ifXTable_rowreq_ctx *
                                              rowreq_ctx,
-                                             U64 *
+                                             struct counter64 *
                                              ifHCOutBroadcastPkts_val_ptr);
     int             ifLinkUpDownTrapEnable_get(ifXTable_rowreq_ctx *
                                                rowreq_ctx,
@@ -284,86 +284,86 @@ config_require(if-mib/ifXTable/ifXTable_data_access)
 
     int             ifHCInOctets_check_value(ifXTable_rowreq_ctx *
                                              rowreq_ctx,
-                                             U64 ifHCInOctets_val);
+                                             struct counter64 ifHCInOctets_val);
     int             ifHCInOctets_undo_setup(ifXTable_rowreq_ctx *
                                             rowreq_ctx);
     int             ifHCInOctets_set(ifXTable_rowreq_ctx * rowreq_ctx,
-                                     U64 ifHCInOctets_val);
+                                     struct counter64 ifHCInOctets_val);
     int             ifHCInOctets_undo(ifXTable_rowreq_ctx * rowreq_ctx);
 
     int             ifHCInUcastPkts_check_value(ifXTable_rowreq_ctx *
                                                 rowreq_ctx,
-                                                U64 ifHCInUcastPkts_val);
+                                                struct counter64 ifHCInUcastPkts_val);
     int             ifHCInUcastPkts_undo_setup(ifXTable_rowreq_ctx *
                                                rowreq_ctx);
     int             ifHCInUcastPkts_set(ifXTable_rowreq_ctx * rowreq_ctx,
-                                        U64 ifHCInUcastPkts_val);
+                                        struct counter64 ifHCInUcastPkts_val);
     int             ifHCInUcastPkts_undo(ifXTable_rowreq_ctx * rowreq_ctx);
 
     int             ifHCInMulticastPkts_check_value(ifXTable_rowreq_ctx *
                                                     rowreq_ctx,
-                                                    U64
+                                                    struct counter64
                                                     ifHCInMulticastPkts_val);
     int             ifHCInMulticastPkts_undo_setup(ifXTable_rowreq_ctx *
                                                    rowreq_ctx);
     int             ifHCInMulticastPkts_set(ifXTable_rowreq_ctx *
                                             rowreq_ctx,
-                                            U64 ifHCInMulticastPkts_val);
+                                            struct counter64 ifHCInMulticastPkts_val);
     int             ifHCInMulticastPkts_undo(ifXTable_rowreq_ctx *
                                              rowreq_ctx);
 
     int             ifHCInBroadcastPkts_check_value(ifXTable_rowreq_ctx *
                                                     rowreq_ctx,
-                                                    U64
+                                                    struct counter64
                                                     ifHCInBroadcastPkts_val);
     int             ifHCInBroadcastPkts_undo_setup(ifXTable_rowreq_ctx *
                                                    rowreq_ctx);
     int             ifHCInBroadcastPkts_set(ifXTable_rowreq_ctx *
                                             rowreq_ctx,
-                                            U64 ifHCInBroadcastPkts_val);
+                                            struct counter64 ifHCInBroadcastPkts_val);
     int             ifHCInBroadcastPkts_undo(ifXTable_rowreq_ctx *
                                              rowreq_ctx);
 
     int             ifHCOutOctets_check_value(ifXTable_rowreq_ctx *
                                               rowreq_ctx,
-                                              U64 ifHCOutOctets_val);
+                                              struct counter64 ifHCOutOctets_val);
     int             ifHCOutOctets_undo_setup(ifXTable_rowreq_ctx *
                                              rowreq_ctx);
     int             ifHCOutOctets_set(ifXTable_rowreq_ctx * rowreq_ctx,
-                                      U64 ifHCOutOctets_val);
+                                      struct counter64 ifHCOutOctets_val);
     int             ifHCOutOctets_undo(ifXTable_rowreq_ctx * rowreq_ctx);
 
     int             ifHCOutUcastPkts_check_value(ifXTable_rowreq_ctx *
                                                  rowreq_ctx,
-                                                 U64 ifHCOutUcastPkts_val);
+                                                 struct counter64 ifHCOutUcastPkts_val);
     int             ifHCOutUcastPkts_undo_setup(ifXTable_rowreq_ctx *
                                                 rowreq_ctx);
     int             ifHCOutUcastPkts_set(ifXTable_rowreq_ctx * rowreq_ctx,
-                                         U64 ifHCOutUcastPkts_val);
+                                         struct counter64 ifHCOutUcastPkts_val);
     int             ifHCOutUcastPkts_undo(ifXTable_rowreq_ctx *
                                           rowreq_ctx);
 
     int             ifHCOutMulticastPkts_check_value(ifXTable_rowreq_ctx *
                                                      rowreq_ctx,
-                                                     U64
+                                                     struct counter64
                                                      ifHCOutMulticastPkts_val);
     int             ifHCOutMulticastPkts_undo_setup(ifXTable_rowreq_ctx *
                                                     rowreq_ctx);
     int             ifHCOutMulticastPkts_set(ifXTable_rowreq_ctx *
                                              rowreq_ctx,
-                                             U64 ifHCOutMulticastPkts_val);
+                                             struct counter64 ifHCOutMulticastPkts_val);
     int             ifHCOutMulticastPkts_undo(ifXTable_rowreq_ctx *
                                               rowreq_ctx);
 
     int             ifHCOutBroadcastPkts_check_value(ifXTable_rowreq_ctx *
                                                      rowreq_ctx,
-                                                     U64
+                                                     struct counter64
                                                      ifHCOutBroadcastPkts_val);
     int             ifHCOutBroadcastPkts_undo_setup(ifXTable_rowreq_ctx *
                                                     rowreq_ctx);
     int             ifHCOutBroadcastPkts_set(ifXTable_rowreq_ctx *
                                              rowreq_ctx,
-                                             U64 ifHCOutBroadcastPkts_val);
+                                             struct counter64 ifHCOutBroadcastPkts_val);
     int             ifHCOutBroadcastPkts_undo(ifXTable_rowreq_ctx *
                                               rowreq_ctx);
 
diff --git a/agent/mibgroup/if-mib/ifXTable/ifXTable_interface.c b/agent/mibgroup/if-mib/ifXTable/ifXTable_interface.c
index 23b50d0..e561842 100644
--- a/agent/mibgroup/if-mib/ifXTable/ifXTable_interface.c
+++ b/agent/mibgroup/if-mib/ifXTable/ifXTable_interface.c
@@ -729,72 +729,72 @@ _ifXTable_get_column(ifXTable_rowreq_ctx * rowreq_ctx,
          * ifHCInOctets(6)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCINOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCInOctets_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCInOctets_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
          * ifHCInUcastPkts(7)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCINUCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCInUcastPkts_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCInUcastPkts_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
          * ifHCInMulticastPkts(8)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCINMULTICASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCInMulticastPkts_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCInMulticastPkts_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
          * ifHCInBroadcastPkts(9)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCINBROADCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCInBroadcastPkts_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCInBroadcastPkts_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
          * ifHCOutOctets(10)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCOUTOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCOutOctets_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCOutOctets_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
          * ifHCOutUcastPkts(11)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCOUTUCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCOutUcastPkts_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCOutUcastPkts_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
          * ifHCOutMulticastPkts(12)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCOUTMULTICASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCOutMulticastPkts_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCOutMulticastPkts_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
          * ifHCOutBroadcastPkts(13)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IFHCOUTBROADCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ifHCOutBroadcastPkts_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ifHCOutBroadcastPkts_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route.h b/agent/mibgroup/ip-forward-mib/data_access/route.h
index 2c731a6..632b396 100644
--- a/agent/mibgroup/ip-forward-mib/data_access/route.h
+++ b/agent/mibgroup/ip-forward-mib/data_access/route.h
@@ -24,7 +24,7 @@ config_require(ip-forward-mib/data_access/route_linux)
 config_require(ip-forward-mib/data_access/route_ioctl)
 #elif defined( freebsd7 ) || defined( netbsd5 ) || defined( openbsd4 ) || defined( dragonfly ) || defined( darwin )
 config_require(ip-forward-mib/data_access/route_sysctl)
-#elif defined(solaris2) && defined( HAVE_MIB2_IPIFSTATSENTRY_T )
+#elif defined(solaris2)
 config_require(ip-forward-mib/data_access/route_solaris)
 #else
 config_error(the route data access library is not available in this environment.)
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route_common.c b/agent/mibgroup/ip-forward-mib/data_access/route_common.c
index 84c1810..a5b957c 100644
--- a/agent/mibgroup/ip-forward-mib/data_access/route_common.c
+++ b/agent/mibgroup/ip-forward-mib/data_access/route_common.c
@@ -9,6 +9,8 @@
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/route.h>
+#include "route.h"
+#include "route_private.h"
 
 /**---------------------------------------------------------------------*/
 /*
@@ -18,21 +20,6 @@ static void _access_route_entry_release(netsnmp_route_entry * entry, void *unuse
 
 /**---------------------------------------------------------------------*/
 /*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-extern int netsnmp_access_route_container_arch_load(netsnmp_container* container,
-                                                    u_int load_flags);
-extern int
-netsnmp_arch_route_create(netsnmp_route_entry *entry);
-extern int
-netsnmp_arch_route_delete(netsnmp_route_entry *entry);
-
-
-/**---------------------------------------------------------------------*/
-/*
  * container functions
  */
 
@@ -84,6 +71,12 @@ netsnmp_access_route_container_free(netsnmp_container *container, u_int free_fla
                         (netsnmp_container_obj_func*)_access_route_entry_release,
                         NULL);
     }
+    else {
+        /*
+         * free the CONTAINER's sl_nodes, but not their data
+         */
+        CONTAINER_CLEAR(container, NULL, NULL);
+    }
 
     if(! (free_flags & NETSNMP_ACCESS_ROUTE_FREE_KEEP_CONTAINER))
         CONTAINER_FREE(container);
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c b/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c
index ff89161..edaf05c 100644
--- a/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c
+++ b/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c
@@ -178,6 +178,7 @@ int _netsnmp_ioctl_route_delete_v4(netsnmp_route_entry * entry)
     else
 	mask.sin_addr.s_addr = entry->rt_mask;
 
+    memset(&gateway, 0, sizeof(gateway));
     gateway.sin_family = AF_INET;
     memcpy(&gateway.sin_addr.s_addr, entry->rt_nexthop, 4);
 
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route_linux.c b/agent/mibgroup/ip-forward-mib/data_access/route_linux.c
index 0f80fe8..7e13084 100644
--- a/agent/mibgroup/ip-forward-mib/data_access/route_linux.c
+++ b/agent/mibgroup/ip-forward-mib/data_access/route_linux.c
@@ -15,6 +15,8 @@
 #include "ip-forward-mib/data_access/route_ioctl.h"
 #include "ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable_constants.h"
 #include "if-mib/data_access/interface_ioctl.h"
+#include "route.h"
+#include "route_private.h"
 
 static int
 _type_from_flags(unsigned int flags)
@@ -215,7 +217,6 @@ _load_ipv6(netsnmp_container* container, u_long *index )
         return -2;
     }
     
-    fgets(line,sizeof(line),in); /* skip header */
     while (fgets(line, sizeof(line), in)) {
         char            c_name[IFNAMSIZ+1];
         char            c_dest[33], c_src[33], c_next[33];
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route_private.h b/agent/mibgroup/ip-forward-mib/data_access/route_private.h
new file mode 100644
index 0000000..8cda4fe
--- /dev/null
+++ b/agent/mibgroup/ip-forward-mib/data_access/route_private.h
@@ -0,0 +1,7 @@
+struct netsnmp_container_s;
+struct netsnmp_route_s;
+
+int netsnmp_access_route_container_arch_load(struct netsnmp_container_s* container,
+                                             u_int load_flags);
+int netsnmp_arch_route_create(struct netsnmp_route_s *entry);
+int netsnmp_arch_route_delete(struct netsnmp_route_s *entry);
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route_solaris.c b/agent/mibgroup/ip-forward-mib/data_access/route_solaris.c
index 5d8ad22..82612ed 100644
--- a/agent/mibgroup/ip-forward-mib/data_access/route_solaris.c
+++ b/agent/mibgroup/ip-forward-mib/data_access/route_solaris.c
@@ -18,6 +18,7 @@
 #include "ip-forward-mib/data_access/route_ioctl.h"
 #include "ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable_constants.h"
 #include "if-mib/data_access/interface_ioctl.h"
+#include "route_private.h"
 
 static int _load_v4(netsnmp_container *container, u_long *count);
 static int _load_v6(netsnmp_container *container, u_long *count);
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route_sysctl.c b/agent/mibgroup/ip-forward-mib/data_access/route_sysctl.c
index d4f926b..3f4f3eb 100644
--- a/agent/mibgroup/ip-forward-mib/data_access/route_sysctl.c
+++ b/agent/mibgroup/ip-forward-mib/data_access/route_sysctl.c
@@ -16,6 +16,7 @@
 #include "ip-forward-mib/data_access/route_sysctl.h"
 #include "ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable_constants.h"
 #include "if-mib/data_access/interface_ioctl.h"
+#include "route_private.h"
 
 static int _load_ipv4(netsnmp_container*, int*);
 static int _load_ipv6(netsnmp_container*, int*);
@@ -223,6 +224,14 @@ _load_routing_table_from_sysctl(netsnmp_container* container, int *index,
          */
         if (rtm->rtm_addrs == RTA_DST)
             continue;
+#ifdef RTF_CLONED
+	if (rtm->rtm_flags & RTF_CLONED)
+	    continue;
+#endif
+#ifdef RTF_WASCLONED
+	if (rtm->rtm_flags & RTF_WASCLONED)
+	    continue;
+#endif
 
         entry = netsnmp_access_route_entry_create();
         if (entry == NULL)
diff --git a/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable.c b/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable.c
index 0f013ea..8222c5e 100644
--- a/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable.c
+++ b/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable.c
@@ -419,9 +419,10 @@ inetCidrRouteTable_indexes_set_tbl_idx(inetCidrRouteTable_mib_index *
     /*
      * make sure there is enough space for inetCidrRoutePolicy data
      */
-    if ((NULL == tbl_idx->inetCidrRoutePolicy) ||
-        (tbl_idx->inetCidrRoutePolicy_len <
-         (inetCidrRoutePolicy_val_ptr_len / sizeof(inetCidrRoutePolicy_val_ptr[0])))) {
+    if (tbl_idx->inetCidrRoutePolicy == NULL ||
+        inetCidrRoutePolicy_val_ptr_len >
+        tbl_idx->inetCidrRoutePolicy_len *
+        sizeof(inetCidrRoutePolicy_val_ptr[0])) {
         snmp_log(LOG_ERR,
 	    "inetCidrRoutePolicy: Not enough space for value (%d < %d)\n",
 	    (int)tbl_idx->inetCidrRoutePolicy_len,
diff --git a/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable_interface.c b/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable_interface.c
index 5df46b6..2677d16 100644
--- a/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable_interface.c
+++ b/agent/mibgroup/ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable_interface.c
@@ -294,10 +294,12 @@ _inetCidrRouteTable_initialize_interface(inetCidrRouteTable_registration *
         netsnmp_handler_registration_create("inetCidrRouteTable", handler,
                                             inetCidrRouteTable_oid,
                                             inetCidrRouteTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #ifndef NETSNMP_DISABLE_SET_SUPPORT
-                                          | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_DISABLE_SET_SUPPORT */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR, "error registering table inetCidrRouteTable\n");
diff --git a/agent/mibgroup/ip-mib/data_access/arp_linux.c b/agent/mibgroup/ip-mib/data_access/arp_linux.c
index a2fa49a..1d66bc5 100644
--- a/agent/mibgroup/ip-mib/data_access/arp_linux.c
+++ b/agent/mibgroup/ip-mib/data_access/arp_linux.c
@@ -95,7 +95,7 @@ _load_v4(netsnmp_arp_access *access)
 
 #define PROCFILE "/proc/net/arp"
     if (!(in = fopen(PROCFILE, "r"))) {
-        snmp_log(LOG_DEBUG,"could not open " PROCFILE "\n");
+        snmp_log_perror("arp_linux: could not open " PROCFILE);
         return -2;
     }
 
diff --git a/agent/mibgroup/ip-mib/data_access/arp_netlink.c b/agent/mibgroup/ip-mib/data_access/arp_netlink.c
index 2059c23..41c0a62 100644
--- a/agent/mibgroup/ip-mib/data_access/arp_netlink.c
+++ b/agent/mibgroup/ip-mib/data_access/arp_netlink.c
@@ -78,7 +78,7 @@ int netsnmp_access_arp_load(netsnmp_arp_access *access)
 
         fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);
         if (fd < 0) {
-            snmp_log(LOG_ERR,"netsnmp_access_arp_load: netlink socket create error\n");
+            snmp_log_perror("netsnmp_access_arp_load: netlink socket create error");
             return -1;
         }
         access->arch_magic = (void *)(uintptr_t)fd;
@@ -87,7 +87,7 @@ int netsnmp_access_arp_load(netsnmp_arp_access *access)
         sa.nl_family = AF_NETLINK;
         sa.nl_groups = RTMGRP_NEIGH;
         if (bind(fd, (struct sockaddr*) &sa, sizeof(sa)) < 0) {
-            snmp_log(LOG_ERR,"netsnmp_access_arp_load: netlink bind failed\n");
+            snmp_log_perror("netsnmp_access_arp_load: netlink bind failed");
             return -1;
         }
 
@@ -109,7 +109,7 @@ int netsnmp_access_arp_load(netsnmp_arp_access *access)
 
     r = send(fd, &req, req.n.nlmsg_len, 0);
     if (r < 0) {
-        snmp_log(LOG_ERR,"netsnmp_access_arp_refresh: send failed\n");
+        snmp_log_perror("netsnmp_access_arp_refresh: send failed");
         return -1;
     }
 
@@ -157,7 +157,7 @@ static void netsnmp_access_arp_read_netlink(int fd, void *data)
 		*access->cache_expired = 1;
             return;
         }
-    } while (0);
+    } while (r < 0 && errno == EINTR);
     len = r;
 
     for (h = (struct nlmsghdr *) buf; NLMSG_OK(h, len); h = NLMSG_NEXT(h, len)) {
@@ -212,6 +212,14 @@ fillup_entry_info(netsnmp_arp_entry *entry, struct nlmsghdr *nlmp)
         return -1;
     }
 
+    if (rtmp->ndm_family != AF_INET && rtmp->ndm_family != AF_INET6) {
+        /* Some address families, notably AF_BRIDGE, have RTM_NEWNEIGH
+         * and RTM_DELNEIGH messages that may not contain an IP address
+         * that we need later. So we drop everything that is not AF_INET or
+         * AF_INET6 silently.*/
+        return 0;
+    }
+
     if (rtmp->ndm_state == NUD_NOARP) {
         /* NUD_NOARP is for broadcast addresses and similar,
          * drop them silently */
diff --git a/agent/mibgroup/ip-mib/data_access/defaultrouter.h b/agent/mibgroup/ip-mib/data_access/defaultrouter.h
index 49b9927..53584d9 100644
--- a/agent/mibgroup/ip-mib/data_access/defaultrouter.h
+++ b/agent/mibgroup/ip-mib/data_access/defaultrouter.h
@@ -22,6 +22,8 @@ config_require(ip-mib/data_access/defaultrouter_common)
 config_require(ip-mib/data_access/defaultrouter_linux)
 #elif defined( freebsd4 ) || defined( netbsd5 ) || defined( openbsd ) || defined( dragonfly ) || defined( darwin )
 config_require(ip-mib/data_access/defaultrouter_sysctl)
+#elif defined( solaris2 )
+config_require(ip-mib/data_access/defaultrouter_solaris2)
 #else
 /*
  * couldn't determine the correct file!
diff --git a/agent/mibgroup/ip-mib/data_access/defaultrouter_common.c b/agent/mibgroup/ip-mib/data_access/defaultrouter_common.c
index ae85bfa..a65f98c 100644
--- a/agent/mibgroup/ip-mib/data_access/defaultrouter_common.c
+++ b/agent/mibgroup/ip-mib/data_access/defaultrouter_common.c
@@ -10,6 +10,8 @@
 #include <net-snmp/data_access/defaultrouter.h>
 
 #include "ip-mib/ipDefaultRouterTable/ipDefaultRouterTable.h"
+#include "defaultrouter.h"
+#include "defaultrouter_private.h"
 
 /**---------------------------------------------------------------------*/
 /*
@@ -22,20 +24,6 @@ static void _access_defaultrouter_entry_release(netsnmp_defaultrouter_entry * en
 
 /**---------------------------------------------------------------------*/
 /*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-extern int
-netsnmp_arch_defaultrouter_entry_init(netsnmp_defaultrouter_entry *entry);
-
-extern int
-netsnmp_arch_defaultrouter_container_load(netsnmp_container* container,
-                                          u_int load_flags);
-
-/**---------------------------------------------------------------------*/
-/*
  * container functions
  */
 /**
diff --git a/agent/mibgroup/ip-mib/data_access/defaultrouter_linux.c b/agent/mibgroup/ip-mib/data_access/defaultrouter_linux.c
index 038016a..1a390f0 100644
--- a/agent/mibgroup/ip-mib/data_access/defaultrouter_linux.c
+++ b/agent/mibgroup/ip-mib/data_access/defaultrouter_linux.c
@@ -10,6 +10,7 @@
 #include <net-snmp/data_access/defaultrouter.h>
 
 #include "ip-mib/ipDefaultRouterTable/ipDefaultRouterTable.h"
+#include "defaultrouter_private.h"
 
 #include <asm/types.h>
 #ifdef HAVE_LINUX_RTNETLINK_H
diff --git a/agent/mibgroup/ip-mib/data_access/defaultrouter_private.h b/agent/mibgroup/ip-mib/data_access/defaultrouter_private.h
new file mode 100644
index 0000000..e8534b2
--- /dev/null
+++ b/agent/mibgroup/ip-mib/data_access/defaultrouter_private.h
@@ -0,0 +1,6 @@
+struct netsnmp_defaultrouter_s;
+struct netsnmp_container_s;
+
+int netsnmp_arch_defaultrouter_entry_init(struct netsnmp_defaultrouter_s *entry);
+int netsnmp_arch_defaultrouter_container_load(struct netsnmp_container_s *container,
+                                              u_int load_flags);
diff --git a/agent/mibgroup/ip-mib/data_access/defaultrouter_solaris2.c b/agent/mibgroup/ip-mib/data_access/defaultrouter_solaris2.c
new file mode 100644
index 0000000..b1a81b7
--- /dev/null
+++ b/agent/mibgroup/ip-mib/data_access/defaultrouter_solaris2.c
@@ -0,0 +1,142 @@
+/*
+ *  Interface MIB architecture support
+ *
+ * $Id:$
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "mibII/mibII_common.h"
+
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/data_access/defaultrouter.h>
+
+#include "ip-mib/ipDefaultRouterTable/ipDefaultRouterTable.h"
+#include "defaultrouter_private.h"
+
+#include <inet/ip.h>
+#include <inet/mib2.h>
+
+#if !defined(SA_SIZE) && !defined(RT_ROUNDUP)
+#define RT_ROUNDUP(a)  \
+        ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
+#endif
+
+/**---------------------------------------------------------------------*/
+/*
+ * local static prototypes
+ */
+static int _load_defaultrouter_from_mib2(netsnmp_container *, int);
+
+static int idx_offset;
+
+/*
+ * initialize arch specific storage
+ *
+ * @retval  0: success
+ * @retval <0: error
+ */
+int
+netsnmp_arch_defaultrouter_entry_init(netsnmp_defaultrouter_entry *entry)
+{
+    /*
+     * init
+     */
+    return 0;
+}
+
+/**
+ *
+ * @retval  0 no errors
+ * @retval !0 errors
+ */
+int
+netsnmp_arch_defaultrouter_container_load(netsnmp_container *container,
+                                          u_int load_flags)
+{
+    int err;
+
+    err = 0;
+    idx_offset = 0;
+
+    DEBUGMSGTL(("access:defaultrouter:entry:arch", "load\n"));
+    if (NULL == container) {
+        snmp_log(LOG_ERR,
+            "netsnmp_arch_defaultrouter_container_load: container invalid\n");
+        return 1;
+    }
+
+    err = _load_defaultrouter_from_mib2(container, AF_INET);
+    if (err != 0) {
+        u_int flags = NETSNMP_ACCESS_DEFAULTROUTER_FREE_KEEP_CONTAINER;
+        netsnmp_access_defaultrouter_container_free(container, flags);
+        goto out;
+    }
+
+#ifdef NETSNMP_ENABLE_IPV6
+    err = _load_defaultrouter_from_mib2(container, AF_INET6);
+    if (err != 0) {
+        u_int flags = NETSNMP_ACCESS_DEFAULTROUTER_FREE_KEEP_CONTAINER;
+        netsnmp_access_defaultrouter_container_free(container, flags);
+        goto out;
+    }
+#endif
+
+out:
+    return err;
+}
+
+
+static int
+IP_Cmp_Route(void *addr, void *ep)
+{
+    return (0);             /* found */
+}
+
+
+/**
+ *
+ * @retval  0 no errors
+ * @retval !0 errors
+ */
+static int
+_load_defaultrouter_from_mib2(netsnmp_container *container, int family)
+{
+    netsnmp_defaultrouter_entry *entry;
+    mib2_ipRouteEntry_t Curentry, Nextentry;
+    int req_type;
+    int err = 0;
+    int idx_offset = 0;
+
+    for (Nextentry.ipRouteDest = (u_long) -2, req_type = GET_FIRST;;
+             Nextentry = Curentry, req_type = GET_NEXT) {
+        if (getMibstat(MIB_IP_ROUTE, &Curentry, sizeof(mib2_ipRouteEntry_t),
+                       req_type, &IP_Cmp_Route, &Nextentry) != 0)
+            break;
+	DEBUGMSGTL(("access:defaultrouter", "nexthop %x type %x\n", Curentry.ipRouteNextHop, Curentry.ipRouteInfo.re_ire_type));
+        if (!(Curentry.ipRouteInfo.re_ire_type & IRE_DEFAULT))
+            continue;
+        entry = netsnmp_access_defaultrouter_entry_create();
+	Curentry.ipRouteIfIndex.o_bytes[Curentry.ipRouteIfIndex.o_length] = '\0';
+        entry->ns_dr_index = ++idx_offset;
+        entry->dr_if_index = netsnmp_access_interface_index_find(
+                Curentry.ipRouteIfIndex.o_bytes);
+
+        entry->dr_addresstype = INETADDRESSTYPE_IPV4;
+        entry->dr_address_len = 4;
+        memcpy(entry->dr_address, &Curentry.ipRouteNextHop, 4);
+
+        entry->dr_lifetime = Curentry.ipRouteAge;
+        entry->dr_preference = Curentry.ipRouteMetric1;
+
+        if ((err = CONTAINER_INSERT(container, entry)) < 0) {
+            DEBUGMSGTL(("access:defaultrouter:container",
+                        "error with defaultrouter_entry: "
+                        "insert into container failed.\n"));
+            netsnmp_access_defaultrouter_entry_free(entry);
+            // goto out;
+        }
+    }
+
+out:
+    return 0;
+}
diff --git a/agent/mibgroup/ip-mib/data_access/defaultrouter_sysctl.c b/agent/mibgroup/ip-mib/data_access/defaultrouter_sysctl.c
index dc46eb8..c5e6210 100644
--- a/agent/mibgroup/ip-mib/data_access/defaultrouter_sysctl.c
+++ b/agent/mibgroup/ip-mib/data_access/defaultrouter_sysctl.c
@@ -10,6 +10,7 @@
 #include <net-snmp/data_access/defaultrouter.h>
 
 #include "ip-mib/ipDefaultRouterTable/ipDefaultRouterTable.h"
+#include "defaultrouter_private.h"
 
 #include <sys/param.h>
 #include <sys/socket.h>
diff --git a/agent/mibgroup/ip-mib/data_access/ipaddress.h b/agent/mibgroup/ip-mib/data_access/ipaddress.h
index d79c7c2..029ae96 100644
--- a/agent/mibgroup/ip-mib/data_access/ipaddress.h
+++ b/agent/mibgroup/ip-mib/data_access/ipaddress.h
@@ -28,3 +28,4 @@ config_require(ip-mib/data_access/ipaddress_sysctl)
 config_error(the ipaddress data access library is not available in this environment.)
 #endif
 
+struct address_flag_info netsnmp_access_other_info_get(int index, int family);
diff --git a/agent/mibgroup/ip-mib/data_access/ipaddress_common.c b/agent/mibgroup/ip-mib/data_access/ipaddress_common.c
index a663985..468d7d1 100644
--- a/agent/mibgroup/ip-mib/data_access/ipaddress_common.c
+++ b/agent/mibgroup/ip-mib/data_access/ipaddress_common.c
@@ -11,6 +11,8 @@
 #include <net-snmp/data_access/interface.h>
 
 #include "ip-mib/ipAddressTable/ipAddressTable_constants.h"
+#include "ipaddress.h"
+#include "ipaddress_private.h"
 
 #include <net-snmp/net-snmp-features.h>
 
@@ -36,29 +38,6 @@ static void _access_ipaddress_entry_release(netsnmp_ipaddress_entry * entry,
 
 /**---------------------------------------------------------------------*/
 /*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-extern int
-netsnmp_arch_ipaddress_container_load(netsnmp_container* container,
-                                      u_int load_flags);
-extern int
-netsnmp_arch_ipaddress_entry_init(netsnmp_ipaddress_entry *entry);
-extern int
-netsnmp_arch_ipaddress_entry_copy(netsnmp_ipaddress_entry *lhs,
-                                  netsnmp_ipaddress_entry *rhs);
-extern void
-netsnmp_arch_ipaddress_entry_cleanup(netsnmp_ipaddress_entry *entry);
-extern int
-netsnmp_arch_ipaddress_create(netsnmp_ipaddress_entry *entry);
-extern int
-netsnmp_arch_ipaddress_delete(netsnmp_ipaddress_entry *entry);
-
-
-/**---------------------------------------------------------------------*/
-/*
  * container functions
  */
 /**
diff --git a/agent/mibgroup/ip-mib/data_access/ipaddress_ioctl.c b/agent/mibgroup/ip-mib/data_access/ipaddress_ioctl.c
index 6025f05..6588898 100644
--- a/agent/mibgroup/ip-mib/data_access/ipaddress_ioctl.c
+++ b/agent/mibgroup/ip-mib/data_access/ipaddress_ioctl.c
@@ -145,7 +145,7 @@ _netsnmp_ioctl_ipaddress_container_load_v4(netsnmp_container *container,
     _ioctl_extras           *extras;
 
     if ((sd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-        snmp_log(LOG_ERR, "could not create socket\n");
+        snmp_log_perror("_netsnmp_ioctl_ipaddress_container_load_v4: could not create socket");
         return -1;
     }
 
@@ -322,8 +322,10 @@ _netsnmp_ioctl_ipaddress_container_load_v4(netsnmp_container *container,
                           " if %d: addr len %d, index 0x%" NETSNMP_PRIo "x\n",
                           i, entry->ia_address_len, entry->if_index));
             if (4 == entry->ia_address_len)
-                DEBUGMSGT_NC(("access:ipaddress:container", " address %p\n",
-                              *((void**)entry->ia_address)));
+                DEBUGMSGT_NC(("access:ipaddress:container",
+                              " address %d.%d.%d.%d\n",
+                              entry->ia_address[0], entry->ia_address[1],
+                              entry->ia_address[2], entry->ia_address[3]));
             DEBUGMSGT_NC(("access:ipaddress:container", "flags 0x%x\n",
                           extras->flags));
             _print_flags(extras->flags);
@@ -383,7 +385,7 @@ _next_alias(const char *if_name)
     len = strlen(if_name);
 
     if ((sd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-        snmp_log(LOG_ERR, "could not create socket\n");
+        snmp_log_perror("_next_alias: could not create socket");
         return -1;
     }
 
@@ -469,7 +471,7 @@ _netsnmp_ioctl_ipaddress_set_v4(netsnmp_ipaddress_entry * entry)
 
     fd = socket(AF_INET, SOCK_DGRAM, 0);
     if(fd < 0) {
-        snmp_log(LOG_ERR,"couldn't create socket\n");
+        snmp_log_perror("_netsnmp_ioctl_ipaddress_set_v4: couldn't create socket");
         return -2;
     }
     memset(&ifrq, 0, sizeof(ifrq));
@@ -537,7 +539,7 @@ _netsnmp_ioctl_ipaddress_delete_v4(netsnmp_ipaddress_entry * entry)
 
     fd = socket(AF_INET, SOCK_DGRAM, 0);
     if(fd < 0) {
-        snmp_log(LOG_ERR,"couldn't create socket\n");
+        snmp_log_perror("_netsnmp_ioctl_ipaddress_delete_v4: couldn't create socket");
         return -2;
     }
 
@@ -591,7 +593,7 @@ _netsnmp_ioctl_ipaddress_v6(netsnmp_ipaddress_entry * entry, int operation)
 
     fd = socket(AF_INET6, SOCK_DGRAM, 0);
     if(fd < 0) {
-        snmp_log(LOG_ERR,"couldn't create socket\n");
+        snmp_log_perror("_netsnmp_ioctl_ipaddress_v6: couldn't create socket");
         return -2;
     }
     memset(&ifrq, 0, sizeof(ifrq));
diff --git a/agent/mibgroup/ip-mib/data_access/ipaddress_linux.c b/agent/mibgroup/ip-mib/data_access/ipaddress_linux.c
index f1cef0a..8743130 100644
--- a/agent/mibgroup/ip-mib/data_access/ipaddress_linux.c
+++ b/agent/mibgroup/ip-mib/data_access/ipaddress_linux.c
@@ -15,6 +15,7 @@
 #include "ip-mib/ipAddressTable/ipAddressTable_constants.h"
 #include "ip-mib/ipAddressPrefixTable/ipAddressPrefixTable_constants.h"
 #include "mibgroup/util_funcs.h"
+#include "../../if-mib/data_access/interface_private.h"
 
 #include <errno.h>
 #include <sys/ioctl.h>
@@ -40,11 +41,12 @@ netsnmp_feature_require(ipaddress_ioctl_entry_copy)
 #endif /* HAVE_LINUX_RTNETLINK_H */
 #endif
 
+#include "ipaddress.h"
 #include "ipaddress_ioctl.h"
-#ifdef SUPPORT_PREFIX_FLAGS
-extern prefix_cbx *prefix_head_list;
-#endif
+#include "ipaddress_private.h"
+
 int _load_v6(netsnmp_container *container, int idx_offset);
+
 #ifdef HAVE_LINUX_RTNETLINK_H
 int
 netsnmp_access_ipaddress_extra_prefix_info(int index,
@@ -232,7 +234,7 @@ _load_v6(netsnmp_container *container, int idx_offset)
 
 #define PROCFILE "/proc/net/if_inet6"
     if (!(in = fopen(PROCFILE, "r"))) {
-        DEBUGMSGTL(("access:ipaddress:container","could not open " PROCFILE "\n"));
+        snmp_log_perror("ipaddress_linux: could not open " PROCFILE);
         return -2;
     }
 
@@ -275,8 +277,7 @@ _load_v6(netsnmp_container *container, int idx_offset)
         buf = entry->ia_address;
         if(1 != netsnmp_hex_to_binary(&buf, &in_len,
                                       &out_len, 0, addr, ":")) {
-            snmp_log(LOG_ERR,"error parsing '%s', skipping\n",
-                     entry->ia_address);
+            snmp_log(LOG_ERR,"error parsing '%s', skipping\n", addr);
             netsnmp_access_ipaddress_entry_free(entry);
             continue;
         }
@@ -433,7 +434,7 @@ netsnmp_access_other_info_get(int index, int family)
    memset(&addr, 0, sizeof(struct address_flag_info));
    sd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);
    if(sd < 0) {
-      snmp_log(LOG_ERR, "could not open netlink socket\n");
+      snmp_log_perror("ipaddress_linux: could not open netlink socket");
       return addr;
    }
 
@@ -450,19 +451,19 @@ netsnmp_access_other_info_get(int index, int family)
 
     status = send(sd, &req, req.n.nlmsg_len, 0);
     if (status < 0) {
-        snmp_log(LOG_ERR, "could not send netlink request\n");
-        return addr;
+        snmp_log_perror("ipadress_linux: could not send netlink request");
+        goto out;
     }
 
     status = recv(sd, buf, sizeof(buf), 0);
     if (status < 0) {
-        snmp_log (LOG_ERR, "could not recieve netlink request\n");
-        return addr;
+        snmp_log_perror("ipadress_linux: could not receive netlink request");
+        goto out;
     }
 
     if(status == 0) {
-       snmp_log (LOG_ERR, "nothing to read\n");
-       return addr;
+       snmp_log (LOG_ERR, "ipadress_linux: nothing to read\n");
+       goto out;
     }
 
     for(nlmp = (struct nlmsghdr *)buf; status > sizeof(*nlmp);) {
@@ -471,12 +472,12 @@ netsnmp_access_other_info_get(int index, int family)
 
         if (req_len < 0 || len > status) {
             snmp_log (LOG_ERR, "invalid netlink message\n");
-            return addr;
+            goto out;
         }
 
         if (!NLMSG_OK(nlmp, status)) {
             snmp_log (LOG_ERR, "invalid NLMSG message\n");
-            return addr;
+            goto out;
         }
         rtmp = (struct ifaddrmsg *)NLMSG_DATA(nlmp);
         rtatp = (struct rtattr *)IFA_RTA(rtmp);
@@ -496,6 +497,7 @@ netsnmp_access_other_info_get(int index, int family)
         status -= NLMSG_ALIGN(len);
         nlmp = (struct nlmsghdr*)((char*)nlmp + NLMSG_ALIGN(len));
     }
+out:
     close(sd);
     return addr;
 #endif
diff --git a/agent/mibgroup/ip-mib/data_access/ipaddress_private.h b/agent/mibgroup/ip-mib/data_access/ipaddress_private.h
new file mode 100644
index 0000000..61107c7
--- /dev/null
+++ b/agent/mibgroup/ip-mib/data_access/ipaddress_private.h
@@ -0,0 +1,10 @@
+int netsnmp_arch_ipaddress_container_load(netsnmp_container *container,
+                                          u_int load_flags);
+int netsnmp_arch_ipaddress_entry_init(netsnmp_ipaddress_entry *entry);
+void netsnmp_arch_ipaddress_entry_cleanup(netsnmp_ipaddress_entry *entry);
+int netsnmp_arch_ipaddress_entry_copy(netsnmp_ipaddress_entry *lhs,
+                                  netsnmp_ipaddress_entry *rhs);
+int netsnmp_arch_ipaddress_create(netsnmp_ipaddress_entry *entry);
+int netsnmp_arch_ipaddress_delete(netsnmp_ipaddress_entry *entry);
+int netsnmp_arch_ipaddress_container_load(netsnmp_container *container,
+                                      u_int load_flags);
diff --git a/agent/mibgroup/ip-mib/data_access/ipaddress_solaris2.c b/agent/mibgroup/ip-mib/data_access/ipaddress_solaris2.c
index e2485e3..884bfe8 100644
--- a/agent/mibgroup/ip-mib/data_access/ipaddress_solaris2.c
+++ b/agent/mibgroup/ip-mib/data_access/ipaddress_solaris2.c
@@ -11,6 +11,7 @@
 #include <net-snmp/data_access/interface.h>
 
 #include "ip-mib/ipAddressTable/ipAddressTable_constants.h"
+#include "ipaddress_private.h"
 
 #include "kernel_sunos5.h"
 #include "mibII/mibII_common.h"
@@ -148,11 +149,11 @@ _load_v4(netsnmp_container *container, int idx_offset)
     while ((rc = getMibstat(MIB_IP_ADDR, &ipae, sizeof(ipae), req,
                             &Get_everything, NULL)) == 0) {
         req = GET_NEXT;
+        if (ipae.ipAdEntAddr == INADDR_ANY)
+            continue;
         entry = netsnmp_access_ipaddress_entry_create();
         if (entry == NULL)
             return (-1);    
-        if (ipae.ipAdEntAddr == INADDR_ANY)
-            continue;
 
         ipae.ipAdEntIfIndex.o_bytes[ipae.ipAdEntIfIndex.o_length] = '\0';
         DEBUGMSGTL(("access:ipaddress:container", "found if %s\n",
diff --git a/agent/mibgroup/ip-mib/data_access/ipaddress_sysctl.c b/agent/mibgroup/ip-mib/data_access/ipaddress_sysctl.c
index 0a6221b..5bee10f 100644
--- a/agent/mibgroup/ip-mib/data_access/ipaddress_sysctl.c
+++ b/agent/mibgroup/ip-mib/data_access/ipaddress_sysctl.c
@@ -30,9 +30,8 @@ netsnmp_feature_require(ipaddress_ioctl_entry_copy)
 #endif /* NETSNMP_FEATURE_REQUIRE_IPADDRESS_ARCH_ENTRY_COPY */
 
 #include "ipaddress_ioctl.h"
-#ifdef SUPPORT_PREFIX_FLAGS
-extern prefix_cbx *prefix_head_list;
-#endif
+#include "ipaddress_private.h"
+#include "if-mib/data_access/interface_private.h"
 
 #define ROUNDUP(a) \
   ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
diff --git a/agent/mibgroup/ip-mib/data_access/ipv6scopezone_common.c b/agent/mibgroup/ip-mib/data_access/ipv6scopezone_common.c
index 7462ebe..ec9bf97 100644
--- a/agent/mibgroup/ip-mib/data_access/ipv6scopezone_common.c
+++ b/agent/mibgroup/ip-mib/data_access/ipv6scopezone_common.c
@@ -8,25 +8,14 @@
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/scopezone.h>
+#include "ipv6scopezone_private.h"
+
 /*
  * local static prototypes
  */
 static void _entry_release(netsnmp_v6scopezone_entry * entry, void *unused);
 
 
-/**---------------------------------------------------------------------*/
-/*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-extern int
-netsnmp_access_scopezone_container_arch_load(netsnmp_container* container,
-                                             u_int load_flags);
-extern void
-netsnmp_access_scopezone_arch_init(void);
-
 /**
  * initialize systemstats container
  */
diff --git a/agent/mibgroup/ip-mib/data_access/ipv6scopezone_linux.c b/agent/mibgroup/ip-mib/data_access/ipv6scopezone_linux.c
index 7d60641..bfe5ce7 100644
--- a/agent/mibgroup/ip-mib/data_access/ipv6scopezone_linux.c
+++ b/agent/mibgroup/ip-mib/data_access/ipv6scopezone_linux.c
@@ -8,6 +8,7 @@
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/scopezone.h>
+#include "ipv6scopezone_private.h"
 
 #if defined (NETSNMP_ENABLE_IPV6)
 static int _scopezone_v6(netsnmp_container* container, int idx_offset);
diff --git a/agent/mibgroup/ip-mib/data_access/ipv6scopezone_private.h b/agent/mibgroup/ip-mib/data_access/ipv6scopezone_private.h
new file mode 100644
index 0000000..89aa9d3
--- /dev/null
+++ b/agent/mibgroup/ip-mib/data_access/ipv6scopezone_private.h
@@ -0,0 +1,2 @@
+int netsnmp_access_scopezone_container_arch_load(netsnmp_container* container,
+                                                 u_int load_flags);
diff --git a/agent/mibgroup/ip-mib/data_access/systemstats_common.c b/agent/mibgroup/ip-mib/data_access/systemstats_common.c
index 29109bd..7cb15b5 100644
--- a/agent/mibgroup/ip-mib/data_access/systemstats_common.c
+++ b/agent/mibgroup/ip-mib/data_access/systemstats_common.c
@@ -10,6 +10,8 @@
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/ipstats.h>
 #include <net-snmp/data_access/systemstats.h>
+#include "systemstats.h"
+#include "systemstats_private.h"
 
 /**---------------------------------------------------------------------*/
 /*
@@ -24,19 +26,6 @@ static void _entry_release(netsnmp_systemstats_entry * entry, void *unused);
 
 /**---------------------------------------------------------------------*/
 /*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-extern int
-netsnmp_access_systemstats_container_arch_load(netsnmp_container* container,
-                                             u_int load_flags);
-extern void
-netsnmp_access_systemstats_arch_init(void);
-
-/**---------------------------------------------------------------------*/
-/*
  * initialization
  */
 void
@@ -264,7 +253,7 @@ _calculate_entries(netsnmp_systemstats_entry * entry)
            && entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTFRAGCREATES]
         && entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTDISCARDS]) {
 
-        U64 tmp, tmp2, tmp3;
+        struct counter64 tmp, tmp2, tmp3;
         tmp = entry->stats.HCOutRequests;
         u64Incr(&tmp, &entry->stats.HCOutForwDatagrams);
         u64Incr(&tmp, &entry->stats.HCOutFragCreates);
diff --git a/agent/mibgroup/ip-mib/data_access/systemstats_linux.c b/agent/mibgroup/ip-mib/data_access/systemstats_linux.c
index 4a26e41..675398f 100644
--- a/agent/mibgroup/ip-mib/data_access/systemstats_linux.c
+++ b/agent/mibgroup/ip-mib/data_access/systemstats_linux.c
@@ -11,6 +11,8 @@
 #include <net-snmp/data_access/systemstats.h>
 
 #include "../ipSystemStatsTable/ipSystemStatsTable.h"
+#include "systemstats.h"
+#include "systemstats_private.h"
 
 #include <sys/types.h>
 #include <dirent.h>
@@ -114,9 +116,7 @@ _systemstats_v4(netsnmp_container* container, u_int load_flags)
     }
 
     if (!(devin = fopen("/proc/net/snmp", "r"))) {
-        DEBUGMSGTL(("access:systemstats",
-                    "Failed to load Systemstats Table (linux1)\n"));
-        NETSNMP_LOGONCE((LOG_ERR, "cannot open /proc/net/snmp ...\n"));
+        snmp_log_perror("systemstats_linux: cannot open /proc/net/snmp");
         return -2;
     }
 
@@ -127,7 +127,7 @@ _systemstats_v4(netsnmp_container* container, u_int load_flags)
     len = strlen(line);
     if (224 != len) {
         fclose(devin);
-        snmp_log(LOG_ERR, "unexpected header length in /proc/net/snmp."
+        snmp_log(LOG_ERR, "systemstats_linux: unexpected header length in /proc/net/snmp."
                  " %d != 224\n", len);
         return -4;
     }
@@ -279,9 +279,7 @@ _additional_systemstats_v4(netsnmp_systemstats_entry* entry,
                 "load addtional v4 (flags %u)\n", load_flags));
 
     if (!(devin = fopen("/proc/net/netstat", "r"))) {
-        DEBUGMSGTL(("access:systemstats",
-                    "cannot open /proc/net/netstat\n"));
-        NETSNMP_LOGONCE((LOG_ERR,"cannot open /proc/net/netstat\n"));
+        snmp_log_perror("systemstats_linux: cannot open /proc/net/netstat");
         return -2;
     }
 
@@ -439,7 +437,7 @@ _systemstats_v6_load_file(netsnmp_systemstats_entry *entry, FILE *devin)
                     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINMCASTOCTETS] = 1;
                 } else
                     rc = 1;
-            } else if ('N' == line[5]) {
+            } else if ('N' == line[5] && 'R' == line[7]) {
                 entry->stats.HCInNoRoutes.low = scan_val & 0xffffffff;
                 entry->stats.HCInNoRoutes.high = scan_val >> 32;
                 entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINNOROUTES] = 1;
@@ -630,7 +628,9 @@ _systemstats_v6_load_ifstats(netsnmp_container* container, u_int load_flags)
             continue;
         }
         if (NULL == (devin = fopen(dev_filename, "r"))) {
-            snmp_log(LOG_ERR, "Failed to open %s\n", dev_filename);
+            char msg[128];
+            snprintf(msg, sizeof(msg), "systemstats_linux: %s", dev_filename);
+            snmp_log_perror(dev_filename);
             continue;
         }
     
diff --git a/agent/mibgroup/ip-mib/data_access/systemstats_private.h b/agent/mibgroup/ip-mib/data_access/systemstats_private.h
new file mode 100644
index 0000000..08cb6e6
--- /dev/null
+++ b/agent/mibgroup/ip-mib/data_access/systemstats_private.h
@@ -0,0 +1,3 @@
+void netsnmp_access_systemstats_arch_init(void);
+int netsnmp_access_systemstats_container_arch_load(netsnmp_container* container,
+                                                   u_int load_flags);
diff --git a/agent/mibgroup/ip-mib/data_access/systemstats_solaris2.c b/agent/mibgroup/ip-mib/data_access/systemstats_solaris2.c
index f2ec497..c7d90de 100644
--- a/agent/mibgroup/ip-mib/data_access/systemstats_solaris2.c
+++ b/agent/mibgroup/ip-mib/data_access/systemstats_solaris2.c
@@ -5,11 +5,12 @@
 #include <net-snmp/data_access/ipstats.h>
 #include <net-snmp/data_access/systemstats.h>
 
+#include "systemstats_private.h"
 #include "kernel_sunos5.h"
 
 static int _systemstats(mibgroup_e, netsnmp_container *, u_int);
 static void _add_ipstats(mib2_ipIfStatsEntry_t *, mib2_ipIfStatsEntry_t *);
-static int _insert_entry(netsnmp_container *, mib2_ipIfStatsEntry_t *);
+static int _insert_entry(netsnmp_container *, mib2_ipIfStatsEntry_t *, int);
 
 void
 netsnmp_access_systemstats_arch_init(void)
@@ -31,9 +32,6 @@ netsnmp_access_systemstats_container_arch_load(netsnmp_container* container,
     if (container == NULL)
         return (-1);
 
-    if (load_flags & NETSNMP_ACCESS_SYSTEMSTATS_LOAD_IFTABLE)
-	return 0; /* we do not support ipIfStatsTable yet */
-
     if ((rc = _systemstats(MIB_IP_TRAFFIC_STATS, container, load_flags)) < 0)
         return (rc);
 #if defined(NETSNMP_ENABLE_IPV6)
@@ -63,10 +61,19 @@ _systemstats(mibgroup_e mib, netsnmp_container *container, u_int load_flags)
                       &Get_everything, NULL) == 0) { 
         req = GET_NEXT;
         netsnmp_assert(ipe.ipIfStatsIPVersion == ipversion);
+	if (ipe.ipIfStatsIfIndex == 0)
+	    continue;
+	if (load_flags & NETSNMP_ACCESS_SYSTEMSTATS_LOAD_IFTABLE) {
+	    if (_insert_entry(container, &ipe, ipe.ipIfStatsIfIndex) != 0)
+	        return -1;
+	}
+	else
         _add_ipstats(&iptot, &ipe);
     }
     iptot.ipIfStatsIPVersion = ipversion;
-    return _insert_entry(container, &iptot);
+    if (load_flags & NETSNMP_ACCESS_SYSTEMSTATS_LOAD_IFTABLE)
+        return 0;
+    return _insert_entry(container, &iptot, 0);
 }
 
 static void
@@ -124,18 +131,18 @@ _add_ipstats(mib2_ipIfStatsEntry_t *o1, mib2_ipIfStatsEntry_t *o2)
  * @retval -2 memory allocation error
  */
 static int 
-_insert_entry(netsnmp_container *container, mib2_ipIfStatsEntry_t *ipe)
+_insert_entry(netsnmp_container *container, mib2_ipIfStatsEntry_t *ipe, int index)
 {
     int i;
     
     netsnmp_systemstats_entry *ep =
-        netsnmp_access_systemstats_entry_create(ipe->ipIfStatsIPVersion, 0,
+        netsnmp_access_systemstats_entry_create(ipe->ipIfStatsIPVersion, index,
                 "ipSystemStatsTable"); 
 
     DEBUGMSGTL(("access:systemstats:arch", "insert entry for v%d\n",
                 ipe->ipIfStatsIPVersion)); 
     if (ep == NULL) {
-        DEBUGMSGT(("access:systemstats:arch", "insert failed (alloc)"));
+        DEBUGMSGT(("access:systemstats:arch", "insert failed (alloc)\n"));
         return (-2);
     }
 
@@ -205,7 +212,7 @@ _insert_entry(netsnmp_container *container, mib2_ipIfStatsEntry_t *ipe)
         ep->stats.columnAvail[i] = 1;
     
     if (CONTAINER_INSERT(container, ep) < 0) {
-        DEBUGMSGT(("access:systemstats:arch", "unable to insert entry")); 
+        DEBUGMSGT(("access:systemstats:arch", "unable to insert entry\n")); 
         netsnmp_access_systemstats_entry_free(ep); 
         return (-1);
     }
diff --git a/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c b/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c
index a1ca16d..f27b436 100644
--- a/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c
+++ b/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c
@@ -11,6 +11,7 @@
 #include <net-snmp/data_access/systemstats.h>
 
 #include "../ipSystemStatsTable/ipSystemStatsTable.h"
+#include "systemstats_private.h"
 
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL)
 #define _KERNEL 1
@@ -35,9 +36,10 @@
 #include <netinet/ip_icmp.h>
 #include <netinet/ip_var.h>
 #if HAVE_NETINET6_IP6_VAR_H
+#include <sys/queue.h>
 #include <netinet6/ip6_var.h>
 #endif
-#ifndef freebsd7
+#if !defined(freebsd7) && !defined(openbsd5)
 #include <netinet6/in6_var.h>
 #endif
 
diff --git a/agent/mibgroup/ip-mib/inetNetToMediaTable/inetNetToMediaTable_interface.c b/agent/mibgroup/ip-mib/inetNetToMediaTable/inetNetToMediaTable_interface.c
index c18689a..3667b82 100644
--- a/agent/mibgroup/ip-mib/inetNetToMediaTable/inetNetToMediaTable_interface.c
+++ b/agent/mibgroup/ip-mib/inetNetToMediaTable/inetNetToMediaTable_interface.c
@@ -292,10 +292,12 @@ _inetNetToMediaTable_initialize_interface(inetNetToMediaTable_registration
         netsnmp_handler_registration_create("inetNetToMediaTable", handler,
                                             inetNetToMediaTable_oid,
                                             inetNetToMediaTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #ifndef NETSNMP_DISABLE_SET_SUPPORT
-                                          | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_DISABLE_SET_SUPPORT */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR, "error registering table inetNetToMediaTable\n");
diff --git a/agent/mibgroup/ip-mib/ipAddressTable/ipAddressTable_interface.c b/agent/mibgroup/ip-mib/ipAddressTable/ipAddressTable_interface.c
index 48770b0..1130361 100644
--- a/agent/mibgroup/ip-mib/ipAddressTable/ipAddressTable_interface.c
+++ b/agent/mibgroup/ip-mib/ipAddressTable/ipAddressTable_interface.c
@@ -281,10 +281,12 @@ _ipAddressTable_initialize_interface(ipAddressTable_registration * reg_ptr,
         netsnmp_handler_registration_create("ipAddressTable", handler,
                                             ipAddressTable_oid,
                                             ipAddressTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #ifndef NETSNMP_DISABLE_SET_SUPPORT
-                                          | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_DISABLE_SET_SUPPORT */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR, "error registering table ipAddressTable\n");
diff --git a/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.c b/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.c
index db673dc..5bc5419 100644
--- a/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.c
+++ b/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.c
@@ -252,7 +252,7 @@ The total number of input IP datagrams received, including
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCInReceives data.
@@ -262,7 +262,7 @@ The total number of input IP datagrams received, including
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCInReceives_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -270,7 +270,7 @@ The total number of input IP datagrams received, including
  */
 int
 ipIfStatsHCInReceives_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                          U64 * ipIfStatsHCInReceives_val_ptr)
+                          struct counter64 *ipIfStatsHCInReceives_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCInReceives_val_ptr);
@@ -377,7 +377,7 @@ The total number of octets received in input IP datagrams,
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCInOctets data.
@@ -387,7 +387,7 @@ The total number of octets received in input IP datagrams,
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCInOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -395,7 +395,7 @@ The total number of octets received in input IP datagrams,
  */
 int
 ipIfStatsHCInOctets_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                        U64 * ipIfStatsHCInOctets_val_ptr)
+                        struct counter64 *ipIfStatsHCInOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCInOctets_val_ptr);
@@ -844,7 +844,7 @@ The number of input datagrams for which this entity was not
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCInForwDatagrams data.
@@ -854,7 +854,7 @@ The number of input datagrams for which this entity was not
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCInForwDatagrams_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -862,7 +862,7 @@ The number of input datagrams for which this entity was not
  */
 int
 ipIfStatsHCInForwDatagrams_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                               U64 * ipIfStatsHCInForwDatagrams_val_ptr)
+                               struct counter64 *ipIfStatsHCInForwDatagrams_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCInForwDatagrams_val_ptr);
@@ -1249,7 +1249,7 @@ The total number of datagrams successfully delivered to IP
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCInDelivers data.
@@ -1259,7 +1259,7 @@ The total number of datagrams successfully delivered to IP
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCInDelivers_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1267,7 +1267,7 @@ The total number of datagrams successfully delivered to IP
  */
 int
 ipIfStatsHCInDelivers_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                          U64 * ipIfStatsHCInDelivers_val_ptr)
+                          struct counter64 *ipIfStatsHCInDelivers_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCInDelivers_val_ptr);
@@ -1378,7 +1378,7 @@ The total number of IP datagrams that local IP user-
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCOutRequests data.
@@ -1388,7 +1388,7 @@ The total number of IP datagrams that local IP user-
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCOutRequests_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1396,7 +1396,7 @@ The total number of IP datagrams that local IP user-
  */
 int
 ipIfStatsHCOutRequests_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                           U64 * ipIfStatsHCOutRequests_val_ptr)
+                           struct counter64 *ipIfStatsHCOutRequests_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCOutRequests_val_ptr);
@@ -1514,7 +1514,7 @@ The number of datagrams for which this entity was not their
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCOutForwDatagrams data.
@@ -1524,7 +1524,7 @@ The number of datagrams for which this entity was not their
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCOutForwDatagrams_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1532,7 +1532,7 @@ The number of datagrams for which this entity was not their
  */
 int
 ipIfStatsHCOutForwDatagrams_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                                U64 * ipIfStatsHCOutForwDatagrams_val_ptr)
+                                struct counter64 *ipIfStatsHCOutForwDatagrams_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCOutForwDatagrams_val_ptr);
@@ -1981,7 +1981,7 @@ The total number of IP datagrams that this entity supplied
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCOutTransmits data.
@@ -1991,7 +1991,7 @@ The total number of IP datagrams that this entity supplied
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCOutTransmits_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1999,7 +1999,7 @@ The total number of IP datagrams that this entity supplied
  */
 int
 ipIfStatsHCOutTransmits_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                            U64 * ipIfStatsHCOutTransmits_val_ptr)
+                            struct counter64 *ipIfStatsHCOutTransmits_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCOutTransmits_val_ptr);
@@ -2105,7 +2105,7 @@ The total number of octets in IP datagrams delivered to the
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCOutOctets data.
@@ -2115,7 +2115,7 @@ The total number of octets in IP datagrams delivered to the
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCOutOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2123,7 +2123,7 @@ The total number of octets in IP datagrams delivered to the
  */
 int
 ipIfStatsHCOutOctets_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                         U64 * ipIfStatsHCOutOctets_val_ptr)
+                         struct counter64 *ipIfStatsHCOutOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCOutOctets_val_ptr);
@@ -2227,7 +2227,7 @@ The number of IP multicast datagrams received.  This object
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCInMcastPkts data.
@@ -2237,7 +2237,7 @@ The number of IP multicast datagrams received.  This object
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCInMcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2245,7 +2245,7 @@ The number of IP multicast datagrams received.  This object
  */
 int
 ipIfStatsHCInMcastPkts_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                           U64 * ipIfStatsHCInMcastPkts_val_ptr)
+                           struct counter64 *ipIfStatsHCInMcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCInMcastPkts_val_ptr);
@@ -2354,7 +2354,7 @@ The total number of octets received in IP multicast
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCInMcastOctets data.
@@ -2364,7 +2364,7 @@ The total number of octets received in IP multicast
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCInMcastOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2372,7 +2372,7 @@ The total number of octets received in IP multicast
  */
 int
 ipIfStatsHCInMcastOctets_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                             U64 * ipIfStatsHCInMcastOctets_val_ptr)
+                             struct counter64 *ipIfStatsHCInMcastOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCInMcastOctets_val_ptr);
@@ -2479,7 +2479,7 @@ The number of IP multicast datagrams transmitted.  This
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCOutMcastPkts data.
@@ -2489,7 +2489,7 @@ The number of IP multicast datagrams transmitted.  This
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCOutMcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2497,7 +2497,7 @@ The number of IP multicast datagrams transmitted.  This
  */
 int
 ipIfStatsHCOutMcastPkts_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                            U64 * ipIfStatsHCOutMcastPkts_val_ptr)
+                            struct counter64 *ipIfStatsHCOutMcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCOutMcastPkts_val_ptr);
@@ -2603,7 +2603,7 @@ The total number of octets transmitted in IP multicast
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCOutMcastOctets data.
@@ -2613,7 +2613,7 @@ The total number of octets transmitted in IP multicast
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCOutMcastOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2621,7 +2621,7 @@ The total number of octets transmitted in IP multicast
  */
 int
 ipIfStatsHCOutMcastOctets_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                              U64 * ipIfStatsHCOutMcastOctets_val_ptr)
+                              struct counter64 *ipIfStatsHCOutMcastOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCOutMcastOctets_val_ptr);
@@ -2725,7 +2725,7 @@ The number of IP broadcast datagrams received.  This object
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCInBcastPkts data.
@@ -2735,7 +2735,7 @@ The number of IP broadcast datagrams received.  This object
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCInBcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2743,7 +2743,7 @@ The number of IP broadcast datagrams received.  This object
  */
 int
 ipIfStatsHCInBcastPkts_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                           U64 * ipIfStatsHCInBcastPkts_val_ptr)
+                           struct counter64 *ipIfStatsHCInBcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCInBcastPkts_val_ptr);
@@ -2847,7 +2847,7 @@ The number of IP broadcast datagrams transmitted.  This
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipIfStatsHCOutBcastPkts data.
@@ -2857,7 +2857,7 @@ The number of IP broadcast datagrams transmitted.  This
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipIfStatsHCOutBcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2865,7 +2865,7 @@ The number of IP broadcast datagrams transmitted.  This
  */
 int
 ipIfStatsHCOutBcastPkts_get(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
-                            U64 * ipIfStatsHCOutBcastPkts_val_ptr)
+                            struct counter64 *ipIfStatsHCOutBcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipIfStatsHCOutBcastPkts_val_ptr);
diff --git a/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.h b/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.h
index 0cc7e47..ad5d8a0 100644
--- a/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.h
+++ b/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_data_get.h
@@ -50,7 +50,7 @@ extern          "C" {
                                             ipIfStatsInReceives_val_ptr);
     int             ipIfStatsHCInReceives_get(ipIfStatsTable_rowreq_ctx *
                                               rowreq_ctx,
-                                              U64 *
+                                              struct counter64 *
                                               ipIfStatsHCInReceives_val_ptr);
     int             ipIfStatsInOctets_get(ipIfStatsTable_rowreq_ctx *
                                           rowreq_ctx,
@@ -58,7 +58,7 @@ extern          "C" {
                                           ipIfStatsInOctets_val_ptr);
     int             ipIfStatsHCInOctets_get(ipIfStatsTable_rowreq_ctx *
                                             rowreq_ctx,
-                                            U64 *
+                                            struct counter64 *
                                             ipIfStatsHCInOctets_val_ptr);
     int             ipIfStatsInHdrErrors_get(ipIfStatsTable_rowreq_ctx *
                                              rowreq_ctx,
@@ -87,7 +87,7 @@ extern          "C" {
     int            
         ipIfStatsHCInForwDatagrams_get(ipIfStatsTable_rowreq_ctx *
                                        rowreq_ctx,
-                                       U64 *
+                                       struct counter64 *
                                        ipIfStatsHCInForwDatagrams_val_ptr);
     int             ipIfStatsReasmReqds_get(ipIfStatsTable_rowreq_ctx *
                                             rowreq_ctx,
@@ -111,7 +111,7 @@ extern          "C" {
                                             ipIfStatsInDelivers_val_ptr);
     int             ipIfStatsHCInDelivers_get(ipIfStatsTable_rowreq_ctx *
                                               rowreq_ctx,
-                                              U64 *
+                                              struct counter64 *
                                               ipIfStatsHCInDelivers_val_ptr);
     int             ipIfStatsOutRequests_get(ipIfStatsTable_rowreq_ctx *
                                              rowreq_ctx,
@@ -119,7 +119,7 @@ extern          "C" {
                                              ipIfStatsOutRequests_val_ptr);
     int             ipIfStatsHCOutRequests_get(ipIfStatsTable_rowreq_ctx *
                                                rowreq_ctx,
-                                               U64 *
+                                               struct counter64 *
                                                ipIfStatsHCOutRequests_val_ptr);
     int             ipIfStatsOutForwDatagrams_get(ipIfStatsTable_rowreq_ctx
                                                   * rowreq_ctx,
@@ -128,7 +128,7 @@ extern          "C" {
     int            
         ipIfStatsHCOutForwDatagrams_get(ipIfStatsTable_rowreq_ctx *
                                         rowreq_ctx,
-                                        U64 *
+                                        struct counter64 *
                                         ipIfStatsHCOutForwDatagrams_val_ptr);
     int             ipIfStatsOutDiscards_get(ipIfStatsTable_rowreq_ctx *
                                              rowreq_ctx,
@@ -156,7 +156,7 @@ extern          "C" {
                                               ipIfStatsOutTransmits_val_ptr);
     int             ipIfStatsHCOutTransmits_get(ipIfStatsTable_rowreq_ctx *
                                                 rowreq_ctx,
-                                                U64 *
+                                                struct counter64 *
                                                 ipIfStatsHCOutTransmits_val_ptr);
     int             ipIfStatsOutOctets_get(ipIfStatsTable_rowreq_ctx *
                                            rowreq_ctx,
@@ -164,7 +164,7 @@ extern          "C" {
                                            ipIfStatsOutOctets_val_ptr);
     int             ipIfStatsHCOutOctets_get(ipIfStatsTable_rowreq_ctx *
                                              rowreq_ctx,
-                                             U64 *
+                                             struct counter64 *
                                              ipIfStatsHCOutOctets_val_ptr);
     int             ipIfStatsInMcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                              rowreq_ctx,
@@ -172,7 +172,7 @@ extern          "C" {
                                              ipIfStatsInMcastPkts_val_ptr);
     int             ipIfStatsHCInMcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                                rowreq_ctx,
-                                               U64 *
+                                               struct counter64 *
                                                ipIfStatsHCInMcastPkts_val_ptr);
     int             ipIfStatsInMcastOctets_get(ipIfStatsTable_rowreq_ctx *
                                                rowreq_ctx,
@@ -180,7 +180,7 @@ extern          "C" {
                                                ipIfStatsInMcastOctets_val_ptr);
     int             ipIfStatsHCInMcastOctets_get(ipIfStatsTable_rowreq_ctx
                                                  * rowreq_ctx,
-                                                 U64 *
+                                                 struct counter64 *
                                                  ipIfStatsHCInMcastOctets_val_ptr);
     int             ipIfStatsOutMcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                               rowreq_ctx,
@@ -188,7 +188,7 @@ extern          "C" {
                                               ipIfStatsOutMcastPkts_val_ptr);
     int             ipIfStatsHCOutMcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                                 rowreq_ctx,
-                                                U64 *
+                                                struct counter64 *
                                                 ipIfStatsHCOutMcastPkts_val_ptr);
     int             ipIfStatsOutMcastOctets_get(ipIfStatsTable_rowreq_ctx *
                                                 rowreq_ctx,
@@ -196,7 +196,7 @@ extern          "C" {
                                                 ipIfStatsOutMcastOctets_val_ptr);
     int             ipIfStatsHCOutMcastOctets_get(ipIfStatsTable_rowreq_ctx
                                                   * rowreq_ctx,
-                                                  U64 *
+                                                  struct counter64 *
                                                   ipIfStatsHCOutMcastOctets_val_ptr);
     int             ipIfStatsInBcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                              rowreq_ctx,
@@ -204,7 +204,7 @@ extern          "C" {
                                              ipIfStatsInBcastPkts_val_ptr);
     int             ipIfStatsHCInBcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                                rowreq_ctx,
-                                               U64 *
+                                               struct counter64 *
                                                ipIfStatsHCInBcastPkts_val_ptr);
     int             ipIfStatsOutBcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                               rowreq_ctx,
@@ -212,7 +212,7 @@ extern          "C" {
                                               ipIfStatsOutBcastPkts_val_ptr);
     int             ipIfStatsHCOutBcastPkts_get(ipIfStatsTable_rowreq_ctx *
                                                 rowreq_ctx,
-                                                U64 *
+                                                struct counter64 *
                                                 ipIfStatsHCOutBcastPkts_val_ptr);
     int            
         ipIfStatsDiscontinuityTime_get(ipIfStatsTable_rowreq_ctx *
diff --git a/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_interface.c b/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_interface.c
index 559d1c1..4955a8b 100644
--- a/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_interface.c
+++ b/agent/mibgroup/ip-mib/ipIfStatsTable/ipIfStatsTable_interface.c
@@ -722,10 +722,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCInReceives(4)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCINRECEIVES:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCInReceives_get(rowreq_ctx,
-                                       (U64 *) var->val.string);
+                                       (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -741,9 +741,9 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCInOctets(6)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCINOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ipIfStatsHCInOctets_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ipIfStatsHCInOctets_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -810,10 +810,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCInForwDatagrams(13)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCINFORWDATAGRAMS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCInForwDatagrams_get(rowreq_ctx,
-                                            (U64 *) var->val.string);
+                                            (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -869,10 +869,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCInDelivers(19)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCINDELIVERS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCInDelivers_get(rowreq_ctx,
-                                       (U64 *) var->val.string);
+                                       (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -889,10 +889,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCOutRequests(21)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCOUTREQUESTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCOutRequests_get(rowreq_ctx,
-                                        (U64 *) var->val.string);
+                                        (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -909,10 +909,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCOutForwDatagrams(24)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCOUTFORWDATAGRAMS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCOutForwDatagrams_get(rowreq_ctx,
-                                             (U64 *) var->val.string);
+                                             (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -979,10 +979,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCOutTransmits(31)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCOUTTRANSMITS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCOutTransmits_get(rowreq_ctx,
-                                         (U64 *) var->val.string);
+                                         (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -999,9 +999,9 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCOutOctets(33)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCOUTOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
-        rc = ipIfStatsHCOutOctets_get(rowreq_ctx, (U64 *) var->val.string);
+        rc = ipIfStatsHCOutOctets_get(rowreq_ctx, (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1018,10 +1018,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCInMcastPkts(35)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCINMCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCInMcastPkts_get(rowreq_ctx,
-                                        (U64 *) var->val.string);
+                                        (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1038,10 +1038,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCInMcastOctets(37)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCINMCASTOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCInMcastOctets_get(rowreq_ctx,
-                                          (U64 *) var->val.string);
+                                          (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1058,10 +1058,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCOutMcastPkts(39)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCOUTMCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCOutMcastPkts_get(rowreq_ctx,
-                                         (U64 *) var->val.string);
+                                         (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1078,10 +1078,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCOutMcastOctets(41)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCOUTMCASTOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCOutMcastOctets_get(rowreq_ctx,
-                                           (U64 *) var->val.string);
+                                           (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1098,10 +1098,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCInBcastPkts(43)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCINBCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCInBcastPkts_get(rowreq_ctx,
-                                        (U64 *) var->val.string);
+                                        (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1118,10 +1118,10 @@ _ipIfStatsTable_get_column(ipIfStatsTable_rowreq_ctx * rowreq_ctx,
          * ipIfStatsHCOutBcastPkts(45)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPIFSTATSHCOUTBCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipIfStatsHCOutBcastPkts_get(rowreq_ctx,
-                                         (U64 *) var->val.string);
+                                         (struct counter64 *) var->val.string);
         break;
 
         /*
diff --git a/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.c b/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.c
index 10587e2..19d4c27 100644
--- a/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.c
+++ b/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.c
@@ -434,7 +434,7 @@ The total number of input IP datagrams received, including
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCInReceives data.
@@ -444,7 +444,7 @@ The total number of input IP datagrams received, including
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCInReceives_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -452,7 +452,7 @@ The total number of input IP datagrams received, including
  */
 int
 ipSystemStatsHCInReceives_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                              U64 * ipSystemStatsHCInReceives_val_ptr)
+                              struct counter64 *ipSystemStatsHCInReceives_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCInReceives_val_ptr);
@@ -561,7 +561,7 @@ The total number of octets received in input IP datagrams,
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCInOctets data.
@@ -571,7 +571,7 @@ The total number of octets received in input IP datagrams,
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCInOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -579,7 +579,7 @@ The total number of octets received in input IP datagrams,
  */
 int
 ipSystemStatsHCInOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                            U64 * ipSystemStatsHCInOctets_val_ptr)
+                            struct counter64 *ipSystemStatsHCInOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCInOctets_val_ptr);
@@ -1039,7 +1039,7 @@ The number of input datagrams for which this entity was not
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCInForwDatagrams data.
@@ -1049,7 +1049,7 @@ The number of input datagrams for which this entity was not
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCInForwDatagrams_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1058,7 +1058,7 @@ The number of input datagrams for which this entity was not
 int
 ipSystemStatsHCInForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                    rowreq_ctx,
-                                   U64 *
+                                   struct counter64 *
                                    ipSystemStatsHCInForwDatagrams_val_ptr)
 {
    /** we should have a non-NULL pointer */
@@ -1456,7 +1456,7 @@ The total number of datagrams successfully delivered to IP
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCInDelivers data.
@@ -1466,7 +1466,7 @@ The total number of datagrams successfully delivered to IP
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCInDelivers_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1474,7 +1474,7 @@ The total number of datagrams successfully delivered to IP
  */
 int
 ipSystemStatsHCInDelivers_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                              U64 * ipSystemStatsHCInDelivers_val_ptr)
+                              struct counter64 *ipSystemStatsHCInDelivers_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCInDelivers_val_ptr);
@@ -1584,7 +1584,7 @@ The total number of IP datagrams which local IP user-
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCOutRequests data.
@@ -1594,7 +1594,7 @@ The total number of IP datagrams which local IP user-
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCOutRequests_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1602,7 +1602,7 @@ The total number of IP datagrams which local IP user-
  */
 int
 ipSystemStatsHCOutRequests_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                               U64 * ipSystemStatsHCOutRequests_val_ptr)
+                               struct counter64 *ipSystemStatsHCOutRequests_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCOutRequests_val_ptr);
@@ -1790,7 +1790,7 @@ The number of datagrams for which this entity was not their
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCOutForwDatagrams data.
@@ -1800,7 +1800,7 @@ The number of datagrams for which this entity was not their
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCOutForwDatagrams_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -1809,7 +1809,7 @@ The number of datagrams for which this entity was not their
 int
 ipSystemStatsHCOutForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
-                                    U64 *
+                                    struct counter64 *
                                     ipSystemStatsHCOutForwDatagrams_val_ptr)
 {
    /** we should have a non-NULL pointer */
@@ -2270,7 +2270,7 @@ The total number of IP datagrams that this entity supplied
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCOutTransmits data.
@@ -2280,7 +2280,7 @@ The total number of IP datagrams that this entity supplied
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCOutTransmits_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2288,7 +2288,7 @@ The total number of IP datagrams that this entity supplied
  */
 int
 ipSystemStatsHCOutTransmits_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                                U64 * ipSystemStatsHCOutTransmits_val_ptr)
+                                struct counter64 *ipSystemStatsHCOutTransmits_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCOutTransmits_val_ptr);
@@ -2397,7 +2397,7 @@ The total number of octets in IP datagrams delivered to the
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCOutOctets data.
@@ -2407,7 +2407,7 @@ The total number of octets in IP datagrams delivered to the
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCOutOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2415,7 +2415,7 @@ The total number of octets in IP datagrams delivered to the
  */
 int
 ipSystemStatsHCOutOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                             U64 * ipSystemStatsHCOutOctets_val_ptr)
+                             struct counter64 *ipSystemStatsHCOutOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCOutOctets_val_ptr);
@@ -2521,7 +2521,7 @@ The number of IP multicast datagrams received.  This object
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCInMcastPkts data.
@@ -2531,7 +2531,7 @@ The number of IP multicast datagrams received.  This object
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCInMcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2539,7 +2539,7 @@ The number of IP multicast datagrams received.  This object
  */
 int
 ipSystemStatsHCInMcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                               U64 * ipSystemStatsHCInMcastPkts_val_ptr)
+                               struct counter64 *ipSystemStatsHCInMcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCInMcastPkts_val_ptr);
@@ -2646,7 +2646,7 @@ The total number of octets received in IP multicast
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCInMcastOctets data.
@@ -2656,7 +2656,7 @@ The total number of octets received in IP multicast
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCInMcastOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2665,7 +2665,7 @@ The total number of octets received in IP multicast
 int
 ipSystemStatsHCInMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                  rowreq_ctx,
-                                 U64 *
+                                 struct counter64 *
                                  ipSystemStatsHCInMcastOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
@@ -2772,7 +2772,7 @@ The number of IP multicast datagrams transmitted.  This
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCOutMcastPkts data.
@@ -2782,7 +2782,7 @@ The number of IP multicast datagrams transmitted.  This
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCOutMcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2790,7 +2790,7 @@ The number of IP multicast datagrams transmitted.  This
  */
 int
 ipSystemStatsHCOutMcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                                U64 * ipSystemStatsHCOutMcastPkts_val_ptr)
+                                struct counter64 *ipSystemStatsHCOutMcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCOutMcastPkts_val_ptr);
@@ -2902,7 +2902,7 @@ The total number of octets transmitted in IP multicast
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCOutMcastOctets data.
@@ -2912,7 +2912,7 @@ The total number of octets transmitted in IP multicast
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCOutMcastOctets_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -2921,7 +2921,7 @@ The total number of octets transmitted in IP multicast
 int
 ipSystemStatsHCOutMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                   rowreq_ctx,
-                                  U64 *
+                                  struct counter64 *
                                   ipSystemStatsHCOutMcastOctets_val_ptr)
 {
    /** we should have a non-NULL pointer */
@@ -3028,7 +3028,7 @@ The number of IP broadcast datagrams received.  This object
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCInBcastPkts data.
@@ -3038,7 +3038,7 @@ The number of IP broadcast datagrams received.  This object
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCInBcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -3046,7 +3046,7 @@ The number of IP broadcast datagrams received.  This object
  */
 int
 ipSystemStatsHCInBcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                               U64 * ipSystemStatsHCInBcastPkts_val_ptr)
+                               struct counter64 *ipSystemStatsHCInBcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCInBcastPkts_val_ptr);
@@ -3152,7 +3152,7 @@ The number of IP broadcast datagrams transmitted.  This
  *
  *
  * Its syntax is COUNTER64 (based on perltype COUNTER64)
- * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
+ * The net-snmp type is ASN_COUNTER64. The C type is struct counter64.
  */
 /**
  * Extract the current value of the ipSystemStatsHCOutBcastPkts data.
@@ -3162,7 +3162,7 @@ The number of IP broadcast datagrams transmitted.  This
  * @param rowreq_ctx
  *        Pointer to the row request context.
  * @param ipSystemStatsHCOutBcastPkts_val_ptr
- *        Pointer to storage for a U64 variable
+ *        Pointer to storage for a struct counter64 variable
  *
  * @retval MFD_SUCCESS         : success
  * @retval MFD_SKIP            : skip this node (no value for now)
@@ -3170,7 +3170,7 @@ The number of IP broadcast datagrams transmitted.  This
  */
 int
 ipSystemStatsHCOutBcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
-                                U64 * ipSystemStatsHCOutBcastPkts_val_ptr)
+                                struct counter64 *ipSystemStatsHCOutBcastPkts_val_ptr)
 {
    /** we should have a non-NULL pointer */
     netsnmp_assert(NULL != ipSystemStatsHCOutBcastPkts_val_ptr);
diff --git a/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.h b/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.h
index ca1e1f3..5c3823e 100644
--- a/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.h
+++ b/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable.h
@@ -144,93 +144,22 @@ config_require(ip-mib/ipSystemStatsTable/ipSystemStatsTable_data_access)
      *********************************************************************
      * function prototypes
      */
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsTable_pre_request(ipSystemStatsTable_registration *
+    int ipSystemStatsTable_pre_request(ipSystemStatsTable_registration *
                                        user_context);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsTable_post_request(ipSystemStatsTable_registration *
+    int ipSystemStatsTable_post_request(ipSystemStatsTable_registration *
                                         user_context, int rc);
 
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsTable_rowreq_ctx_init(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsTable_rowreq_ctx_init(ipSystemStatsTable_rowreq_ctx *
                                            rowreq_ctx,
                                            void *user_init_ctx);
     void
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
         ipSystemStatsTable_rowreq_ctx_cleanup(ipSystemStatsTable_rowreq_ctx
                                               * rowreq_ctx);
 
     ipSystemStatsTable_data *ipSystemStatsTable_allocate_data(void);
     void            ipSystemStatsTable_release_data(ipSystemStatsTable_data
                                                     * data);
-
-
-         
-         
-         
-         
-         
-         
-        ipSystemStatsTable_rowreq_ctx
+    ipSystemStatsTable_rowreq_ctx
         * ipSystemStatsTable_row_find_by_mib_index
         (ipSystemStatsTable_mib_index * mib_idx);
 
@@ -265,226 +194,50 @@ config_require(ip-mib/ipSystemStatsTable/ipSystemStatsTable_data_access)
      * indexes
      */
 
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInReceives_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInReceives_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     ipSystemStatsInReceives_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCInReceives_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCInReceives_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
-                                      U64 *
+                                      struct counter64 *
                                       ipSystemStatsHCInReceives_val_ptr);
     int             ipSystemStatsInOctets_get(ipSystemStatsTable_rowreq_ctx
                                               * rowreq_ctx,
                                               u_long *
                                               ipSystemStatsInOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCInOctets_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCInOctets_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
-                                    U64 * ipSystemStatsHCInOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInHdrErrors_get(ipSystemStatsTable_rowreq_ctx *
+                                    struct counter64 *ipSystemStatsHCInOctets_val_ptr);
+    int ipSystemStatsInHdrErrors_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      ipSystemStatsInHdrErrors_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInNoRoutes_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInNoRoutes_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     ipSystemStatsInNoRoutes_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInAddrErrors_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInAddrErrors_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       ipSystemStatsInAddrErrors_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInUnknownProtos_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInUnknownProtos_get(ipSystemStatsTable_rowreq_ctx *
                                          rowreq_ctx,
                                          u_long *
                                          ipSystemStatsInUnknownProtos_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInTruncatedPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInTruncatedPkts_get(ipSystemStatsTable_rowreq_ctx *
                                          rowreq_ctx,
                                          u_long *
                                          ipSystemStatsInTruncatedPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                          rowreq_ctx,
                                          u_long *
                                          ipSystemStatsInForwDatagrams_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCInForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCInForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                            rowreq_ctx,
-                                           U64 *
+                                           struct counter64 *
                                            ipSystemStatsHCInForwDatagrams_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsReasmReqds_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsReasmReqds_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     ipSystemStatsReasmReqds_val_ptr);
@@ -492,690 +245,142 @@ config_require(ip-mib/ipSystemStatsTable/ipSystemStatsTable_data_access)
                                               * rowreq_ctx,
                                               u_long *
                                               ipSystemStatsReasmOKs_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsReasmFails_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsReasmFails_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     ipSystemStatsReasmFails_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInDiscards_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInDiscards_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     ipSystemStatsInDiscards_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInDelivers_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInDelivers_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     ipSystemStatsInDelivers_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCInDelivers_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCInDelivers_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
-                                      U64 *
+                                      struct counter64 *
                                       ipSystemStatsHCInDelivers_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutRequests_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutRequests_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      ipSystemStatsOutRequests_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCOutRequests_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCOutRequests_get(ipSystemStatsTable_rowreq_ctx *
                                        rowreq_ctx,
-                                       U64 *
+                                       struct counter64 *
                                        ipSystemStatsHCOutRequests_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutNoRoutes_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutNoRoutes_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      ipSystemStatsOutNoRoutes_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                           rowreq_ctx,
                                           u_long *
                                           ipSystemStatsOutForwDatagrams_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCOutForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCOutForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                             rowreq_ctx,
-                                            U64 *
+                                            struct counter64 *
                                             ipSystemStatsHCOutForwDatagrams_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutDiscards_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutDiscards_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      ipSystemStatsOutDiscards_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutFragReqds_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutFragReqds_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       ipSystemStatsOutFragReqds_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutFragOKs_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutFragOKs_get(ipSystemStatsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     ipSystemStatsOutFragOKs_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutFragFails_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutFragFails_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       ipSystemStatsOutFragFails_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutFragCreates_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutFragCreates_get(ipSystemStatsTable_rowreq_ctx *
                                         rowreq_ctx,
                                         u_long *
                                         ipSystemStatsOutFragCreates_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutTransmits_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutTransmits_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       ipSystemStatsOutTransmits_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCOutTransmits_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCOutTransmits_get(ipSystemStatsTable_rowreq_ctx *
                                         rowreq_ctx,
-                                        U64 *
+                                        struct counter64 *
                                         ipSystemStatsHCOutTransmits_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutOctets_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutOctets_get(ipSystemStatsTable_rowreq_ctx *
                                    rowreq_ctx,
                                    u_long *
                                    ipSystemStatsOutOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCOutOctets_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCOutOctets_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
-                                     U64 *
+                                     struct counter64 *
                                      ipSystemStatsHCOutOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      ipSystemStatsInMcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCInMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCInMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                        rowreq_ctx,
-                                       U64 *
+                                       struct counter64 *
                                        ipSystemStatsHCInMcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                        rowreq_ctx,
                                        u_long *
                                        ipSystemStatsInMcastOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCInMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCInMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                          rowreq_ctx,
-                                         U64 *
+                                         struct counter64 *
                                          ipSystemStatsHCInMcastOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       ipSystemStatsOutMcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCOutMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCOutMcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                         rowreq_ctx,
-                                        U64 *
+                                        struct counter64 *
                                         ipSystemStatsHCOutMcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                         rowreq_ctx,
                                         u_long *
                                         ipSystemStatsOutMcastOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCOutMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCOutMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                           rowreq_ctx,
-                                          U64 *
+                                          struct counter64 *
                                           ipSystemStatsHCOutMcastOctets_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsInBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsInBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      ipSystemStatsInBcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCInBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCInBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                        rowreq_ctx,
-                                       U64 *
+                                       struct counter64 *
                                        ipSystemStatsHCInBcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsOutBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsOutBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                       rowreq_ctx,
                                       u_long *
                                       ipSystemStatsOutBcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsHCOutBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsHCOutBcastPkts_get(ipSystemStatsTable_rowreq_ctx *
                                         rowreq_ctx,
-                                        U64 *
+                                        struct counter64 *
                                         ipSystemStatsHCOutBcastPkts_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsDiscontinuityTime_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsDiscontinuityTime_get(ipSystemStatsTable_rowreq_ctx *
                                            rowreq_ctx,
                                            u_long *
                                            ipSystemStatsDiscontinuityTime_val_ptr);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsRefreshRate_get(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsRefreshRate_get(ipSystemStatsTable_rowreq_ctx *
                                      rowreq_ctx,
                                      u_long *
                                      ipSystemStatsRefreshRate_val_ptr);
-
-
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsTable_indexes_set_tbl_idx(ipSystemStatsTable_mib_index
+    int ipSystemStatsTable_indexes_set_tbl_idx(ipSystemStatsTable_mib_index
                                                * tbl_idx,
                                                u_long
                                                ipSystemStatsIPVersion_val);
-    int
-     
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        
-        ipSystemStatsTable_indexes_set(ipSystemStatsTable_rowreq_ctx *
+    int ipSystemStatsTable_indexes_set(ipSystemStatsTable_rowreq_ctx *
                                        rowreq_ctx,
                                        u_long ipSystemStatsIPVersion_val);
 
-
-
     /*
      *********************************************************************
      * SET function declarations
diff --git a/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable_interface.c b/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable_interface.c
index e1ca2cb..09c061f 100644
--- a/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable_interface.c
+++ b/agent/mibgroup/ip-mib/ipSystemStatsTable/ipSystemStatsTable_interface.c
@@ -674,10 +674,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCInReceives(4)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCINRECEIVES:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCInReceives_get(rowreq_ctx,
-                                           (U64 *) var->val.string);
+                                           (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -694,10 +694,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCInOctets(6)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCINOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCInOctets_get(rowreq_ctx,
-                                         (U64 *) var->val.string);
+                                         (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -764,10 +764,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCInForwDatagrams(13)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCINFORWDATAGRAMS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCInForwDatagrams_get(rowreq_ctx,
-                                                (U64 *) var->val.string);
+                                                (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -824,10 +824,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCInDelivers(19)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCINDELIVERS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCInDelivers_get(rowreq_ctx,
-                                           (U64 *) var->val.string);
+                                           (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -844,10 +844,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCOutRequests(21)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCOUTREQUESTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCOutRequests_get(rowreq_ctx,
-                                            (U64 *) var->val.string);
+                                            (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -874,10 +874,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCOutForwDatagrams(24)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCOUTFORWDATAGRAMS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCOutForwDatagrams_get(rowreq_ctx,
-                                                 (U64 *) var->val.string);
+                                                 (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -944,10 +944,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCOutTransmits(31)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCOUTTRANSMITS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCOutTransmits_get(rowreq_ctx,
-                                             (U64 *) var->val.string);
+                                             (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -964,10 +964,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCOutOctets(33)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCOUTOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCOutOctets_get(rowreq_ctx,
-                                          (U64 *) var->val.string);
+                                          (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -984,10 +984,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCInMcastPkts(35)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCINMCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCInMcastPkts_get(rowreq_ctx,
-                                            (U64 *) var->val.string);
+                                            (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1004,10 +1004,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCInMcastOctets(37)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCINMCASTOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCInMcastOctets_get(rowreq_ctx,
-                                              (U64 *) var->val.string);
+                                              (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1024,10 +1024,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCOutMcastPkts(39)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCOUTMCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCOutMcastPkts_get(rowreq_ctx,
-                                             (U64 *) var->val.string);
+                                             (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1044,10 +1044,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCOutMcastOctets(41)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCOUTMCASTOCTETS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCOutMcastOctets_get(rowreq_ctx,
-                                               (U64 *) var->val.string);
+                                               (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1064,10 +1064,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCInBcastPkts(43)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCINBCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCInBcastPkts_get(rowreq_ctx,
-                                            (U64 *) var->val.string);
+                                            (struct counter64 *) var->val.string);
         break;
 
         /*
@@ -1084,10 +1084,10 @@ _ipSystemStatsTable_get_column(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
          * ipSystemStatsHCOutBcastPkts(45)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h 
          */
     case COLUMN_IPSYSTEMSTATSHCOUTBCASTPKTS:
-        var->val_len = sizeof(U64);
+        var->val_len = sizeof(struct counter64);
         var->type = ASN_COUNTER64;
         rc = ipSystemStatsHCOutBcastPkts_get(rowreq_ctx,
-                                             (U64 *) var->val.string);
+                                             (struct counter64 *) var->val.string);
         break;
 
         /*
diff --git a/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable.c b/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable.c
index 351ddd1..91646f7 100644
--- a/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable.c
+++ b/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable.c
@@ -33,8 +33,7 @@ OID_LENGTH(ipv4InterfaceTable_oid);
 ipv4InterfaceTable_registration ipv4InterfaceTable_user_context;
 static ipv4InterfaceTable_registration *ipv4InterfaceTable_user_context_p;
 
-void            initialize_table_ipv4InterfaceTable(void);
-void            shutdown_table_ipv4InterfaceTable(void);
+static void     shutdown_table_ipv4InterfaceTable(void);
 
 
 /**
diff --git a/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable_interface.c b/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable_interface.c
index a851a30..fba8d52 100644
--- a/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable_interface.c
+++ b/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable_interface.c
@@ -166,8 +166,6 @@ NETSNMP_STATIC_INLINE int
                                                 var, int column);
 #endif
 
-ipv4InterfaceTable_data *ipv4InterfaceTable_allocate_data(void);
-
 /**
  * @internal
  * Initialize the table ipv4InterfaceTable 
@@ -274,10 +272,12 @@ _ipv4InterfaceTable_initialize_interface(ipv4InterfaceTable_registration *
         netsnmp_handler_registration_create("ipv4InterfaceTable", handler,
                                             ipv4InterfaceTable_oid,
                                             ipv4InterfaceTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #ifndef NETSNMP_DISABLE_SET_SUPPORT
-                                          | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_DISABLE_SET_SUPPORT */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR, "error registering table ipv4InterfaceTable\n");
@@ -387,6 +387,7 @@ ipv4InterfaceTable_valid_columns_set(netsnmp_column_info *vc)
     ipv4InterfaceTable_if_ctx.tbl_info.valid_columns = vc;
 }                               /* ipv4InterfaceTable_valid_columns_set */
 
+#if 0
 /*
  * ipv4InterfaceTable_allocate_data
  *
@@ -407,6 +408,7 @@ ipv4InterfaceTable_allocate_data(void)
 
     return rtn;
 }                               /* ipv4InterfaceTable_allocate_data */
+#endif
 
 /**
  * @internal
diff --git a/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable.c b/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable.c
index 92f0a5b..a69bcbb 100644
--- a/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable.c
+++ b/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable.c
@@ -33,8 +33,7 @@ OID_LENGTH(ipv6InterfaceTable_oid);
 ipv6InterfaceTable_registration ipv6InterfaceTable_user_context;
 static ipv6InterfaceTable_registration *ipv6InterfaceTable_user_context_p;
 
-void            initialize_table_ipv6InterfaceTable(void);
-void            shutdown_table_ipv6InterfaceTable(void);
+static void     shutdown_table_ipv6InterfaceTable(void);
 
 
 /**
diff --git a/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable_interface.c b/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable_interface.c
index cbd533c..c42553b 100644
--- a/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable_interface.c
+++ b/agent/mibgroup/ip-mib/ipv6InterfaceTable/ipv6InterfaceTable_interface.c
@@ -272,10 +272,12 @@ _ipv6InterfaceTable_initialize_interface(ipv6InterfaceTable_registration *
         netsnmp_handler_registration_create("ipv6InterfaceTable", handler,
                                             ipv6InterfaceTable_oid,
                                             ipv6InterfaceTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #ifndef NETSNMP_DISABLE_SET_SUPPORT
-                                          | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_DISABLE_SET_SUPPORT */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR, "error registering table ipv6InterfaceTable\n");
diff --git a/agent/mibgroup/kernel_sunos5.c b/agent/mibgroup/kernel_sunos5.c
index 331ee6d..30025f9 100644
--- a/agent/mibgroup/kernel_sunos5.c
+++ b/agent/mibgroup/kernel_sunos5.c
@@ -82,7 +82,7 @@ kstat_ctl_t    *kstat_fd = 0;
 static
 mibcache        Mibcache[MIBCACHE_SIZE+1] = {
     {MIB_SYSTEM, 0, (void *) -1, 0, 0, 0, 0},
-    {MIB_INTERFACES, 50 * sizeof(mib2_ifEntry_t), (void *) -1, 0, 30, 0,
+    {MIB_INTERFACES, 50 * sizeof(mib2_ifEntry_t), (void *) -1, 0, 3, 0,
      0},
     {MIB_AT, 0, (void *) -1, 0, 0, 0, 0},
     {MIB_IP, sizeof(mib2_ip_t), (void *) -1, 0, 60, 0, 0},
@@ -257,14 +257,10 @@ void
 init_kernel_sunos5(void)
 {
     static int creg   = 0;
-    const  int period = 30;
+    const  int period = 3;
     int    alarm_id   = 0;
 
     if (creg == 0) {
-	alarm_id = snmp_alarm_register(5, NULL, kernel_sunos5_cache_age,
-                                       NULL);
-	DEBUGMSGTL(("kernel_sunos5", "registered alarm %d with period 5s\n", 
-		    alarm_id));
 	alarm_id = snmp_alarm_register(period, SA_REPEAT, 
                                        kernel_sunos5_cache_age,
                                        (void *)period);
@@ -1405,7 +1401,7 @@ getif(mib2_ifEntry_t *ifbuf, size_t size, req_e req_type,
      ifnp->if_index != 0 && (i < nentries); ifnp++) {
 
         DEBUGMSGTL(("kernel_sunos5", "...... getif %s\n", ifnp->if_name));
-        memcpy(lifrp->lifr_name, ifnp->if_name, LIFNAMSIZ);
+        strlcpy(lifrp->lifr_name, ifnp->if_name, LIFNAMSIZ);
         if_isv6 = B_FALSE;
 
         if (ioctl(ifsd, SIOCGLIFFLAGS, lifrp) < 0) {
@@ -2070,20 +2066,3 @@ main(int argc, char **argv)
 }
 #endif /*_GETMIBSTAT_TEST */
 #endif                          /* SUNOS5 */
-
-
-/*-
- * These variables describe the formatting of this file.  If you don't like the
- * template defaults, feel free to change them here (not in your .emacs file).
- *
- * Local Variables:
- * comment-column: 32
- * c-indent-level: 4
- * c-continued-statement-offset: 4
- * c-brace-offset: -4
- * c-argdecl-indent: 0
- * c-label-offset: -4
- * fill-column: 79
- * fill-prefix: " * "
- * End:
- */
diff --git a/agent/mibgroup/kernel_sunos5.h b/agent/mibgroup/kernel_sunos5.h
index bf337ae..3b4b82e 100644
--- a/agent/mibgroup/kernel_sunos5.h
+++ b/agent/mibgroup/kernel_sunos5.h
@@ -208,19 +208,4 @@ extern          "C" {
 }
 #endif
 #endif
-/*-
- * These variables describe the formatting of this file.  If you don't like the
- * template defaults, feel free to change them here (not in your .emacs file).
- *
- * Local Variables:
- * comment-column: 32
- * c-indent-level: 4
- * c-continued-statement-offset: 4
- * c-brace-offset: -4
- * c-argdecl-indent: 0
- * c-label-offset: -4
- * fill-column: 79
- * fill-prefix: " * "
- * End:
- */
 #endif
diff --git a/agent/mibgroup/mibII.h b/agent/mibgroup/mibII.h
index 35cb544..44243d2 100644
--- a/agent/mibgroup/mibII.h
+++ b/agent/mibgroup/mibII.h
@@ -36,6 +36,9 @@ config_require(ip-mib ip-forward-mib tcp-mib udp-mib)
 config_require(ip-mib ip-forward-mib tcp-mib udp-mib)
 #elif defined(solaris2)
 config_require(tcp-mib udp-mib)
+config_require(ip-forward-mib)
+config_require(ip-mib/ipAddressTable ip-mib/ipAddressPrefixTable)
+config_require(ip-mib/ipDefaultRouterTable)
 #elif defined(freebsd4)
 config_require(tcp-mib udp-mib)
 #elif defined(netbsd1)
@@ -46,6 +49,9 @@ config_require(tcp-mib udp-mib)
  * For Solaris, enable additional tables when it has extended MIB support.
  */
 #if defined( solaris2 ) && defined( HAVE_MIB2_IPIFSTATSENTRY_T )
-config_require(ip-mib/ipSystemStatsTable ip-mib/ipAddressTable)
-config_require(ip-forward-mib)
+config_require(ip-mib/ipSystemStatsTable ip-mib/ipIfStatsTable)
+/* Still missing:
+ * ip-mib/inetNetToMediaTable
+ * ip-mib/ipv6ScopeZoneIndexTable
+ */
 #endif
diff --git a/agent/mibgroup/mibII/at.c b/agent/mibgroup/mibII/at.c
index f57ba2a..64125a3 100644
--- a/agent/mibgroup/mibII/at.c
+++ b/agent/mibgroup/mibII/at.c
@@ -618,7 +618,7 @@ ARP_Scan_Init(void)
 
     in = fopen("/proc/net/arp", "r");
     if (!in) {
-        snmp_log(LOG_ERR, "snmpd: Cannot open /proc/net/arp\n");
+        snmp_log_perror("mibII/at: Cannot open /proc/net/arp");
         arptab_size = 0;
         return;
     }
@@ -638,11 +638,12 @@ ARP_Scan_Init(void)
             struct arptab  *newtab = (struct arptab *)
                 realloc(at, (sizeof(struct arptab) *
                              (arptab_curr_max_size + ARP_CACHE_INCR)));
-            if (newtab == at) {
+            if (newtab == NULL) {
                 snmp_log(LOG_ERR,
                          "Error allocating more space for arpcache.  "
                          "Cache will continue to be limited to %d entries",
                          arptab_curr_max_size);
+                newtab = at;
                 break;
             } else {
                 arptab_curr_max_size += ARP_CACHE_INCR;
@@ -860,7 +861,7 @@ ARP_Scan_Next(in_addr_t * IPAddr, char *PhysAddr, int *PhysAddrLen,
 #elif defined(HAVE_IPHLPAPI_H)  /* WIN32 cygwin */
 #include <iphlpapi.h>
 
-extern WriteMethod write_arp;
+static WriteMethod write_arp;
 MIB_IPNETROW   *arp_row = NULL;
 int             create_flag = 0;
 
diff --git a/agent/mibgroup/mibII/icmp.c b/agent/mibgroup/mibII/icmp.c
index be803ee..a78e2ae 100644
--- a/agent/mibgroup/mibII/icmp.c
+++ b/agent/mibgroup/mibII/icmp.c
@@ -29,6 +29,7 @@
 
 #include "util_funcs/MIB_STATS_CACHE_TIMEOUT.h"
 #include "icmp.h"
+#include "ip.h"
 
 #ifndef MIB_STATS_CACHE_TIMEOUT
 #define MIB_STATS_CACHE_TIMEOUT	5
@@ -167,11 +168,6 @@ static struct icmp6_mib icmp6stat;
 static const oid icmp_oid[] = { SNMP_OID_MIB2, 5 };
 static const oid icmp_stats_tbl_oid[] = { SNMP_OID_MIB2, 5, 29 };
 static const oid icmp_msg_stats_tbl_oid[] = { SNMP_OID_MIB2, 5, 30 };
-#ifdef USING_MIBII_IP_MODULE
-extern oid      ip_module_oid[];
-extern int      ip_module_oid_len;
-extern int      ip_module_count;
-#endif
 
 #ifdef USES_SNMP_DESIGNED_ICMPSTAT
 struct icmp_stats_table_entry {
@@ -641,7 +637,7 @@ init_icmp(void)
     netsnmp_handler_registration *table_reginfo = NULL;
     netsnmp_iterator_info *iinfo;
     netsnmp_iterator_info *msg_stats_iinfo;
-    netsnmp_table_registration_info *table_info;
+    netsnmp_table_registration_info *table_info = NULL;
     netsnmp_table_registration_info *msg_stats_table_info;
 #endif
     netsnmp_handler_registration *scalar_reginfo = NULL;
diff --git a/agent/mibgroup/mibII/icmp.h b/agent/mibgroup/mibII/icmp.h
index d07841a..3214c9e 100644
--- a/agent/mibgroup/mibII/icmp.h
+++ b/agent/mibgroup/mibII/icmp.h
@@ -14,12 +14,16 @@ config_arch_require(freebsd7,  mibII/kernel_sysctl)
 config_arch_require(freebsd8,  mibII/kernel_sysctl)
 config_arch_require(freebsd9,  mibII/kernel_sysctl)
 config_arch_require(freebsd10, mibII/kernel_sysctl)
+config_arch_require(freebsd11, mibII/kernel_sysctl)
+config_arch_require(freebsd12, mibII/kernel_sysctl)
 config_arch_require(netbsd,    mibII/kernel_netbsd)
 config_arch_require(netbsdelf, mibII/kernel_netbsd)
 config_arch_require(openbsd4,  mibII/kernel_sysctl)
 config_arch_require(openbsd5,  mibII/kernel_sysctl)
+config_arch_require(openbsd6,  mibII/kernel_sysctl)
 config_arch_require(dragonfly2, mibII/kernel_sysctl)
 config_arch_require(dragonfly3, mibII/kernel_sysctl)
+config_arch_require(dragonfly4, mibII/kernel_sysctl)
 config_arch_require(darwin10,  mibII/kernel_sysctl)
 config_arch_require(darwin11,  mibII/kernel_sysctl)
 config_arch_require(darwin12,  mibII/kernel_sysctl)
diff --git a/agent/mibgroup/mibII/interfaces.c b/agent/mibgroup/mibII/interfaces.c
index 26ffebb..b93694f 100644
--- a/agent/mibgroup/mibII/interfaces.c
+++ b/agent/mibgroup/mibII/interfaces.c
@@ -12,6 +12,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -319,10 +324,10 @@ if_type_from_name(const char *pcch)
         {0, 0}                  /* end of list */
     };
 
-    int             ii, len;
+    int             len;
     register pmatch_if pm;
 
-    for (ii = 0, pm = lmatch_if; pm->mi_name; pm++) {
+    for (pm = lmatch_if; pm->mi_name; pm++) {
         len = strlen(pm->mi_name);
         if (0 == strncmp(pcch, pm->mi_name, len)) {
             return (pm->mi_type);
@@ -433,8 +438,6 @@ struct small_ifaddr {
     struct in_addr  sifa_broadcast;
 };
 
-extern const struct sockaddr *get_address(const void *, int, int);
-extern const struct in_addr *get_in_address(const void *, int, int);
 static int      Interface_Scan_By_Index(int, struct if_msghdr *, char *,
                                         struct small_ifaddr *);
 static int      Interface_Get_Ether_By_Index(int, u_char *);
@@ -1464,11 +1467,6 @@ static int      saveIndex = 0;
 unsigned int getIfSpeed(int fd, struct ifreq ifr, unsigned int defaultspeed)
 {
 #ifdef linux
-    /** temporary expose internal until this module can be re-written */
-    extern unsigned int
-        netsnmp_linux_interface_get_if_speed(int fd, const char *name,
-                unsigned long long defaultspeed);
-
     return netsnmp_linux_interface_get_if_speed(fd, ifr.ifr_name, defaultspeed);
 #else /*!linux*/			   
     return defaultspeed;
@@ -1864,7 +1862,9 @@ Interface_Scan_NextInt(int *Index,
                     struct ifnet *Retifnet, struct in_ifaddr *dummy)
 {
     struct ifnet    ifnet;
+#if !defined(linux)
     register char  *cp;
+#endif
 
     while (ifnetaddr) {
         /*
@@ -1898,7 +1898,6 @@ Interface_Scan_NextInt(int *Index,
 #endif
 
         saveName[sizeof(saveName) - 1] = '\0';
-        cp = (char *) strchr(saveName, '\0');
 #ifdef linux
         strlcat(saveName, ifnet.if_unit, sizeof(saveName));
 #else
@@ -1906,6 +1905,7 @@ Interface_Scan_NextInt(int *Index,
         /* this exists here just so we don't copy ifdef logic elsewhere */
         netsnmp_feature_require(string_append_int);
 #endif
+        cp = (char *) strchr(saveName, '\0');
         string_append_int(cp, ifnet.if_unit);
 #endif
         if (1 || strcmp(saveName, "lo0") != 0) {        /* XXX */
@@ -2374,8 +2374,6 @@ static int      header_interfaces(struct variable *, oid *, size_t *, int,
                                   size_t *, WriteMethod ** write);
 static int      header_ifEntry(struct variable *, oid *, size_t *, int,
                                size_t *, WriteMethod ** write);
-u_char         *var_ifEntry(struct variable *, oid *, size_t *, int,
-                            size_t *, WriteMethod ** write);
 
 static char    *physaddrbuf;
 static int      nphysaddrs;
diff --git a/agent/mibgroup/mibII/ip.c b/agent/mibgroup/mibII/ip.c
index f39d322..a134d30 100644
--- a/agent/mibgroup/mibII/ip.c
+++ b/agent/mibgroup/mibII/ip.c
@@ -59,9 +59,6 @@ perfstat_id_t ps_name;
 	 *
 	 *********************/
 
-extern void     init_routes(void);
-
-
 /*
  * define the structure we're going to ask the agent to register our
  * information at 
diff --git a/agent/mibgroup/mibII/ip.h b/agent/mibgroup/mibII/ip.h
index 04c5651..93e320f 100644
--- a/agent/mibgroup/mibII/ip.h
+++ b/agent/mibgroup/mibII/ip.h
@@ -17,12 +17,17 @@ config_arch_require(linux,     mibII/kernel_linux)
 config_arch_require(netbsd,    mibII/kernel_netbsd)
 config_arch_require(netbsd5,   mibII/kernel_netbsd)
 config_arch_require(netbsd6,   mibII/kernel_netbsd)
+config_arch_require(netbsd7,   mibII/kernel_netbsd)
 config_arch_require(netbsdelf, mibII/kernel_netbsd)
 config_arch_require(netbsdelf5, mibII/kernel_netbsd)
 
 #include "var_route.h"
 #include "route_write.h"
 
+extern oid ip_module_oid[];
+extern int ip_module_oid_len;
+extern int ip_module_count;
+
 extern void     init_ip(void);
 extern Netsnmp_Node_Handler ip_handler;
 extern NetsnmpCacheLoad ip_load;
diff --git a/agent/mibgroup/mibII/ipAddr.c b/agent/mibgroup/mibII/ipAddr.c
index a4d577e..888751a 100644
--- a/agent/mibgroup/mibII/ipAddr.c
+++ b/agent/mibgroup/mibII/ipAddr.c
@@ -115,6 +115,7 @@
 #include <net-snmp/data_access/interface.h>
 
 #include "ip.h"
+#include "ipAddr.h"
 #include "interfaces.h"
 
 #ifdef cygwin
@@ -531,7 +532,6 @@ Address_Scan_Init(void)
     while (ifc.ifc_len >= (sizeof(struct ifreq) * num_interfaces));
     
     ifr = ifc.ifc_req;
-    close(fd);
 }
 
 /*
diff --git a/agent/mibgroup/mibII/ipv6.c b/agent/mibgroup/mibII/ipv6.c
index 99d50e8..19de4f8 100644
--- a/agent/mibgroup/mibII/ipv6.c
+++ b/agent/mibgroup/mibII/ipv6.c
@@ -5,6 +5,11 @@
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#if HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL)
 #define _KERNEL 1
 #define _I_DEFINED_KERNEL
@@ -12,9 +17,7 @@
 #if NETSNMP_IFNET_NEEDS_KERNEL_STRUCTURES
 #define _KERNEL_STRUCTURES
 #endif
-#include <sys/types.h>
 #include <sys/param.h>
-#include <sys/socket.h>
 #if defined(freebsd3) || defined(darwin)
 # if HAVE_SYS_SOCKETVAR_H
 #  include <sys/socketvar.h>
@@ -32,9 +35,6 @@
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_IOCTL_H
-#include <sys/ioctl.h>
-#endif
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
@@ -53,7 +53,13 @@
 #if HAVE_SYS_TCPIPSTATS_H
 #include <sys/tcpipstats.h>
 #endif
+#ifdef _I_DEFINED_KERNEL
+#undef _KERNEL
+#endif
 #include <net/if.h>
+#ifdef _I_DEFINED_KERNEL
+#define _KERNEL 1
+#endif
 #if HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
 #endif
@@ -81,6 +87,7 @@
 # include <netinet/ip_var.h>
 #endif
 #if HAVE_NETINET6_IP6_VAR_H
+# include <sys/queue.h>
 # include <netinet6/ip6_var.h>
 #endif
 #include <net/route.h>
@@ -131,6 +138,20 @@
 #include <syslog.h>
 #endif
 
+#if HAVE_KVM_GETFILES
+#if defined(HAVE_KVM_GETFILE2) || !defined(openbsd5)
+#undef HAVE_KVM_GETFILES
+#endif
+#endif
+
+#if HAVE_KVM_GETFILES
+#include <kvm.h>
+#include <sys/sysctl.h>
+#define _KERNEL
+#include <sys/file.h>
+#undef _KERNEL
+#endif
+
 #ifdef MIB_IPCOUNTER_SYMBOL
 #include <sys/mib.h>
 #include <netinet/mib_kern.h>
@@ -597,6 +618,43 @@ if_getindex(const char *name)
 
 /*------------------------------------------------------------*/
 #ifndef linux
+
+#ifdef __OpenBSD__
+
+ /*
+  * It is not possible to use struct ifnet anymore on OpenBSD, get
+  * interface flags and L2 address through getifaddrs(3).
+  */
+
+#include <ifaddrs.h>
+
+static int
+if_getifflags(int ifindex, int *ifflags)
+{
+    const char      *ifname;
+    struct ifaddrs  *ifa0, *ifa;
+    int              ret = -1;
+
+    ifname = if_getname(ifindex);
+    if (ifname == NULL)
+        return ret;
+
+    if (getifaddrs(&ifa0) != -1) {
+        for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
+            if (strcmp(ifa->ifa_name, ifname) == 0) {
+                *ifflags = ifa->ifa_flags;
+                ret = 0;
+                break;
+            }
+        }
+        freeifaddrs(ifa0);
+    }
+
+    return ret;
+}
+
+#else
+
 /*
  * KAME dependent part 
  */
@@ -630,6 +688,8 @@ if_getifnet(int idx, struct ifnet *result)
     return -1;
 }
 
+#endif /* !__OpenBSD__ */
+
 #if TRUST_IFLASTCHANGE         /*untrustable value returned... */
 #ifdef HAVE_NET_IF_MIB_H
 #if defined(HAVE_SYS_SYSCTL_H) && defined(CTL_NET)
@@ -844,6 +904,37 @@ var_ifv6Entry(register struct variable * vp,
 #endif
     case IPV6IFPHYSADDRESS:
         {
+#ifdef __OpenBSD__
+	    struct ifaddrs *ifa0, *ifa;
+            static struct sockaddr_dl sdl;
+            char ifnam[IF_NAMESIZE];
+
+	    if (if_indextoname(interface, ifnam) == NULL) {
+                *var_len = 0;
+                return NULL;
+            }
+
+	    if (getifaddrs(&ifa0) != -1) {
+                for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
+
+                    if (strcmp(ifnam, ifa->ifa_name) != 0)
+                       continue;
+
+                    if (ifa->ifa_addr == NULL)
+                       continue;
+
+                    memcpy(&sdl, ifa->ifa_addr, sizeof(sdl));
+                    if (sdl.sdl_family != AF_LINK)
+                       continue;
+
+                   freeifaddrs(ifa0);
+                   *var_len = sdl.sdl_alen;
+                   return (u_char *) (sdl.sdl_data + sdl.sdl_nlen);
+		}
+	    }
+	    freeifaddrs(ifa0);
+	    return NULL;
+#else
             struct ifnet    ifnet;
             struct ifaddr   ifaddr;
 #if defined(__DragonFly__) && __DragonFly_version >= 197700
@@ -929,23 +1020,38 @@ var_ifv6Entry(register struct variable * vp,
              */
             *var_len = 0;
             return NULL;
+#endif /* !__OpenBSD__ */
         }
     case IPV6IFADMSTATUS:
         {
+#ifdef __OpenBSD__
+            int    if_flags;
+            if (if_getifflags(interface, &if_flags) < 0)
+                break;
+            long_return = (if_flags & IFF_RUNNING) ? 1 : 2;
+#else
             struct ifnet    ifnet;
 
             if (if_getifnet(interface, &ifnet) < 0)
                 break;
             long_return = (ifnet.if_flags & IFF_RUNNING) ? 1 : 2;
+#endif
             return (u_char *) & long_return;
         }
     case IPV6IFOPERSTATUS:
         {
+#ifdef __OpenBSD__
+            int    if_flags;
+            if (if_getifflags(interface, &if_flags) < 0)
+                break;
+            long_return = (if_flags & IFF_UP) ? 1 : 2;
+#else
             struct ifnet    ifnet;
 
             if (if_getifnet(interface, &ifnet) < 0)
                 break;
             long_return = (ifnet.if_flags & IFF_UP) ? 1 : 2;
+#endif
             return (u_char *) & long_return;
         }
 #if TRUST_IFLASTCHANGE         /*untrustable value returned... */
@@ -1302,6 +1408,91 @@ var_icmpv6Entry(register struct variable * vp,
 #endif
 }
 
+#if HAVE_KVM_GETFILES
+
+u_char         *
+var_udp6(register struct variable * vp,
+         oid * name,
+         size_t * length,
+         int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    oid             newname[MAX_OID_LEN];
+    oid             savname[MAX_OID_LEN];
+    int             result, count, found, savnameLen;
+    int             p, i, j;
+    u_char         *sa, *savsa;
+    struct kinfo_file *udp;
+
+    udp = kvm_getfiles(kd, KERN_FILE_BYFILE, DTYPE_SOCKET, sizeof(struct kinfo_file), &count);
+    found = savnameLen = 0;
+    memcpy(newname, vp->name, (int) vp->namelen * sizeof(oid));
+    for (p = 0; p < count; p++) {
+	if (udp[p].so_protocol != IPPROTO_UDP || udp[p].so_family != AF_INET6)
+	    continue;
+	j = vp->namelen;
+        sa = (u_char *)&udp[p].inp_laddru[0];
+	for (i = 0; i < sizeof(struct in6_addr); i++)
+            newname[j++] = sa[i];
+        newname[j++] = ntohs(udp[p].inp_lport);
+        if (IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)sa))
+            newname[j++] = ntohs(sa[2]);
+        else
+            newname[j++] = 0;
+        DEBUGMSGTL(("mibII/ipv6", "var_udp6 new: %d %d ",
+                    (int) vp->namelen, j));
+        DEBUGMSGOID(("mibII/ipv6", newname, j));
+        DEBUGMSG(("mibII/ipv6", " %d\n", exact));
+
+        result = snmp_oid_compare(name, *length, newname, j);
+        if (exact && result == 0) {
+                savnameLen = j;
+                memcpy(savname, newname, j * sizeof(oid));
+                savsa = sa;
+                found++;
+                break;
+        } else if (!exact && result < 0) {
+            /*
+             *  take the least greater one
+             */
+            if (savnameLen == 0 || snmp_oid_compare(savname, savnameLen, newname, j) > 0) {
+                savnameLen = j;
+                savsa = sa;
+                memcpy(savname, newname, j * sizeof(oid));
+                    found++;
+            }
+        }
+    }
+    DEBUGMSGTL(("mibII/ipv6", "found=%d\n", found));
+    if (!found)
+        return NULL;
+    *length = savnameLen;
+    memcpy((char *) name, (char *) savname, *length * sizeof(oid));
+    *write_method = 0;
+    *var_len = sizeof(long);    /* default to 'long' results */
+
+/*
+ *     DEBUGMSGTL(("mibII/ipv6", "var_udp6 found: "));
+ *     DEBUGMSGOID(("mibII/ipv6", name, *length));
+ *     DEBUGMSG(("mibII/ipv6", " %d\n", exact));
+ */
+    DEBUGMSGTL(("mibII/ipv6", "magic=%d\n", vp->magic));
+    switch (vp->magic) {
+    case IPV6UDPIFINDEX:
+        if (IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)savsa))
+            long_return = ntohs(savsa[2]);
+        else
+            long_return = 0;
+        return (u_char *) &long_return;
+    default:
+        break;
+    }
+    ERROR_MSG("");
+
+    return NULL;
+}
+
+#else
+
 u_char         *
 var_udp6(register struct variable * vp,
          oid * name,
@@ -1336,10 +1527,18 @@ var_udp6(register struct variable * vp,
     DEBUGMSGOID(("mibII/ipv6", name, *length));
     DEBUGMSG(("mibII/ipv6", " %d\n", exact));
 
-#if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000 || defined(openbsd4)	/*1.6Y*/
+#if defined(__NetBSD__) && __NetBSD_Version__ >= 700000001
+    if (!auto_nlist("udbtable", (char *) &udbtable, sizeof(udbtable)))
+        return NULL;
+    first = p = (caddr_t)udbtable.inpt_queue.tqh_first;
+#elif defined(__NetBSD__) && __NetBSD_Version__ >= 106250000 || defined(openbsd4)	/*1.6Y*/
     if (!auto_nlist("udbtable", (char *) &udbtable, sizeof(udbtable)))
         return NULL;
+#if defined(openbsd5)
+    first = p = (caddr_t)TAILQ_FIRST(&udbtable.inpt_queue);
+#else
     first = p = (caddr_t)udbtable.inpt_queue.cqh_first;
+#endif
 #elif !defined(freebsd3) && !defined(darwin)
     if (!auto_nlist("udb6", (char *) &udb6, sizeof(udb6)))
         return NULL;
@@ -1415,6 +1614,9 @@ var_udp6(register struct variable * vp,
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
         if (in6pcb.in6p_af != AF_INET6)
             goto skip;
+#elif defined(INP_ISIPV6)
+	if (!INP_ISIPV6(&in6pcb))
+	    goto skip;
 #elif defined(freebsd3) || defined(darwin)
         if (0 == (in6pcb.inp_vflag & INP_IPV6))
             goto skip;
@@ -1470,9 +1672,15 @@ var_udp6(register struct variable * vp,
         }
 
       skip:
-#if defined(openbsd4)
+#ifdef openbsd5
+        p = (caddr_t)TAILQ_NEXT(&in6pcb, inp_queue);
+        if (p == NULL) break;
+#elif defined(openbsd4)
         p = (caddr_t)in6pcb.inp_queue.cqe_next;
 	if (p == first) break;
+#elif defined(__NetBSD__) && __NetBSD_Version__ >= 700000001
+        p = (caddr_t)in6pcb.in6p_queue.tqe_next;
+	if (p == first) break;
 #elif defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
         p = (caddr_t)in6pcb.in6p_queue.cqe_next;
 	if (p == first) break;
@@ -1524,6 +1732,7 @@ var_udp6(register struct variable * vp,
     ERROR_MSG("");
     return NULL;
 }
+#endif /* KVM_GETFILES */
 
 #ifdef TCP6
 u_char         *
@@ -1627,6 +1836,9 @@ var_tcp6(register struct variable * vp,
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
         if (in6pcb.in6p_af != AF_INET6)
             goto skip;
+#elif defined(INP_ISIPV6)
+	if (!INP_ISIPV6(&in6pcb))
+	    goto skip;
 #elif defined(freebsd3) || defined(darwin)
         if (0 == (in6pcb.inp_vflag & INP_IPV6))
             goto skip;
@@ -1718,6 +1930,110 @@ var_tcp6(register struct variable * vp,
     return NULL;
 }
 
+#elif HAVE_KVM_GETFILES
+
+u_char         *
+var_tcp6(register struct variable * vp,
+         oid * name,
+         size_t * length,
+         int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    oid             newname[MAX_OID_LEN];
+    oid             savname[MAX_OID_LEN];
+    int             result, count, found, savnameLen, savstate;
+    int             p, i, j;
+    u_char         *lsa, *savlsa, *fsa, *savfsa;
+    struct kinfo_file *tcp;
+    static int      tcp6statemap[16];
+    static int      initialized = 0;
+
+    if (!initialized) {
+        tcp6statemap[TCPS_CLOSED] = 1;
+        tcp6statemap[TCPS_LISTEN] = 2;
+        tcp6statemap[TCPS_SYN_SENT] = 3;
+        tcp6statemap[TCPS_SYN_RECEIVED] = 4;
+        tcp6statemap[TCPS_ESTABLISHED] = 5;
+        tcp6statemap[TCPS_CLOSE_WAIT] = 8;
+        tcp6statemap[TCPS_FIN_WAIT_1] = 6;
+        tcp6statemap[TCPS_CLOSING] = 10;
+        tcp6statemap[TCPS_LAST_ACK] = 9;
+        tcp6statemap[TCPS_FIN_WAIT_2] = 7;
+        tcp6statemap[TCPS_TIME_WAIT] = 11;
+        initialized++;
+    }
+
+    tcp = kvm_getfiles(kd, KERN_FILE_BYFILE, DTYPE_SOCKET, sizeof(struct kinfo_file), &count);
+    found = savnameLen = 0;
+    memcpy(newname, vp->name, (int) vp->namelen * sizeof(oid));
+    for (p = 0; p < count; p++) {
+	if (tcp[p].so_protocol != IPPROTO_TCP || tcp[p].so_family != AF_INET6)
+	    continue;
+	j = vp->namelen;
+        lsa = (u_char *)&tcp[p].inp_laddru[0];
+	for (i = 0; i < sizeof(struct in6_addr); i++)
+            newname[j++] = lsa[i];
+        newname[j++] = ntohs(tcp[p].inp_lport);
+        fsa = (u_char *)&tcp[p].inp_faddru[0];
+	for (i = 0; i < sizeof(struct in6_addr); i++)
+            newname[j++] = fsa[i];
+        newname[j++] = ntohs(tcp[p].inp_fport);
+        if (IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)lsa))
+            newname[j++] = ntohs(lsa[2]);
+        else
+            newname[j++] = 0;
+        DEBUGMSGTL(("mibII/ipv6", "var_udp6 new: %d %d ",
+                    (int) vp->namelen, j));
+        DEBUGMSGOID(("mibII/ipv6", newname, j));
+        DEBUGMSG(("mibII/ipv6", " %d\n", exact));
+
+        result = snmp_oid_compare(name, *length, newname, j);
+        if (exact && result == 0) {
+                savnameLen = j;
+                memcpy(savname, newname, j * sizeof(oid));
+                savlsa = lsa;
+                savfsa = fsa;
+                savstate = tcp[p].t_state;
+                found++;
+                break;
+        } else if (!exact && result < 0) {
+            /*
+             *  take the least greater one
+             */
+            if (savnameLen == 0 || snmp_oid_compare(savname, savnameLen, newname, j) > 0) {
+                savnameLen = j;
+                savlsa = lsa;
+                savfsa = fsa;
+                savstate = tcp[p].t_state;
+                memcpy(savname, newname, j * sizeof(oid));
+		found++;
+            }
+        }
+    }
+    DEBUGMSGTL(("mibII/ipv6", "found=%d\n", found));
+    if (!found)
+        return NULL;
+    *length = savnameLen;
+    memcpy((char *) name, (char *) savname, *length * sizeof(oid));
+    *write_method = 0;
+    *var_len = sizeof(long);    /* default to 'long' results */
+
+/*
+ *     DEBUGMSGTL(("mibII/ipv6", "var_udp6 found: "));
+ *     DEBUGMSGOID(("mibII/ipv6", name, *length));
+ *     DEBUGMSG(("mibII/ipv6", " %d\n", exact));
+ */
+    DEBUGMSGTL(("mibII/ipv6", "magic=%d\n", vp->magic));
+    switch (vp->magic) {
+    case IPV6TCPCONNSTATE:
+	long_return = tcp6statemap[savstate & 0x0F];
+        return (u_char *) &long_return;
+    default:
+        break;
+    }
+    ERROR_MSG("");
+    return NULL;
+}
+
 #else  /* ! TCP6 */
 
 static int mapTcpState( int val)
@@ -1783,7 +2099,13 @@ var_tcp6(register struct variable * vp,
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000 || defined(openbsd4)	/*1.6Y*/
     if (!auto_nlist("tcbtable", (char *) &tcbtable, sizeof(tcbtable)))
         return NULL;
+#ifdef openbsd5
+    first = p = (caddr_t)TAILQ_FIRST(&tcbtable.inpt_queue);
+#elif defined(__NetBSD__) && __NetBSD_Version__ >= 700000001
+    first = p = (caddr_t)tcbtable.inpt_queue.tqh_first;
+#else
     first = p = (caddr_t)tcbtable.inpt_queue.cqh_first;
+#endif
 #elif !defined(freebsd3) && !defined(darwin)
     if (!auto_nlist("tcb6", (char *) &tcb6, sizeof(tcb6)))
         return NULL;
@@ -1861,6 +2183,9 @@ var_tcp6(register struct variable * vp,
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
         if (in6pcb.in6p_af != AF_INET6)
             goto skip;
+#elif defined(INP_ISIPV6)
+	if (!INP_ISIPV6(&in6pcb))
+	    goto skip;
 #elif defined(freebsd3) || defined(darwin)
         if (0 == (in6pcb.inp_vflag & INP_IPV6))
             goto skip;
@@ -1925,9 +2250,15 @@ var_tcp6(register struct variable * vp,
         }
 
       skip:
-#if defined(openbsd4)
+#ifdef openbsd5
+        p = (caddr_t)TAILQ_NEXT(&in6pcb, inp_queue);
+        if (p == NULL) break;
+#elif defined(openbsd4)
         p = (caddr_t)in6pcb.inp_queue.cqe_next;
 	if (p == first) break;
+#elif defined(__NetBSD__) && __NetBSD_Version__ >= 700000001
+        p = (caddr_t)in6pcb.in6p_queue.tqe_next;
+	if (p == first) break;
 #elif defined(__NetBSD__) && __NetBSD_Version__ >= 106250000 || defined(openbsd4)	/*1.6Y*/
         p = (caddr_t)in6pcb.in6p_queue.cqe_next;
 	if (p == first) break;
@@ -2242,12 +2573,18 @@ linux_if_nameindex(void)
         if_count = 0;
         maxidx = -1;
         while (!feof(f)) {
-            if (fscanf(f, "%*s %lx %*x %*x %*x %s",
+            if (fscanf(f, "%*s %lx %*x %*x %*x %255s",
                        &if_index, if_name) != 2)
                 continue;
             if (if_index == 0)
                 continue;
             if_name[sizeof(if_name) - 1] = '\0';
+            /*
+             * Large if_index values can cause the multiplication in the
+             * realloc() statement to overflow. Hence check if_index.
+             */
+            if (if_index > 65536)
+                break;
             if (maxidx < 0 || maxidx < if_index) {
                 if (last_if_count < if_index)
                     last_if_count = if_index;
diff --git a/agent/mibgroup/mibII/mibII_common.h b/agent/mibgroup/mibII/mibII_common.h
index 87ef9d1..3662329 100644
--- a/agent/mibgroup/mibII/mibII_common.h
+++ b/agent/mibgroup/mibII/mibII_common.h
@@ -33,7 +33,13 @@
 #include <sys/socket.h>
 #endif
 #if HAVE_NET_IF_H
+#ifdef _I_DEFINED_KERNEL
+#undef _KERNEL
+#endif
 #include <net/if.h>
+#ifdef _I_DEFINED_KERNEL
+#define _KERNEL 1
+#endif
 #endif
 #if HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
diff --git a/agent/mibgroup/mibII/mta_sendmail.c b/agent/mibgroup/mibII/mta_sendmail.c
index c1edd07..fd2af21 100644
--- a/agent/mibgroup/mibII/mta_sendmail.c
+++ b/agent/mibgroup/mibII/mta_sendmail.c
@@ -1396,7 +1396,7 @@ var_mtaGroupEntry(struct variable *vp,
         *length = vp->namelen + 2;
     }
 
-    *write_method = 0;
+    *write_method = NULL;
     *var_len = sizeof(long);    /* default to 'long' results */
 
     if (vp->magic & NEEDS_STATS) {
diff --git a/agent/mibgroup/mibII/route_write.c b/agent/mibgroup/mibII/route_write.c
index 5820ee1..5157d6d 100644
--- a/agent/mibgroup/mibII/route_write.c
+++ b/agent/mibgroup/mibII/route_write.c
@@ -65,6 +65,7 @@
 
 #include "ip.h"
 #include "route_write.h"
+#include "var_route.h"
 
 #ifdef cygwin
 #include <windows.h>
@@ -198,10 +199,11 @@ delRoute(u_long dstip, u_long gwip, u_long iff, u_short flags)
 
     flags |= RTF_UP;
 
+    memset(&dst, 0, sizeof(dst));
     dst.sin_family = AF_INET;
     dst.sin_addr.s_addr = htonl(dstip);
 
-
+    memset(&gateway, 0, sizeof(gateway));
     gateway.sin_family = AF_INET;
     gateway.sin_addr.s_addr = htonl(gwip);
 
@@ -596,9 +598,6 @@ write_rte(int action,
 #elif defined(HAVE_IPHLPAPI_H)  /* WIN32 cygwin */
 #include <iphlpapi.h>
 
-extern PMIB_IPFORWARDROW route_row;
-extern int      create_flag;
-
 int
 write_rte(int action,
           u_char * var_val,
diff --git a/agent/mibgroup/mibII/snmp_mib.c b/agent/mibgroup/mibII/snmp_mib.c
index 1ebe64c..f09acfa 100644
--- a/agent/mibgroup/mibII/snmp_mib.c
+++ b/agent/mibgroup/mibII/snmp_mib.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
@@ -5,6 +16,7 @@
 #include <net-snmp/agent/sysORTable.h>
 
 #include "snmp_mib.h"
+#include "system_mib.h"
 #include "updates.h"
 
 #ifndef NETSNMP_NO_WRITE_SUPPORT
@@ -13,9 +25,6 @@ netsnmp_feature_require(check_vb_truthvalue)
 
 static const oid snmp_oid[] = { 1, 3, 6, 1, 2, 1, 11 };
 
-extern long snmp_enableauthentraps;
-extern int snmp_enableauthentrapsset;
-
 static int
 snmp_enableauthentraps_store(int a, int b, void *c, void *d)
 {
@@ -93,12 +102,6 @@ handle_snmp(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-#ifdef USING_MIBII_SYSTEM_MIB_MODULE
-extern oid      system_module_oid[];
-extern int      system_module_oid_len;
-extern int      system_module_count;
-#endif
-
 /** Initializes the snmp module */
 void
 init_snmp_mib(void)
@@ -112,13 +115,23 @@ init_snmp_mib(void)
     {
         const oid snmpEnableAuthenTraps_oid[] = { 1, 3, 6, 1, 2, 1, 11, 30, 0 };
 	static netsnmp_watcher_info enableauthen_info;
+        netsnmp_mib_handler *handler;
         netsnmp_handler_registration *reg =
             netsnmp_create_update_handler_registration(
                 "mibII/snmpEnableAuthenTraps",
                 snmpEnableAuthenTraps_oid,
                 OID_LENGTH(snmpEnableAuthenTraps_oid),
                 HANDLER_CAN_RWRITE, &snmp_enableauthentrapsset);
-        netsnmp_inject_handler(reg, netsnmp_get_truthvalue());
+        handler = netsnmp_get_truthvalue();
+        if (!handler ||
+            (netsnmp_inject_handler(reg, handler) != SNMPERR_SUCCESS)) {
+            snmp_log(LOG_ERR,
+                     "could not create mibII/snmpEnableAuthenTraps handler\n");
+            if (handler)
+                netsnmp_handler_free(handler);
+            netsnmp_handler_registration_free(reg);
+            return;
+        }
         netsnmp_register_watched_instance(
             reg,
             netsnmp_init_watcher_info(
diff --git a/agent/mibgroup/mibII/sysORTable.c b/agent/mibgroup/mibII/sysORTable.c
index ed26919..95463a4 100644
--- a/agent/mibgroup/mibII/sysORTable.c
+++ b/agent/mibgroup/mibII/sysORTable.c
@@ -7,6 +7,7 @@
 #include <net-snmp/agent/sysORTable.h>
 
 #include "sysORTable.h"
+#include "system_mib.h"
 
 #include <net-snmp/net-snmp-features.h>
 
@@ -192,12 +193,6 @@ sysORTable_handler(netsnmp_mib_handler *handler,
     return SNMP_ERR_NOERROR;
 }
 
-#ifdef USING_MIBII_SYSTEM_MIB_MODULE
-extern oid      system_module_oid[];
-extern int      system_module_oid_len;
-extern int      system_module_count;
-#endif
-
 static netsnmp_handler_registration *sysORLastChange_reg;
 static netsnmp_watcher_info sysORLastChange_winfo;
 static netsnmp_handler_registration *sysORTable_reg;
diff --git a/agent/mibgroup/mibII/system_mib.c b/agent/mibgroup/mibII/system_mib.c
index 65b0b7c..cd037e5 100644
--- a/agent/mibgroup/mibII/system_mib.c
+++ b/agent/mibgroup/mibII/system_mib.c
@@ -62,15 +62,9 @@ static char     sysLocation[SYS_STRING_LEN] = NETSNMP_SYS_LOC;
 static oid      sysObjectID[MAX_OID_LEN];
 static size_t sysObjectIDByteLength;
 
-extern oid      version_sysoid[];
-extern int      version_sysoid_len;
-
 static int      sysServices = 72;
 static int      sysServicesConfiged = 0;
 
-extern oid      version_id[];
-extern int      version_id_len;
-
 static int      sysContactSet = 0, sysLocationSet = 0, sysNameSet = 0;
 
 #if (defined (WIN32) && defined (HAVE_WIN32_PLATFORM_SDK)) || defined (mingw32)
diff --git a/agent/mibgroup/mibII/system_mib.h b/agent/mibgroup/mibII/system_mib.h
index dd16f08..19f5b88 100644
--- a/agent/mibgroup/mibII/system_mib.h
+++ b/agent/mibgroup/mibII/system_mib.h
@@ -7,6 +7,10 @@ extern "C" {
 
 config_require(util_funcs mibII/updates)
 
+extern oid system_module_oid[];
+extern int system_module_oid_len;
+extern int system_module_count;
+
 void init_system_mib(void);
 
 #ifdef __cplusplus
diff --git a/agent/mibgroup/mibII/tcp.c b/agent/mibgroup/mibII/tcp.c
index 3c79fad..8569687 100644
--- a/agent/mibgroup/mibII/tcp.c
+++ b/agent/mibgroup/mibII/tcp.c
@@ -92,9 +92,6 @@ perfstat_id_t ps_name;
 int  hz = 1000;
 #endif
 
-#ifndef NETSNMP_FEATURE_REMOVE_TCP_COUNT_CONNECTIONS
-extern int TCP_Count_Connections( void );
-#endif /* NETSNMP_FEATURE_REMOVE_TCP_COUNT_CONNECTIONS */
         /*********************
 	 *
 	 *  Initialisation & common implementation functions
@@ -321,6 +318,9 @@ tcp_handler(netsnmp_mib_handler          *handler,
             ret_value = tcpstat.tcpOutRsts;
             break;
 	}
+#elif defined(solaris2)
+        ret_value = tcpstat.tcpOutRsts;
+        break;
 #endif			/* linux */
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
diff --git a/agent/mibgroup/mibII/tcpTable.c b/agent/mibgroup/mibII/tcpTable.c
index 03c85e5..817e4b5 100644
--- a/agent/mibgroup/mibII/tcpTable.c
+++ b/agent/mibgroup/mibII/tcpTable.c
@@ -36,6 +36,20 @@
 #include <linux/inet_diag.h>
 #endif
 
+#if HAVE_KVM_GETFILES
+#if defined(HAVE_KVM_GETFILE2) || !defined(openbsd5)
+#undef HAVE_KVM_GETFILES
+#endif
+#endif
+
+#if HAVE_KVM_GETFILES
+#include <kvm.h>
+#include <sys/sysctl.h>
+#define _KERNEL
+#include <sys/file.h>
+#undef _KERNEL
+#endif
+
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
@@ -55,9 +69,8 @@ netsnmp_feature_child_of(tcp_count_connections, tcptable_all)
 #define	TCPTABLE_REMOTEADDRESS	RemAddress 
 #define	TCPTABLE_REMOTEPORT	RemPort 
 #define	TCPTABLE_IS_TABLE
-#else
 
-#ifdef solaris2
+#elif defined(solaris2)
 typedef struct netsnmp_tcpConnEntry_s netsnmp_tcpConnEntry;
 struct netsnmp_tcpConnEntry_s {
     mib2_tcpConnEntry_t   entry;
@@ -70,9 +83,8 @@ struct netsnmp_tcpConnEntry_s {
 #define	TCPTABLE_REMOTEADDRESS	entry.tcpConnRemAddress 
 #define	TCPTABLE_REMOTEPORT	entry.tcpConnRemPort 
 #define	TCPTABLE_IS_LINKED_LIST
-#else
 
-#ifdef HAVE_IPHLPAPI_H
+#elif defined(HAVE_IPHLPAPI_H)
 #include <iphlpapi.h>
 #define	TCPTABLE_ENTRY_TYPE	MIB_TCPROW
 #define	TCPTABLE_STATE		dwState 
@@ -81,9 +93,8 @@ struct netsnmp_tcpConnEntry_s {
 #define	TCPTABLE_REMOTEADDRESS	dwRemoteAddr 
 #define	TCPTABLE_REMOTEPORT	dwRemotePort 
 #define	TCPTABLE_IS_TABLE
-#else
 
-#ifdef linux
+#elif defined(linux)
 #define	TCPTABLE_ENTRY_TYPE	struct inpcb 
 #define	TCPTABLE_STATE		inp_state 
 #define	TCPTABLE_LOCALADDRESS	inp_laddr.s_addr 
@@ -92,6 +103,15 @@ struct netsnmp_tcpConnEntry_s {
 #define	TCPTABLE_REMOTEPORT	inp_fport
 #define	TCPTABLE_IS_LINKED_LIST
 
+#elif HAVE_KVM_GETFILES
+#define	TCPTABLE_ENTRY_TYPE	struct kinfo_file
+#define	TCPTABLE_STATE		t_state 
+#define	TCPTABLE_LOCALADDRESS	inp_laddru[0]
+#define	TCPTABLE_LOCALPORT	inp_lport
+#define	TCPTABLE_REMOTEADDRESS	inp_faddru[0]
+#define	TCPTABLE_REMOTEPORT	inp_fport
+#define	TCPTABLE_IS_TABLE
+
 #else			/* everything else */
 
 typedef struct netsnmp_inpcb_s netsnmp_inpcb;
@@ -110,9 +130,6 @@ struct netsnmp_inpcb_s {
 #define	TCPTABLE_REMOTEPORT	pcb.inp_fport
 #define	TCPTABLE_IS_LINKED_LIST
 
-#endif                          /* linux */
-#endif                          /* WIN32 cygwin */
-#endif                          /* solaris2 */
 #endif                          /* hpux11 */
 
 				/* Head of linked list, or root of table */
@@ -213,6 +230,9 @@ tcpTable_handler(netsnmp_mib_handler          *handler,
     netsnmp_variable_list *requestvb;
     netsnmp_table_request_info *table_info;
     TCPTABLE_ENTRY_TYPE	  *entry;
+#if HAVE_KVM_GETFILES
+    int      StateMap[] = { 1, 2, 3, 4, 5, 8, 6, 10, 9, 7, 11 };
+#endif
     oid      subid;
     long     port;
     long     state;
@@ -236,7 +256,11 @@ tcpTable_handler(netsnmp_mib_handler          *handler,
 
             switch (subid) {
             case TCPCONNSTATE:
+#if HAVE_KVM_GETFILES
+                state = StateMap[entry->TCPTABLE_STATE];
+#else
                 state = entry->TCPTABLE_STATE;
+#endif
 	        snmp_set_var_typed_value(requestvb, ASN_INTEGER,
                                  (u_char *)&state, sizeof(state));
                 break;
@@ -346,6 +370,11 @@ tcpTable_next_entry( void **loop_context,
     netsnmp_variable_list *idx;
     long port;
 
+#if HAVE_KVM_GETFILES
+    while (i < tcp_size && (tcp_head[i].so_protocol != IPPROTO_TCP
+	    || tcp_head[i].so_family != AF_INET))
+	i++;
+#endif
     if (tcp_size < i)
         return NULL;
 
@@ -353,7 +382,7 @@ tcpTable_next_entry( void **loop_context,
      * Set up the indexing for the specified row...
      */
     idx = index;
-#if defined (WIN32) || defined (cygwin)
+#if defined (WIN32) || defined (cygwin) || defined(openbsd5)
     port = ntohl((u_long)tcp_head[i].TCPTABLE_LOCALADDRESS);
     snmp_set_var_value(idx, (u_char *)&port,
                                 sizeof(tcp_head[i].TCPTABLE_LOCALADDRESS));
@@ -367,7 +396,7 @@ tcpTable_next_entry( void **loop_context,
     snmp_set_var_value(idx, (u_char*)&port, sizeof(port));
 
     idx = idx->next_variable;
-#if defined (WIN32) || defined (cygwin)
+#if defined (WIN32) || defined (cygwin) || defined(openbsd5)
     port = ntohl((u_long)tcp_head[i].TCPTABLE_REMOTEADDRESS);
     snmp_set_var_value(idx, (u_char *)&port,
                                 sizeof(tcp_head[i].TCPTABLE_REMOTEADDRESS));
@@ -398,8 +427,9 @@ tcpTable_free(netsnmp_cache *cache, void *magic)
 		/* the allocated structure is a count followed by table entries */
 		free((char *)(tcp_head) - sizeof(DWORD));
 	}
+#elif defined(openbsd5)
 #else
-	if (tcp_head)
+    if (tcp_head)
         free(tcp_head);
 #endif
     tcp_head  = NULL;
@@ -558,9 +588,8 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
     DEBUGMSGTL(("mibII/tcpTable", "Failed to load TCP Table (hpux11)\n"));
     return -1;
 }
-#else                           /* hpux11 */
 
-#ifdef linux
+#elif defined(linux)
 
 /*  see <netinet/tcp.h> */
 #define TCP_ALL ((1 << (TCP_CLOSING + 1)) - 1)
@@ -654,7 +683,16 @@ tcpTable_load_netlink(void)
 				break;
 			}
 
-			r = nlmsg_data(h);
+			/** handle the case where the kernel doesn't have netlink socket 
+			 * diagnostics enabled */
+			if ((h->nlmsg_type == NLMSG_ERROR) && 
+				(((struct nlmsgerr *)r)->error != 0)) {
+				int nlerr = ((struct nlmsgerr *)r)->error;
+				running = 0;
+				DEBUGMSGTL(("mibII/tcpTable", "netlink error: %d\n", nlerr));
+				snmp_log(LOG_ERR, "snmpd: netlink error: %d\n", nlerr);
+				break;
+			}
 
 			if (r->idiag_family != AF_INET) {
 				h = nlmsg_next(h, &len);
@@ -729,6 +767,7 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
         unsigned int    lp, fp;
         int             state, uid;
 
+        memset(&pcb, 0, sizeof(pcb));
         if (6 != sscanf(line,
                         "%*d: %x:%x %x:%x %x %*X:%*X %*X:%*X %*X %d",
                         &pcb.inp_laddr.s_addr, &lp,
@@ -757,9 +796,9 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
     DEBUGMSGTL(("mibII/tcpTable", "Loaded TCP Table (linux)\n"));
     return 0;
 }
-#else                           /* linux */
 
-#ifdef solaris2
+#elif defined(solaris2)
+
 static int
 TCP_Cmp(void *addr, void *ep)
 {
@@ -816,9 +855,30 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
     DEBUGMSGTL(("mibII/tcpTable", "Failed to load TCP Table (solaris)\n"));
     return -1;
 }
-#else                           /* solaris2 */
 
-#if defined (WIN32) || defined (cygwin)
+#elif HAVE_KVM_GETFILES
+
+int
+tcpTable_load(netsnmp_cache *cache, void *vmagic)
+{
+    int i, count;
+    int      StateMap[] = { 1, 2, 3, 4, 5, 8, 6, 10, 9, 7, 11 };
+
+    tcp_head = kvm_getfiles(kd, KERN_FILE_BYFILE, DTYPE_SOCKET, sizeof(struct kinfo_file), &count);
+    tcp_size = count;
+    for (i = 0; i < tcp_size; i++) {
+	if (tcp_head[i].so_protocol != IPPROTO_TCP || tcp_head[i].so_family != AF_INET)
+	    continue;
+	if (StateMap[tcp_head[i].TCPTABLE_STATE] == 5 /* established */ ||
+	    StateMap[tcp_head[i].TCPTABLE_STATE] == 8 /*  closeWait  */ )
+	    tcp_estab++;
+    }
+
+    return 0;
+}
+
+#elif defined (WIN32) || defined (cygwin)
+
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -864,9 +924,8 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
 		free(pTcpTable);
     return -1;
 }
-#else                           /* WIN32 cygwin */
 
-#if (defined(NETSNMP_CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST))
+#elif (defined(NETSNMP_CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST))
 
 #if defined(freebsd4) || defined(darwin)
     #define NS_ELEM struct xtcpcb
@@ -930,7 +989,11 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
         memcpy(&(nnew->pcb), &(((NS_ELEM *) xig)->xt_inp),
                            sizeof(struct inpcb));
 
+#ifdef INP_ISIPV6
+	if (INP_ISIPV6(&nnew->pcb))
+#else
 	if (nnew->pcb.inp_vflag & INP_IPV6)
+#endif
 	    free(nnew);
 	else {
 	    nnew->inp_next = tcp_head;
@@ -953,8 +1016,8 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
 }
 #undef NS_ELEM
 
-#else		/* (defined(NETSNMP_CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST)) */
-#ifdef PCB_TABLE
+#elif defined(PCB_TABLE)
+
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -974,7 +1037,7 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
     /*
      *  Set up a linked list
      */
-    entry  = table.inpt_queue.cqh_first;
+    entry  = table.INP_FIRST_SYMBOL;
     while (entry) {
    
         nnew = SNMP_MALLOC_TYPEDEF(netsnmp_inpcb);
@@ -998,7 +1061,7 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
 	nnew->inp_next = tcp_head;
 	tcp_head   = nnew;
 
-        if (entry == table.inpt_queue.cqh_first)
+        if (entry == table.INP_FIRST_SYMBOL)
             break;
     }
 
@@ -1010,8 +1073,8 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
     return -1;
 }
 
-#else				/* PCB_TABLE */
-#ifdef TCP_SYMBOL
+#elif defined(TCP_SYMBOL)
+
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -1070,17 +1133,11 @@ tcpTable_load(netsnmp_cache *cache, void *vmagic)
     return -1;
 }
 
-#else				/* UDB_SYMBOL */
+#else				/* TCP_SYMBOL */
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
 {
     DEBUGMSGTL(("mibII/tcpTable", "Loading TCP Table not implemented\n"));
     return -1;
 }
-#endif				/* UDB_SYMBOL */
-#endif				/* PCB_TABLE */
-#endif		/* (defined(NETSNMP_CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST)) */
-#endif                          /* WIN32 cygwin */
-#endif                          /* linux */
-#endif                          /* solaris2 */
-#endif                          /* hpux11 */
+#endif				/* TCP_SYMBOL */
diff --git a/agent/mibgroup/mibII/udpTable.c b/agent/mibgroup/mibII/udpTable.c
index 2c88749..62845be 100644
--- a/agent/mibgroup/mibII/udpTable.c
+++ b/agent/mibgroup/mibII/udpTable.c
@@ -24,6 +24,20 @@
 #include <netinet/udp_var.h>
 #endif
 
+#if HAVE_KVM_GETFILES
+#if defined(HAVE_KVM_GETFILE2) || !defined(openbsd5)
+#undef HAVE_KVM_GETFILES
+#endif
+#endif
+
+#if HAVE_KVM_GETFILES
+#include <kvm.h>
+#include <sys/sysctl.h>
+#define _KERNEL
+#include <sys/file.h>
+#undef _KERNEL
+#endif
+
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
@@ -39,9 +53,8 @@
 #define	UDPTABLE_LOCALADDRESS	LocalAddress 
 #define	UDPTABLE_LOCALPORT	LocalPort 
 #define	UDPTABLE_IS_TABLE
-#else
 
-#ifdef solaris2
+#elif defined(solaris2)
 typedef struct netsnmp_udpEntry_s netsnmp_udpEntry;
 struct netsnmp_udpEntry_s {
     mib2_udpEntry_t   entry;
@@ -51,19 +64,28 @@ struct netsnmp_udpEntry_s {
 #define	UDPTABLE_LOCALADDRESS	entry.udpLocalAddress 
 #define	UDPTABLE_LOCALPORT	entry.udpLocalPort 
 #define	UDPTABLE_IS_LINKED_LIST
-#else
 
-#ifdef HAVE_IPHLPAPI_H
+#elif defined(HAVE_IPHLPAPI_H)
 #include <iphlpapi.h>
 #define	UDPTABLE_ENTRY_TYPE	MIB_UDPROW		/* ??? */
 #define	UDPTABLE_LOCALADDRESS	dwLocalAddr
 #define	UDPTABLE_LOCALPORT	dwLocalPort 
 #define	UDPTABLE_IS_TABLE
-#else			/* everything else */
 
-#ifdef linux
+#elif defined(HAVE_KVM_GETFILES)
+#define	UDPTABLE_ENTRY_TYPE	struct kinfo_file
+#define	UDPTABLE_LOCALADDRESS	inp_laddru[0]
+#define	UDPTABLE_LOCALPORT	inp_lport 
+#define	UDPTABLE_IS_TABLE
+
+#elif defined(linux)
 #define INP_NEXT_SYMBOL		inp_next
-#endif
+#define	UDPTABLE_ENTRY_TYPE	struct inpcb 
+#define	UDPTABLE_LOCALADDRESS	inp_laddr.s_addr 
+#define	UDPTABLE_LOCALPORT	inp_lport
+#define	UDPTABLE_IS_LINKED_LIST
+
+#else
 #ifdef openbsd4
 #define INP_NEXT_SYMBOL		inp_queue.cqe_next	/* or set via <net-snmp/system/openbsd.h> */
 #endif
@@ -85,8 +107,6 @@ struct netsnmp_inpcb_s {
 #endif
 #define	UDPTABLE_IS_LINKED_LIST
 
-#endif                          /* WIN32 cygwin */
-#endif                          /* solaris2 */
 #endif                          /* hpux11 */
 
 				/* Head of linked list, or root of table */
@@ -298,13 +318,18 @@ udpTable_next_entry( void **loop_context,
     int i = (int)*loop_context;
     long port;
 
+#if HAVE_KVM_GETFILES
+    while (i < udp_size && (udp_head[i].so_protocol != IPPROTO_UDP
+	    || udp_head[i].so_family != AF_INET))
+	i++;
+#endif
     if (udp_size < i)
         return NULL;
 
     /*
      * Set up the indexing for the specified row...
      */
-#if defined (WIN32) || defined (cygwin)
+#if defined (WIN32) || defined (cygwin) || defined(openbsd5)
     port = ntohl((u_long)udp_head[i].UDPTABLE_LOCALADDRESS);
     snmp_set_var_value(index, (u_char *)&port,
                                   sizeof(udp_head[i].UDPTABLE_LOCALADDRESS));
@@ -332,6 +357,7 @@ udpTable_free(netsnmp_cache *cache, void *magic)
 		/* the allocated structure is a count followed by table entries */
 		free((char *)(udp_head) - sizeof(DWORD));
 	}
+#elif defined(openbsd5)
 #else
     if (udp_head)
         free(udp_head);
@@ -370,7 +396,7 @@ udpTable_next_entry( void **loop_context,
 {
     UDPTABLE_ENTRY_TYPE	 *entry = (UDPTABLE_ENTRY_TYPE *)*loop_context;
     long port;
-    long addr;
+    in_addr_t addr;
 
     if (!entry)
         return NULL;
@@ -467,9 +493,8 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
     DEBUGMSGTL(("mibII/udpTable", "Failed to load UDP Table (hpux11)\n"));
     return -1;
 }
-#else                           /* hpux11 */
 
-#ifdef linux
+#elif defined(linux)
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -519,9 +544,20 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
     DEBUGMSGTL(("mibII/udpTable", "Loaded UDP Table (linux)\n"));
     return 0;
 }
-#else                           /* linux */
 
-#ifdef solaris2
+#elif HAVE_KVM_GETFILES
+
+int
+udpTable_load(netsnmp_cache *cache, void *vmagic)
+{
+    int count;
+    udp_head = kvm_getfiles(kd, KERN_FILE_BYFILE, DTYPE_SOCKET, sizeof(struct kinfo_file), &count);
+    udp_size = count;
+    DEBUGMSGTL(("mibII/udpTable", "Loaded UDP Table (kvm_getfiles)\n"));
+    return 0;
+}
+
+#elif defined(solaris2)
 static int
 UDP_Cmp(void *addr, void *ep)
 {
@@ -586,9 +622,8 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
     DEBUGMSGTL(("mibII/udpTable", "Failed to load UDP Table (solaris)\n"));
     return -1;
 }
-#else                           /* solaris2 */
 
-#if defined (WIN32) || defined (cygwin)
+#elif defined (WIN32) || defined (cygwin)
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -620,9 +655,8 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
 	free(pUdpTable);
     return -1;
 }
-#else                           /* WIN32 cygwin*/
 
-#if (defined(NETSNMP_CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST))
+#elif (defined(NETSNMP_CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST))
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -688,8 +722,8 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
     DEBUGMSGTL(("mibII/udpTable", "Failed to load UDP Table (sysctl)\n"));
     return -1;
 }
-#else		/* (defined(NETSNMP_CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST)) */
-#ifdef PCB_TABLE
+
+#elif defined(PCB_TABLE)
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -706,7 +740,7 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
     /*
      *  Set up a linked list
      */
-    entry  = table.inpt_queue.cqh_first;
+    entry  = table.INP_FIRST_SYMBOL;
     while (entry) {
    
         nnew = SNMP_MALLOC_TYPEDEF(struct inpcb);
@@ -718,11 +752,11 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
             break;
         }
 
-        entry    = nnew->inp_queue.cqe_next;	/* Next kernel entry */
-	nnew->inp_queue.cqe_next = udp_head;
+        entry    = nnew->INP_NEXT_SYMBOL;	/* Next kernel entry */
+	nnew->INP_NEXT_SYMBOL = udp_head;
 	udp_head = nnew;
 
-        if (entry == table.inpt_queue.cqh_first)
+        if (entry == table.INP_FIRST_SYMBOL)
             break;
     }
 
@@ -734,8 +768,7 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
     return -1;
 }
 
-#else				/* PCB_TABLE */
-#ifdef UDB_SYMBOL
+#elif defined(UDB_SYMBOL)
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -788,9 +821,3 @@ udpTable_load(netsnmp_cache *cache, void *vmagic)
     return -1;
 }
 #endif				/* UDB_SYMBOL */
-#endif				/* PCB_TABLE */
-#endif		/* (defined(NETSNMP_CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST)) */
-#endif                          /* WIN32 cygwin*/
-#endif                          /* linux */
-#endif                          /* solaris2 */
-#endif                          /* hpux11 */
diff --git a/agent/mibgroup/mibII/updates.c b/agent/mibgroup/mibII/updates.c
index 938ea29..7fc99e3 100644
--- a/agent/mibgroup/mibII/updates.c
+++ b/agent/mibgroup/mibII/updates.c
@@ -1,6 +1,7 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "updates.h"
 
 static int
 handle_updates(netsnmp_mib_handler *handler,
diff --git a/agent/mibgroup/mibII/vacm_context.c b/agent/mibgroup/mibII/vacm_context.c
index 8f43cd3..aab1688 100644
--- a/agent/mibgroup/mibII/vacm_context.c
+++ b/agent/mibgroup/mibII/vacm_context.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 
 #if HAVE_STRING_H
@@ -95,7 +106,7 @@ init_vacm_context(void)
     if (!table_info || !iinfo) {
         SNMP_FREE(table_info);
         SNMP_FREE(iinfo);
-        SNMP_FREE(my_handler);
+        netsnmp_handler_registration_free(my_handler);
         return;
     }
 
diff --git a/agent/mibgroup/mibII/vacm_vars.c b/agent/mibgroup/mibII/vacm_vars.c
index 85cef94..2a05743 100644
--- a/agent/mibgroup/mibII/vacm_vars.c
+++ b/agent/mibgroup/mibII/vacm_vars.c
@@ -10,6 +10,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -103,7 +108,7 @@ init_vacm_vars(void)
          var_vacm_view, 3, {2, 1, 4}},
         {VIEWSTORAGE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
          var_vacm_view, 3, {2, 1, 5}},
-        {VIEWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
+        {VACMVIEWSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
          var_vacm_view, 3, {2, 1, 6}},
     };
 
@@ -145,7 +150,7 @@ var_vacm_sec2group(struct variable * vp,
     struct vacm_groupEntry *gp;
     oid            *groupSubtree;
     ssize_t         groupSubtreeLen;
-    int             secmodel;
+    oid             secmodel;
     char            secname[VACMSTRINGLEN], *cp;
 
     /*
@@ -267,7 +272,7 @@ var_vacm_access(struct variable * vp,
                 int exact, size_t * var_len, WriteMethod ** write_method)
 {
     struct vacm_accessEntry *gp;
-    int             secmodel, seclevel;
+    oid             secmodel, seclevel;
     char            groupName[VACMSTRINGLEN] = { 0 };
     char            contextPrefix[VACMSTRINGLEN] = { 0 };
     oid            *op;
@@ -372,11 +377,12 @@ var_vacm_access(struct variable * vp,
             if (len > VACM_MAX_STRING)
                 return NULL;
             cp = groupName;
-            for (i = 0; i <= len; i++) {
+            for (i = 0; i <= len && op < name + *length; i++) {
                 if (*op > 255) {
-                    return NULL;   /* illegal value */
-                }
-                *cp++ = (char) *op++;
+                    *cp++ = 255;
+                    ++op;
+                } else
+                    *cp++ = (char) *op++;
             }
             *cp = 0;
         }
@@ -386,11 +392,12 @@ var_vacm_access(struct variable * vp,
             if (len > VACM_MAX_STRING)
                 return NULL;
             cp = contextPrefix;
-            for (i = 0; i <= len; i++) {
+            for (i = 0; i <= len && op < name + *length; i++) {
                 if (*op > 255) {
-                    return NULL;   /* illegal value */
-                }
-                *cp++ = (char) *op++;
+                    *cp++ = 255;
+                    ++op;
+                } else
+                    *cp++ = (char) *op++;
             }
             *cp = 0;
         }
@@ -515,7 +522,7 @@ var_vacm_view(struct variable * vp,
     case VIEWSTORAGE:
         *write_method = write_vacmViewStorageType;
         break;
-    case VIEWSTATUS:
+    case VACMVIEWSTATUS:
         *write_method = write_vacmViewStatus;
         break;
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */ 
@@ -583,9 +590,10 @@ var_vacm_view(struct variable * vp,
                 cp = viewName;
                 for (i = 0; i <= len && op < name + *length; i++) {
                     if (*op > 255) {
-                        return NULL;
-                    }
-                    *cp++ = (char) *op++;
+                        *cp++ = 255;
+                        ++op;
+                    } else
+                        *cp++ = (char) *op++;
                 }
                 *cp = 0;
             }
@@ -662,7 +670,7 @@ var_vacm_view(struct variable * vp,
         long_return = gp->viewStorageType;
         return (u_char *) & long_return;
 
-    case VIEWSTATUS:
+    case VACMVIEWSTATUS:
         long_return = gp->viewStatus;
         return (u_char *) & long_return;
     }
diff --git a/agent/mibgroup/mibII/var_route.c b/agent/mibgroup/mibII/var_route.c
index 72a503f..0326d1e 100644
--- a/agent/mibgroup/mibII/var_route.c
+++ b/agent/mibgroup/mibII/var_route.c
@@ -75,8 +75,6 @@ netsnmp_feature_child_of(get_routes, libnetsnmpmibs)
 #include <netinet/mib_kern.h>
 #endif                          /* hpux */
 
-extern WriteMethod write_rte;
-
 #if !defined (WIN32) && !defined (cygwin)
 
 #ifdef USE_SYSCTL_ROUTE_DUMP
@@ -87,9 +85,6 @@ static unsigned char *all_routes = 0;
 static unsigned char *all_routes_end;
 static size_t   all_routes_size;
 
-extern const struct sockaddr *get_address(const void *, int, int);
-extern const struct in_addr *get_in_address(const void *, int, int);
-
 /*
  * var_ipRouteEntry(...
  * Arguments:
@@ -772,6 +767,8 @@ var_ipRouteEntry(struct variable * vp,
         if(entry.ipRouteInfo.re_ire_type&IRE_CACHE)
             continue;
 #endif /* HAVE_DEFINED_IRE_CACHE */
+        if(entry.ipRouteInfo.re_ire_type & IRE_BROADCAST)
+            continue;
         COPY_IPADDR(cp, (u_char *) & entry.ipRouteDest, op,
                     current + IP_ROUTEADDR_OFF);
         if (exact) {
diff --git a/agent/mibgroup/mibII/var_route.h b/agent/mibgroup/mibII/var_route.h
index 7862c43..cdcf0a8 100644
--- a/agent/mibgroup/mibII/var_route.h
+++ b/agent/mibgroup/mibII/var_route.h
@@ -8,6 +8,13 @@
 config_require(mibII/ip)
 config_arch_require(solaris2, kernel_sunos5)
 
+#if defined(HAVE_IPHLPAPI_H)
+     struct _MIB_IPFORWARDROW;
+
+     extern struct _MIB_IPFORWARDROW *route_row;
+#endif
+     extern int      create_flag;
+
      void            init_var_route(void);
 #if defined(RTENTRY_4_4) && !defined(hpux11)
      struct radix_node;
diff --git a/agent/mibgroup/misc/ipfwacc.c b/agent/mibgroup/misc/ipfwacc.c
index cca9871..6fb0d9f 100644
--- a/agent/mibgroup/misc/ipfwacc.c
+++ b/agent/mibgroup/misc/ipfwacc.c
@@ -256,7 +256,7 @@ var_ipfwacc(struct variable *vp,
             size_t * length,
             int exact, size_t * var_len, WriteMethod ** write_method)
 {
-    *write_method = 0;          /* assume it isnt writable for the time being */
+    *write_method = NULL;       /* assume it isnt writable for the time being */
     *var_len = sizeof(ret_val); /* assume an integer and change later if not */
 
     if (header_simple_table
diff --git a/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c b/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c
index 48d4aca..ef7e98a 100644
--- a/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c
+++ b/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c
@@ -279,6 +279,7 @@ etherStatsTable_container_load(netsnmp_container * container)
         if (NULL == rowreq_ctx) {
             snmp_log(LOG_ERR, "memory allocation failed\n");
             close(fd);
+            etherstats_interface_name_list_free(list_head);
             return MFD_RESOURCE_UNAVAILABLE;
         }
 
diff --git a/agent/mibgroup/sctp-mib/sctpScalars_common.c b/agent/mibgroup/sctp-mib/sctpScalars_common.c
index 2a895a8..f0a10a3 100644
--- a/agent/mibgroup/sctp-mib/sctpScalars_common.c
+++ b/agent/mibgroup/sctp-mib/sctpScalars_common.c
@@ -12,7 +12,7 @@ netsnmp_sctp_params sctp_params;
 static int      need_wrap_check = 1;
 
 void
-netsnmp_access_sctp_stats_init()
+netsnmp_access_sctp_stats_init(void)
 {
     netsnmp_access_sctp_stats_arch_init();
 }
@@ -140,7 +140,7 @@ netsnmp_access_sctp_stats_free(netsnmp_cache * cache, void *magic)
 }
 
 void
-netsnmp_access_sctp_params_init()
+netsnmp_access_sctp_params_init(void)
 {
     netsnmp_access_sctp_params_arch_init();
 }
diff --git a/agent/mibgroup/sctp-mib/sctpScalars_linux.c b/agent/mibgroup/sctp-mib/sctpScalars_linux.c
index 6da5a6b..7982105 100644
--- a/agent/mibgroup/sctp-mib/sctpScalars_linux.c
+++ b/agent/mibgroup/sctp-mib/sctpScalars_linux.c
@@ -44,7 +44,7 @@ load_uint_file(const char *filename, u_int * value)
 }
 
 void
-netsnmp_access_sctp_stats_arch_init()
+netsnmp_access_sctp_stats_arch_init(void)
 {
 }
 
@@ -155,7 +155,7 @@ netsnmp_access_sctp_stats_arch_load(netsnmp_sctp_stats * sctp_stats)
 }
 
 void
-netsnmp_access_sctp_params_arch_init()
+netsnmp_access_sctp_params_arch_init(void)
 {
 }
 
diff --git a/agent/mibgroup/smux/smux.c b/agent/mibgroup/smux/smux.c
index 4598c2b..b60b285 100644
--- a/agent/mibgroup/smux/smux.c
+++ b/agent/mibgroup/smux/smux.c
@@ -451,6 +451,8 @@ var_smux_write(int action,
              */
             packet_len = len;
             ptr = asn_parse_header(buf, &packet_len, &type);
+            if (ptr == NULL)
+                return SNMP_ERR_GENERR;
             packet_len += (ptr - buf);
             if (len > (ssize_t)packet_len) {
                 /*
@@ -483,9 +485,11 @@ var_smux_write(int action,
 
             if (buf[0] == SMUX_TRAP) {
                 DEBUGMSGTL(("smux", "[var_smux_write] Received trap\n"));
-                snmp_log(LOG_INFO, "Got trap from peer on fd %d\n",
-                         rptr->sr_fd);
+                DEBUGMSGTL(("smux", "Got trap from peer on fd %d\n",
+                         rptr->sr_fd));
                 ptr = asn_parse_header(buf, &len, &type);
+                if (ptr == NULL)
+                    return SNMP_ERR_GENERR;
                 smux_trap_process(ptr, &len);
 
 
@@ -593,14 +597,14 @@ smux_accept(int sd)
         snmp_log_perror("[smux_accept] accept failed");
         return -1;
     } else {
-        snmp_log(LOG_INFO, "[smux_accept] accepted fd %d from %s:%d\n",
+        DEBUGMSGTL(("smux", "[smux_accept] accepted fd %d from %s:%d\n",
                  fd, inet_ntoa(in_socket.sin_addr),
-                 ntohs(in_socket.sin_port));
+                 ntohs(in_socket.sin_port)));
         if (npeers + 1 == SMUXMAXPEERS) {
             snmp_log(LOG_ERR,
                      "[smux_accept] denied peer on fd %d, limit %d reached",
                      fd, SMUXMAXPEERS);
-            close(sd);
+            close(fd);
             return -1;
         }
 
@@ -694,7 +698,8 @@ smux_process(int fd)
 
     if (length <= 0)
     {
-       snmp_log_perror("[smux_process] peek failed");
+       if (length < 0)
+           snmp_log_perror("[smux_process] peek failed");
        smux_peer_cleanup(fd);
        return -1;
     }
@@ -704,6 +709,8 @@ smux_process(int fd)
      */
     packet_len = length;
     ptr = asn_parse_header(data, &packet_len, &type);
+    if (ptr == NULL)
+        return -1;
     packet_len += (ptr - data);
     if (length > packet_len) {
         /*
@@ -750,6 +757,10 @@ smux_pdu_process(int fd, u_char * data, size_t length)
     while (error == 0 && ptr != NULL && ptr < data + length) {
         len = length - (ptr - data);
         ptr = asn_parse_header(ptr, &len, &type);
+        if (ptr == NULL) {
+            DEBUGMSGTL(("smux", "[smux_pdu_process] cannot parse header\n"));
+            break;
+        }
         DEBUGMSGTL(("smux", "[smux_pdu_process] type is %d\n",
                     (int) type));
         switch (type) {
@@ -784,7 +795,7 @@ smux_pdu_process(int fd, u_char * data, size_t length)
             DEBUGMSGTL(("smux", "This shouldn't have happened!\n"));
             break;
         case SMUX_TRAP:
-            snmp_log(LOG_INFO, "Got trap from peer on fd %d\n", fd);
+            DEBUGMSGTL(("smux", "Got trap from peer on fd %d\n", fd));
             if (ptr)
             {
                DEBUGMSGTL(("smux", "[smux_pdu_process] call smux_trap_process.\n"));
@@ -890,9 +901,9 @@ smux_open_process(int fd, u_char * ptr, size_t * len, int *fail)
         *fail = TRUE;
         return ptr;
     }
-    snmp_log(LOG_INFO,
+    DEBUGMSGTL(("smux",
              "accepted smux peer: oid %s, descr %s\n",
-             oid_print, descr);
+             oid_print, descr));
     *fail = FALSE;
     return ptr;
 }
@@ -1426,6 +1437,8 @@ smux_snmp_process(int exact,
          */
         packet_len = length;
         ptr = asn_parse_header(result, &packet_len, &type);
+        if (ptr == NULL)
+            return NULL;
         packet_len += (ptr - result);
         if (length > packet_len) {
             /*
@@ -1457,8 +1470,10 @@ smux_snmp_process(int exact,
 
         if (result[0] == SMUX_TRAP) {
             DEBUGMSGTL(("smux", "[smux_snmp_process] Received trap\n"));
-            snmp_log(LOG_INFO, "Got trap from peer on fd %d\n", sd);
+            DEBUGMSGTL(("smux", "Got trap from peer on fd %d\n", sd));
             ptr = asn_parse_header(result, (size_t *) &length, &type);
+            if (ptr == NULL)
+                return NULL;
             smux_trap_process(ptr, (size_t *) &length);
 
             /*
@@ -1809,7 +1824,7 @@ smux_peer_cleanup(int sd)
             Auths[i]->sa_active_fd = -1;
             snprint_objid(oid_name, sizeof(oid_name), Auths[i]->sa_oid,
                           Auths[i]->sa_oid_len);
-            snmp_log(LOG_INFO, "peer disconnected: %s\n", oid_name);
+            DEBUGMSGTL(("smux", "peer disconnected: %s\n", oid_name));
         }
     }
 }
@@ -1945,9 +1960,8 @@ smux_trap_process(u_char * rsp, size_t * len)
         ptr = snmp_parse_var_op(ptr, var_name, &var_name_len, &vartype,
                                 &var_val_len, (u_char **) & var_val, len);
 
-        if (ptr == NULL) {
-            return NULL;
-        }
+        if (ptr == NULL)
+            goto err;
 
         maxlen = SMUXMAXPKTSIZE;
         switch ((short) vartype) {
@@ -1981,7 +1995,7 @@ smux_trap_process(u_char * rsp, size_t * len)
              */
             if ((var_val =
                  asn_parse_header(var_val, &maxlen, &vartype)) == NULL)
-                return NULL;
+                goto err;
             memcpy((u_char *) & (smux_sa.sin_addr.s_addr), var_val,
                    var_val_len);
             var_val = (u_char *) & (smux_sa.sin_addr.s_addr);
@@ -1991,8 +2005,6 @@ smux_trap_process(u_char * rsp, size_t * len)
             /*
              * XXX 
              */
-            if (len == NULL)
-                return NULL;
             var_val_len = SMUXMAXSTRLEN;
             asn_parse_string(var_val, &maxlen, &vartype,
                              smux_str, &var_val_len);
@@ -2015,8 +2027,6 @@ smux_trap_process(u_char * rsp, size_t * len)
             /*
              * XXX 
              */
-            if (len == NULL)
-                return NULL;
             var_val_len = SMUXMAXSTRLEN;
             asn_parse_bitstring(var_val, &maxlen, &vartype,
                                 smux_str, &var_val_len);
@@ -2029,12 +2039,9 @@ smux_trap_process(u_char * rsp, size_t * len)
             break;
         }
 
-        snmptrap_tmp =
-            (netsnmp_variable_list *)
-            malloc(sizeof(netsnmp_variable_list));
+        snmptrap_tmp = calloc(1, sizeof(netsnmp_variable_list));
         if (snmptrap_tmp == NULL)
-            return NULL;
-        memset(snmptrap_tmp, 0, sizeof(netsnmp_variable_list));
+            goto err;
         if (snmptrap_head == NULL) {
             snmptrap_head = snmptrap_tmp;
             snmptrap_ptr = snmptrap_head;
@@ -2063,6 +2070,9 @@ smux_trap_process(u_char * rsp, size_t * len)
 
     return ptr;
 
+err:
+    snmp_free_varbind(snmptrap_head);
+    return NULL;
 }
 
 #define NUM_SOCKETS	32
diff --git a/agent/mibgroup/smux/snmp_bgp.c b/agent/mibgroup/smux/snmp_bgp.c
index 16b0185..a97ca35 100644
--- a/agent/mibgroup/smux/snmp_bgp.c
+++ b/agent/mibgroup/smux/snmp_bgp.c
@@ -112,7 +112,6 @@ init_snmp_bdp(void)
 static oid      max_bgp_mib[] =
     { 1, 3, 6, 1, 2, 1, 15, 5, 1, 6, 255, 255, 255, 255 };
 static oid      min_bgp_mib[] = { 1, 3, 6, 1, 2, 1, 15, 1, 0 };
-extern u_char   smux_type;
 
 u_char         *
 var_bgp(struct variable *vp,
diff --git a/agent/mibgroup/smux/snmp_ospf.c b/agent/mibgroup/smux/snmp_ospf.c
index 73f0e43..4b6d640 100644
--- a/agent/mibgroup/smux/snmp_ospf.c
+++ b/agent/mibgroup/smux/snmp_ospf.c
@@ -54,7 +54,6 @@
 static oid      max_ospf_mib[] = { 1, 3, 6, 1, 2, 1, 14, 14, 1, 6, 0 };
 static oid      min_ospf_mib[] =
     { 1, 3, 6, 1, 2, 1, 14, 1, 1, 0, 0, 0, 0 };
-extern u_char   smux_type;
 
 struct variable13 ospf_variables[] = {
     {ospfRouterId, ASN_IPADDRESS, NETSNMP_OLDAPI_RWRITE,
diff --git a/agent/mibgroup/smux/snmp_rip2.c b/agent/mibgroup/smux/snmp_rip2.c
index b987a09..9d49a30 100644
--- a/agent/mibgroup/smux/snmp_rip2.c
+++ b/agent/mibgroup/smux/snmp_rip2.c
@@ -54,7 +54,6 @@
 static oid      max_rip_mib[] =
     { 1, 3, 6, 1, 2, 1, 23, 3, 1, 9, 255, 255, 255, 255 };
 static oid      min_rip_mib[] = { 1, 3, 6, 1, 2, 1, 23, 1, 1, 0 };
-extern u_char   smux_type;
 
 struct variable13 rip2_variables[] = {
     {RIP2GLOBALROUTECHANGES, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
diff --git a/agent/mibgroup/snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable_interface.c b/agent/mibgroup/snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable_interface.c
index 4040e3f..81cb544 100644
--- a/agent/mibgroup/snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable_interface.c
+++ b/agent/mibgroup/snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable_interface.c
@@ -201,23 +201,9 @@ snmpNotifyFilterTable_data *snmpNotifyFilterTable_allocate_data(void);
  *    (Define its contents and how it's structured)
  */
 void
- 
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    _snmpNotifyFilterTable_initialize_interface
-    (snmpNotifyFilterTable_registration * reg_ptr, u_long flags) {
+_snmpNotifyFilterTable_initialize_interface
+    (snmpNotifyFilterTable_registration *reg_ptr, u_long flags)
+{
     netsnmp_baby_steps_access_methods *access_multiplexer =
         &snmpNotifyFilterTable_if_ctx.access_multiplexer;
     netsnmp_table_registration_info *tbl_info =
@@ -326,10 +312,12 @@ void
                                             handler,
                                             snmpNotifyFilterTable_oid,
                                             snmpNotifyFilterTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
-                                            | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT  */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR,
@@ -413,23 +401,9 @@ void
  * Shutdown the table snmpNotifyFilterTable
  */
 void
- 
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    
-    _snmpNotifyFilterTable_shutdown_interface
-    (snmpNotifyFilterTable_registration * reg_ptr) {
+_snmpNotifyFilterTable_shutdown_interface
+    (snmpNotifyFilterTable_registration *reg_ptr)
+{
     /*
      * shutdown the container
      */
@@ -448,9 +422,8 @@ snmpNotifyFilterTable_valid_columns_set(netsnmp_column_info *vc)
  * convert the index component stored in the context to an oid
  */
 int
-snmpNotifyFilterTable_index_to_oid(netsnmp_index * oid_idx,
-                                   snmpNotifyFilterTable_mib_index *
-                                   mib_idx)
+snmpNotifyFilterTable_index_to_oid(netsnmp_index *oid_idx,
+                                   snmpNotifyFilterTable_mib_index *mib_idx)
 {
     int             err = SNMP_ERR_NOERROR;
 
@@ -523,9 +496,8 @@ snmpNotifyFilterTable_index_to_oid(netsnmp_index * oid_idx,
  * @retval SNMP_ERR_GENERR   : error
  */
 int
-snmpNotifyFilterTable_index_from_oid(netsnmp_index * oid_idx,
-                                     snmpNotifyFilterTable_mib_index *
-                                     mib_idx)
+snmpNotifyFilterTable_index_from_oid(netsnmp_index *oid_idx,
+                                     snmpNotifyFilterTable_mib_index *mib_idx)
 {
     int             err = SNMP_ERR_NOERROR;
 
diff --git a/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_data_get.c b/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_data_get.c
index 427d26f..7c9b4cd 100644
--- a/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_data_get.c
+++ b/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_data_get.c
@@ -125,13 +125,13 @@ usmDHUserKeyTable_allocate_data(void)
     if (NULL == rtn) {
         snmp_log(LOG_ERR, "unable to malloc memory for new "
                  "usmDHUserKeyTable_data.\n");
+    } else {
+        /*
+         * not real user, not in a list. mark for testing
+         */
+        rtn->next = (struct usmUser *) -1;
+        rtn->prev = (struct usmUser *) -1;
     }
-    /*
-     * not real user, not in a list. mark for testing
-     */
-    rtn->next = (struct usmUser *) -1;
-    rtn->prev = (struct usmUser *) -1;
-
     return rtn;
 }                               /* usmDHUserKeyTable_allocate_data */
 
diff --git a/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_interface.c b/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_interface.c
index 04231f9..83e8635 100644
--- a/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_interface.c
+++ b/agent/mibgroup/snmp-usm-dh-objects-mib/usmDHUserKeyTable/usmDHUserKeyTable_interface.c
@@ -266,10 +266,12 @@ _usmDHUserKeyTable_initialize_interface(usmDHUserKeyTable_registration *
         netsnmp_handler_registration_create("usmDHUserKeyTable", handler,
                                             usmDHUserKeyTable_oid,
                                             usmDHUserKeyTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #ifndef NETSNMP_DISABLE_SET_SUPPORT
-                                          | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_DISABLE_SET_SUPPORT */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR, "error registering table usmDHUserKeyTable\n");
diff --git a/agent/mibgroup/snmpv3/snmpEngine.c b/agent/mibgroup/snmpv3/snmpEngine.c
index e756788..af24d97 100644
--- a/agent/mibgroup/snmpv3/snmpEngine.c
+++ b/agent/mibgroup/snmpv3/snmpEngine.c
@@ -76,15 +76,6 @@ init_snmpEngine(void)
     register_snmpEngine_scalars();
 }
 
-#ifndef NETSNMP_NO_WRITE_SUPPORT
-#ifdef NETSNMP_ENABLE_TESTING_CODE
-int             write_engineBoots(int, u_char *, u_char, size_t, u_char *,
-                                  oid *, size_t);
-int             write_engineTime(int, u_char *, u_char, size_t, u_char *,
-                                 oid *, size_t);
-#endif                          /* NETSNMP_ENABLE_TESTING_CODE */
-#endif /* NETSNMP_NO_WRITE_SUPPORT */
-
 u_char         *
 var_snmpEngine(struct variable *vp,
                oid * name,
diff --git a/agent/mibgroup/snmpv3/snmpMPDStats_5_5.c b/agent/mibgroup/snmpv3/snmpMPDStats_5_5.c
index a7fc2ce..2b07f7d 100644
--- a/agent/mibgroup/snmpv3/snmpMPDStats_5_5.c
+++ b/agent/mibgroup/snmpv3/snmpMPDStats_5_5.c
@@ -1,5 +1,14 @@
 /*
  * snmpMPDStats.c: tallies errors for SNMPv3 message processing.
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -32,12 +41,17 @@ init_snmpMPDStats_5_5(void)
         netsnmp_create_handler_registration(
             "snmpMPDStats", NULL, snmpMPDStats, OID_LENGTH(snmpMPDStats),
             HANDLER_CAN_RONLY);
-    if (s &&
-	NETSNMP_REGISTER_STATISTIC_HANDLER(s, 1, MPD) == MIB_REGISTERED_OK) {
-        REGISTER_SYSOR_ENTRY(snmpMPDCompliance,
-                             "The MIB for Message Processing and Dispatching.");
-        snmpMPDStats_reg = s;
+    if (!s)
+        return;
+
+    if (NETSNMP_REGISTER_STATISTIC_HANDLER(s, 1, MPD) != MIB_REGISTERED_OK) {
+        netsnmp_handler_registration_free(s);
+        return;
     }
+
+    REGISTER_SYSOR_ENTRY(snmpMPDCompliance,
+                         "The MIB for Message Processing and Dispatching.");
+    snmpMPDStats_reg = s;
 }
 
 void
diff --git a/agent/mibgroup/snmpv3/usmStats_5_5.c b/agent/mibgroup/snmpv3/usmStats_5_5.c
index bcd04e1..8187ac6 100644
--- a/agent/mibgroup/snmpv3/usmStats_5_5.c
+++ b/agent/mibgroup/snmpv3/usmStats_5_5.c
@@ -1,5 +1,14 @@
 /*
  * usmStats.c: implements the usmStats portion of the SNMP-USER-BASED-SM-MIB
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -31,13 +40,18 @@ init_usmStats_5_5(void)
         netsnmp_create_handler_registration(
             "usmStats", NULL, usmStats, OID_LENGTH(usmStats),
             HANDLER_CAN_RONLY);
-    if (s &&
-	NETSNMP_REGISTER_STATISTIC_HANDLER(s, 1, USM) == MIB_REGISTERED_OK) {
-        REGISTER_SYSOR_ENTRY(usmMIBCompliance,
-                             "The management information definitions for the "
-                             "SNMP User-based Security Model.");
-        usmStats_reg = s;
+    if (!s)
+        return;
+
+    if (NETSNMP_REGISTER_STATISTIC_HANDLER(s, 1, USM) != MIB_REGISTERED_OK) {
+        netsnmp_handler_registration_free(s);
+        return;
     }
+
+    REGISTER_SYSOR_ENTRY(usmMIBCompliance,
+                         "The management information definitions for the "
+                         "SNMP User-based Security Model.");
+    usmStats_reg = s;
 }
 
 void
diff --git a/agent/mibgroup/snmpv3/usmUser.c b/agent/mibgroup/snmpv3/usmUser.c
index 9f0503d..101b8cc 100644
--- a/agent/mibgroup/snmpv3/usmUser.c
+++ b/agent/mibgroup/snmpv3/usmUser.c
@@ -1,5 +1,14 @@
 /*
  * usmUser.c
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -61,7 +70,9 @@ oid             usmUser_variables_oid[] = { 1, 3, 6, 1, 6, 3, 15, 1, 2 };
  */
 #define USM_MIB_LENGTH 12
 
+#ifndef NETSNMP_NO_WRITE_SUPPORT
 static unsigned int usmUserSpinLock = 0;
+#endif
 
 void
 init_usmUser(void)
@@ -305,8 +316,10 @@ var_usmUser(struct variable * vp,
      * variables we may use later 
      */
     static long     long_ret;
+#ifndef NETSNMP_NO_WRITE_SUPPORT
     static u_char   string[1];
     static oid      objid[2];   /* for .0.0 */
+#endif
 
     if (!vp || !name || !length || !var_len)
         return NULL;
diff --git a/agent/mibgroup/tcp-mib/data_access/tcpConn_common.c b/agent/mibgroup/tcp-mib/data_access/tcpConn_common.c
index bba01fe..19b6680 100644
--- a/agent/mibgroup/tcp-mib/data_access/tcpConn_common.c
+++ b/agent/mibgroup/tcp-mib/data_access/tcpConn_common.c
@@ -21,26 +21,6 @@ static void _access_tcpconn_entry_release(netsnmp_tcpconn_entry * entry,
 
 /**---------------------------------------------------------------------*/
 /*
- * external per-architecture functions prototypes
- *
- * These shouldn't be called by the general public, so they aren't in
- * the header file.
- */
-extern int
-netsnmp_arch_tcpconn_container_load(netsnmp_container* container,
-                                      u_int load_flags);
-extern int
-netsnmp_arch_tcpconn_entry_init(netsnmp_tcpconn_entry *entry);
-extern int
-netsnmp_arch_tcpconn_entry_copy(netsnmp_tcpconn_entry *lhs,
-                                  netsnmp_tcpconn_entry *rhs);
-extern void
-netsnmp_arch_tcpconn_entry_cleanup(netsnmp_tcpconn_entry *entry);
-
-
-
-/**---------------------------------------------------------------------*/
-/*
  * container functions
  */
 /**
diff --git a/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c b/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c
index fed1e84..532499b 100644
--- a/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c
+++ b/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c
@@ -181,7 +181,11 @@ _load(netsnmp_container *container, u_int load_flags)
 	}
 
 #if !defined(NETSNMP_ENABLE_IPV6)
+#ifdef INP_ISIPV6
+	if (INP_ISIPV6(&pcb.xt_inp))
+#else
 	if (pcb.xt_inp.inp_vflag & INP_IPV6)
+#endif
 	    continue;
 #endif
 
@@ -198,7 +202,11 @@ _load(netsnmp_container *container, u_int load_flags)
         entry->pid = 0;
         
         /** the addr string may need work */
+#ifdef INP_ISIPV6
+	if (INP_ISIPV6(&pcb.xt_inp)) {
+#else
 	if (pcb.xt_inp.inp_vflag & INP_IPV6) {
+#endif
 	    entry->loc_addr_len = entry->rmt_addr_len = 16;
 	    memcpy(entry->loc_addr, &pcb.xt_inp.in6p_laddr, 16);
 	    memcpy(entry->rmt_addr, &pcb.xt_inp.in6p_faddr, 16);
@@ -216,6 +224,8 @@ _load(netsnmp_container *container, u_int load_flags)
         CONTAINER_INSERT(container, entry);
     }
 
+    free(tcpcb_buf);
+
     if(rc<0)
         return rc;
 
diff --git a/agent/mibgroup/tcp-mib/data_access/tcpConn_linux.c b/agent/mibgroup/tcp-mib/data_access/tcpConn_linux.c
index 5f93be0..42121bb 100644
--- a/agent/mibgroup/tcp-mib/data_access/tcpConn_linux.c
+++ b/agent/mibgroup/tcp-mib/data_access/tcpConn_linux.c
@@ -121,6 +121,8 @@ _load4(netsnmp_container *container, u_int load_flags)
     int             rc = 0;
     FILE           *in;
     char            line[160];
+    enum            { rbufsize = 65536 };
+    void           *rbuf = alloca(rbufsize);
     
     netsnmp_assert(NULL != container);
 
@@ -130,6 +132,7 @@ _load4(netsnmp_container *container, u_int load_flags)
         return -2;
     }
     
+    setvbuf(in, rbuf, _IOFBF, rbufsize);
     fgets(line, sizeof(line), in); /* skip header */
 
     /*
@@ -262,6 +265,8 @@ _load6(netsnmp_container *container, u_int load_flags)
     int             rc = 0;
     FILE           *in;
     char            line[360];
+    enum            { rbufsize = 65536 };
+    void           *rbuf = alloca(rbufsize);
 
     netsnmp_assert(NULL != container);
 
@@ -272,6 +277,7 @@ _load6(netsnmp_container *container, u_int load_flags)
         return -2;
     }
 
+    setvbuf(in, rbuf, _IOFBF, rbufsize);
     fgets(line, sizeof(line), in); /* skip header */
 
     /*
diff --git a/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c b/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c
index 001064f..f297ecb 100644
--- a/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c
+++ b/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c
@@ -26,7 +26,25 @@
 #include <netinet/tcp_var.h>
 #endif
 
+#if HAVE_KVM_GETFILES
+#if defined(HAVE_KVM_GETFILE2) || !defined(openbsd5)
+#undef HAVE_KVM_GETFILES
+#endif
+#endif
+
+#if HAVE_KVM_GETFILES
+#include <kvm.h>
+#include <sys/sysctl.h>
+#define _KERNEL /* for DTYPE_SOCKET */
+#include <sys/file.h>
+#undef _KERNEL
+#endif
+
+#ifdef HAVE_KVM_GETFILES
+static int _kvmload(netsnmp_container *container, u_int flags);
+#else
 static int _load(netsnmp_container *container, u_int flags);
+#endif
 
 /*
  * initialize arch specific storage
@@ -96,11 +114,100 @@ netsnmp_arch_tcpconn_container_load(netsnmp_container *container,
         return -1;
     }
 
+#ifdef HAVE_KVM_GETFILES
+    rc = _kvmload(container, load_flags);
+#else
     rc = _load(container, load_flags);
+#endif
 
     return rc;
 }
 
+#ifdef HAVE_KVM_GETFILES
+/**
+ *
+ * @retval  0 no errors
+ * @retval !0 errors
+ */
+static int
+_kvmload(netsnmp_container *container, u_int load_flags)
+{
+    int      StateMap[] = { 1, 2, 3, 4, 5, 8, 6, 10, 9, 7, 11 };
+    netsnmp_tcpconn_entry  *entry;
+    struct   kinfo_file *kf;
+    int      count;
+    int      state;
+    int      rc = 0;
+
+    kf = kvm_getfiles(kd, KERN_FILE_BYFILE, DTYPE_SOCKET, sizeof(struct kinfo_file), &count);
+
+    while (count--) {
+	if (kf->so_protocol != IPPROTO_TCP)
+	    goto skip;
+
+	state = StateMap[kf->t_state];
+
+	if (load_flags) {
+	    if (state == TCPCONNECTIONSTATE_LISTEN) {
+		if (load_flags & NETSNMP_ACCESS_TCPCONN_LOAD_NOLISTEN) {
+		    DEBUGMSGT(("verbose:access:tcpconn:container",
+			       " skipping listen\n"));
+		    goto skip;
+		}
+	    }
+	    else if (load_flags & NETSNMP_ACCESS_TCPCONN_LOAD_ONLYLISTEN) {
+		DEBUGMSGT(("verbose:access:tcpconn:container",
+			    " skipping non-listen\n"));
+		goto skip;
+	    }
+	}
+
+#if !defined(NETSNMP_ENABLE_IPV6)
+        if (kf->so_family == AF_INET6)
+	    goto skip;
+#endif
+
+        entry = netsnmp_access_tcpconn_entry_create();
+        if(NULL == entry) {
+            rc = -3;
+            break;
+        }
+
+        /** oddly enough, these appear to already be in network order */
+        entry->loc_port = ntohs(kf->inp_lport);
+        entry->rmt_port = ntohs(kf->inp_fport);
+        entry->tcpConnState = StateMap[kf->t_state];
+        entry->pid = kf->p_pid;
+        
+        /** the addr string may need work */
+	if (kf->so_family == AF_INET6) {
+	    entry->loc_addr_len = entry->rmt_addr_len = 16;
+	    memcpy(entry->loc_addr, &kf->inp_laddru, 16);
+	    memcpy(entry->rmt_addr, &kf->inp_faddru, 16);
+	}
+	else {
+	    entry->loc_addr_len = entry->rmt_addr_len = 4;
+	    memcpy(entry->loc_addr, &kf->inp_laddru, 4);
+	    memcpy(entry->rmt_addr, &kf->inp_faddru, 4);
+	}
+	DEBUGMSGTL(("tcp-mib/data_access", "tcp %d %d %d\n",
+	    entry->loc_addr_len, entry->loc_port, entry->rmt_port));
+
+        /*
+         * add entry to container
+         */
+        entry->arbitrary_index = CONTAINER_SIZE(container) + 1;
+        CONTAINER_INSERT(container, entry);
+skip:
+	kf++;
+    }
+
+    if (rc < 0)
+    return rc;
+    return 0;
+}
+
+#else /* HAVE_KVM_GETFILES */
 
 /**
  *
@@ -209,3 +316,4 @@ skip:
 
     return 0;
 }
+#endif /* HAVE_KVM_GETFILES */
diff --git a/agent/mibgroup/tcp-mib/tcpConnectionTable/tcpConnectionTable_interface.c b/agent/mibgroup/tcp-mib/tcpConnectionTable/tcpConnectionTable_interface.c
index d0b27e5..ffdca8e 100644
--- a/agent/mibgroup/tcp-mib/tcpConnectionTable/tcpConnectionTable_interface.c
+++ b/agent/mibgroup/tcp-mib/tcpConnectionTable/tcpConnectionTable_interface.c
@@ -291,10 +291,12 @@ _tcpConnectionTable_initialize_interface(tcpConnectionTable_registration *
         netsnmp_handler_registration_create("tcpConnectionTable", handler,
                                             tcpConnectionTable_oid,
                                             tcpConnectionTable_oid_size,
-                                            HANDLER_CAN_BABY_STEP
+                                            HANDLER_CAN_BABY_STEP |
 #if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
-                                          | HANDLER_CAN_RWRITE
-#endif
+                                            HANDLER_CAN_RWRITE
+#else
+                                            HANDLER_CAN_RONLY
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT  */
                                           );
     if (NULL == reginfo) {
         snmp_log(LOG_ERR, "error registering table tcpConnectionTable\n");
diff --git a/agent/mibgroup/testhandler.c b/agent/mibgroup/testhandler.c
index f7468f0..7b7836e 100644
--- a/agent/mibgroup/testhandler.c
+++ b/agent/mibgroup/testhandler.c
@@ -29,7 +29,6 @@ static oid      my_test_oid[4] = { 1, 2, 3, 4 };
 static oid      my_table_oid[4] = { 1, 2, 3, 5 };
 static oid      my_instance_oid[5] = { 1, 2, 3, 6, 1 };
 static oid      my_data_table_oid[4] = { 1, 2, 3, 7 };
-static oid      my_data_table_set_oid[4] = { 1, 2, 3, 8 };
 static oid      my_data_ulong_instance[4] = { 1, 2, 3, 9 };
 
 u_long          my_ulong = 0;
@@ -44,7 +43,6 @@ init_testhandler(void)
     netsnmp_table_registration_info *table_info;
     u_long          ind1;
     netsnmp_table_data *table;
-    netsnmp_table_data_set *table_set;
     netsnmp_table_row *row;
 
     DEBUGMSGTL(("testhandler", "initializing\n"));
@@ -112,7 +110,7 @@ init_testhandler(void)
     netsnmp_table_row_add_index(row, ASN_INTEGER, &ind1, sizeof(ind1));
     netsnmp_table_row_add_index(row, ASN_OCTET_STR, "partridge",
                                 strlen("partridge"));
-    row->data = (void *) "pear tree";
+    row->data = NETSNMP_REMOVE_CONST(void *, "pear tree");
     netsnmp_table_data_add_row(table, row);
 
     /*
@@ -123,7 +121,7 @@ init_testhandler(void)
     netsnmp_table_row_add_index(row, ASN_INTEGER, &ind1, sizeof(ind1));
     netsnmp_table_row_add_index(row, ASN_OCTET_STR, "turtle",
                                 strlen("turtle"));
-    row->data = (void *) "doves";
+    row->data = NETSNMP_REMOVE_CONST(void *, "doves");
     netsnmp_table_data_add_row(table, row);
 
     /*
@@ -253,7 +251,7 @@ my_test_table_handler(netsnmp_mib_handler *handler,
                 /*
                  * or no index specified 
                  */
-                table_info->indexes->val.integer == 0) {
+                table_info->indexes->val.integer == NULL) {
                 table_info->colnum = RESULT_COLUMN;
                 x = 0;
                 y = 0;
@@ -363,7 +361,7 @@ my_test_instance_handler(netsnmp_mib_handler *handler,
          * update current 
          */
         accesses = *(requests->requestvb->val.integer);
-        DEBUGMSGTL(("testhandler", "updated accesses -> %d\n", accesses));
+        DEBUGMSGTL(("testhandler", "updated accesses -> %lu\n", accesses));
         break;
 
     case MODE_SET_UNDO:
@@ -406,17 +404,16 @@ my_data_table_handler(netsnmp_mib_handler *handler,
          */
         row = netsnmp_extract_table_row(requests);
         table_info = netsnmp_extract_table_info(requests);
-        if (row)
-            column3 = (char *) row->data;
-        if (!row || !table_info || !column3)
+        if (!table_info || !row || !row->data)
             continue;
+        column3 = (char *) row->data;
 
         /*
          * there's only one column, we don't need to check if it's right 
          */
         netsnmp_table_data_build_result(reginfo, reqinfo, requests, row,
                                         table_info->colnum,
-                                        ASN_OCTET_STR, column3,
+                                        ASN_OCTET_STR, (u_char*)column3,
                                         strlen(column3));
         requests = requests->next;
     }
diff --git a/agent/mibgroup/tlstm-mib/snmpTlstmAddrTable/snmpTlstmAddrTable.c b/agent/mibgroup/tlstm-mib/snmpTlstmAddrTable/snmpTlstmAddrTable.c
index 5493ff9..6989d279 100644
--- a/agent/mibgroup/tlstm-mib/snmpTlstmAddrTable/snmpTlstmAddrTable.c
+++ b/agent/mibgroup/tlstm-mib/snmpTlstmAddrTable/snmpTlstmAddrTable.c
@@ -88,12 +88,6 @@ typedef struct tlstmAddrTable_entry_s {
 
 } tlstmAddrTable_entry;
 
-netsnmp_tdata_row *tlstmAddrTable_createEntry(netsnmp_tdata * table_data,
-                                              char *snmpTargetAddrName,
-                                              size_t snmpTargetAddrName_len);
-void tlstmAddrTable_removeEntry(netsnmp_tdata * table_data,
-                                netsnmp_tdata_row * row);
-
 static Netsnmp_Node_Handler tlstmAddrTable_handler;
 static int _cache_load(netsnmp_cache *cache, netsnmp_tdata *table);
 static void _cache_free(netsnmp_cache *cache, netsnmp_tdata *table);
diff --git a/agent/mibgroup/tlstm-mib/snmpTlstmCertToTSNTable/snmpTlstmCertToTSNTable.c b/agent/mibgroup/tlstm-mib/snmpTlstmCertToTSNTable/snmpTlstmCertToTSNTable.c
index 84d1afb..6299a7d 100644
--- a/agent/mibgroup/tlstm-mib/snmpTlstmCertToTSNTable/snmpTlstmCertToTSNTable.c
+++ b/agent/mibgroup/tlstm-mib/snmpTlstmCertToTSNTable/snmpTlstmCertToTSNTable.c
@@ -33,9 +33,6 @@ netsnmp_feature_require(table_tdata_insert_row)
 
 #define MAP_MIB_CONFIG_TOKEN "snmpTlstmCertToTSNEntry"
 
-extern netsnmp_cert_map *netsnmp_certToTSN_parse_common(char **line);
-
-
     /*
      * structure for undo storage and other vars for set processing 
      */
diff --git a/agent/mibgroup/tunnel/tunnel.c b/agent/mibgroup/tunnel/tunnel.c
index f9649ef..a3c34c6 100644
--- a/agent/mibgroup/tunnel/tunnel.c
+++ b/agent/mibgroup/tunnel/tunnel.c
@@ -78,13 +78,6 @@
 #ifdef USING_IF_MIB_IFTABLE_IFTABLE_MODULE
 #include "if-mib/ifTable/ifTable.h"
 #include "if-mib/ifTable/ifTable_defs.h"
-#else
-/*
- * This is used, because the TUNNEL-MIB augments ifTable. 
- */
-extern unsigned char *var_ifEntry(struct variable *,
-                                  oid *, size_t *,
-                                  int, size_t *, WriteMethod **);
 #endif
 
 
@@ -98,10 +91,6 @@ oid             tunnel_variables_oid[] =
     { 1, 3, 6, 1, 2, 1, 10, 131, 1, 1 };
 const int       tunnel_len = 10;
 
-oid             tunnel_ifEntry_oid[] =
-    { 1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 1, 1 };
-const int       tunnel_ifEntry_len = 12;
-
 oid             tunnel_configEntry_oid[] =
     { 1, 3, 6, 1, 2, 1, 10, 131, 1, 1, 2, 1 };
 const int       tunnel_configEntry_len = 12;
@@ -291,7 +280,7 @@ getTunnelParm(char *ifname)
     }
 
     memset(&parm, 0, sizeof(struct ip_tunnel_parm));
-    strcpy(ifrq.ifr_name, ifname);
+    strlcpy(ifrq.ifr_name, ifname, sizeof(ifrq.ifr_name));
     ifrq.ifr_ifru.ifru_data = (void *) &parm;
     if (ioctl(fd, SIOCGETTUNNEL, &ifrq) < 0) {
         /*
@@ -324,7 +313,7 @@ setTunnelParm(char *ifname, struct ip_tunnel_parm *parm)
         return -1;
     }
 
-    strcpy(ifrq.ifr_name, ifname);
+    strlcpy(ifrq.ifr_name, ifname, sizeof(ifrq.ifr_name));
     ifrq.ifr_ifru.ifru_data = (void *) parm;
     err = ioctl(fd, SIOCCHGTUNNEL, &ifrq);
     close(fd);
@@ -371,7 +360,7 @@ updateTunnel(struct tunnel *tunnel)
          * 4 bytes of sa_data. We don't use sa_data here, or we'd
          * need to memset it to 0 before the ioct.
          */
-        strcpy(ifrq.ifr_name, tunnel->ifname);
+        strlcpy(ifrq.ifr_name, tunnel->ifname, sizeof(ifrq.ifr_name));
         if (ioctl(fd, SIOCGIFHWADDR, &ifrq) == 0)
             switch (ifrq.ifr_hwaddr.sa_family) {
             case ARPHRD_TUNNEL:
@@ -897,7 +886,7 @@ var_tunnelIfEntry(struct variable *vp,
         *write_method = writeTOS;
         return (u_char *) & ret_int;
     default:
-        return 0;
+        return NULL;
     }
 
     return NULL;
@@ -994,7 +983,7 @@ var_tunnelConfigEntry(struct variable *vp,
         vp->type = ASN_INTEGER;
         return (u_char *) & ret_int;
     default:
-        return 0;
+        return NULL;
     }
 
     return NULL;
diff --git a/agent/mibgroup/ucd-snmp/disk_hw.c b/agent/mibgroup/ucd-snmp/disk_hw.c
index ea37610..3d05bf7 100644
--- a/agent/mibgroup/ucd-snmp/disk_hw.c
+++ b/agent/mibgroup/ucd-snmp/disk_hw.c
@@ -34,6 +34,7 @@
 
 #include "struct.h"
 #include "disk.h"
+#include "disk_hw.h"
 #include "util_funcs/header_simple_table.h"
 #if USING_UCD_SNMP_ERRORMIB_MODULE
 #include "errormib.h"
diff --git a/agent/mibgroup/ucd-snmp/diskio.c b/agent/mibgroup/ucd-snmp/diskio.c
index 4ea8987..2a47785 100644
--- a/agent/mibgroup/ucd-snmp/diskio.c
+++ b/agent/mibgroup/ucd-snmp/diskio.c
@@ -120,8 +120,6 @@ static int      getstats(void);
 void		devla_getstats(unsigned int regno, void *dummy);
 #endif
 
-FILE           *file;
-
 #ifdef linux
 static int	diskio_free_config(int, int, void *, void *);
 #endif
@@ -184,6 +182,8 @@ init_diskio(void)
          var_diskio, 1, {12}},
         {DISKIO_NWRITTENX, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
          var_diskio, 1, {13}},
+        {DISKIO_BUSYTIME, ASN_COUNTER64, NETSNMP_OLDAPI_RONLY,
+         var_diskio, 1, {14}},
     };
 
     /*
@@ -566,6 +566,7 @@ var_diskio(struct variable * vp,
            int exact, size_t * var_len, WriteMethod ** write_method)
 {
     static long     long_ret;
+    static long long        longlong_ret;
     static struct counter64 c64_ret;
     unsigned int    indx;
 
@@ -609,7 +610,12 @@ var_diskio(struct variable * vp,
         c64_ret.low = dk[indx].ds_rbytes & 0xffffffff;
         c64_ret.high = dk[indx].ds_rbytes >> 32;
         return (u_char *) & c64_ret;
-
+    case DISKIO_BUSYTIME:
+        *var_len = sizeof(struct counter64);
+	longlong_ret = dk[indx].ds_time.tv_sec*1000000 + dk[indx].ds_time.tv_usec;
+        c64_ret.low = longlong_ret & 0xffffffff;
+        c64_ret.high = longlong_ret >> 32;
+	return (u_char *) &c64_ret;
     default:
         ERROR_MSG("diskio.c: don't know how to handle this request.");
     }
@@ -699,6 +705,8 @@ var_diskio(struct variable * vp,
            int exact, size_t * var_len, WriteMethod ** write_method)
 {
     static long     long_ret;
+    static long long        longlong_ret;
+    static struct counter64 c64_ret;
     unsigned int    indx;
 
     if (getstats() == 0)
@@ -741,6 +749,20 @@ var_diskio(struct variable * vp,
 #endif
         return (u_char *) & long_ret;
 
+    case DISKIO_NREADX:
+        *var_len = sizeof(struct counter64);
+        longlong_ret = dk[indx].rbytes;
+        c64_ret.low = longlong_ret & 0xffffffff;
+        c64_ret.high = longlong_ret >> 32;
+        return (u_char *) & c64_ret;
+
+    case DISKIO_NWRITTENX:
+        *var_len = sizeof(struct counter64);
+        longlong_ret = dk[indx].wbytes;
+        c64_ret.low = longlong_ret & 0xffffffff;
+        c64_ret.high = longlong_ret >> 32;
+        return (u_char *) & c64_ret;
+
     case DISKIO_READS:
 #ifdef HW_DISKSTATS
      	long_ret = dk[indx].dk_rxfer;
@@ -761,6 +783,21 @@ var_diskio(struct variable * vp,
 #endif
         return (u_char *) & long_ret;
 
+    case DISKIO_BUSYTIME:
+#ifdef HW_IOSTATS
+        *var_len = sizeof(struct counter64);
+	if (dk[indx].type == IOSTAT_DISK) {
+	    longlong_ret = dk[indx].time_sec*1000 + dk[indx].time_usec/1000;
+	    c64_ret.low = longlong_ret & 0xffffffff;
+	    c64_ret.high = longlong_ret >> 32;
+	    return (u_char *) & c64_ret;
+	}
+	else
+	    return NULL;
+#else
+	return NULL;
+#endif
+
     default:
         ERROR_MSG("diskio.c: don't know how to handle this request.");
     }
@@ -944,14 +981,14 @@ var_diskio(struct variable * vp,
         return (u_char *) stat->dinfo->devices[indx].device_name;
     case DISKIO_NREAD:
 #if HAVE_DEVSTAT_GETDEVS
-        long_ret = (signed long) stat->dinfo->devices[indx].bytes[DEVSTAT_READ];
+        long_ret = (signed long) stat->dinfo->devices[indx].bytes[DEVSTAT_READ] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].bytes_read;
 #endif
         return (u_char *) & long_ret;
     case DISKIO_NWRITTEN:
 #if HAVE_DEVSTAT_GETDEVS
-        long_ret = (signed long) stat->dinfo->devices[indx].bytes[DEVSTAT_WRITE];
+        long_ret = (signed long) stat->dinfo->devices[indx].bytes[DEVSTAT_WRITE] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].bytes_written;
 #endif
@@ -978,14 +1015,14 @@ var_diskio(struct variable * vp,
         return (u_char *) & c64_ret;
     case DISKIO_READS:
 #if HAVE_DEVSTAT_GETDEVS
-        long_ret = (signed long) stat->dinfo->devices[indx].operations[DEVSTAT_READ];
+        long_ret = (signed long) stat->dinfo->devices[indx].operations[DEVSTAT_READ] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].num_reads;
 #endif
         return (u_char *) & long_ret;
     case DISKIO_WRITES:
 #if HAVE_DEVSTAT_GETDEVS
-        long_ret = (signed long) stat->dinfo->devices[indx].operations[DEVSTAT_WRITE];
+        long_ret = (signed long) stat->dinfo->devices[indx].operations[DEVSTAT_WRITE] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].num_writes;
 #endif
@@ -1185,7 +1222,7 @@ getstats(void)
 	    }
 	    pTemp = &head.indices[head.length];
 
-	    rc = fscanf (parts, "%d %d %lu %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
+	    rc = fscanf(parts, "%d %d %lu %255s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
 		    &pTemp->major, &pTemp->minor, &pTemp->blocks, pTemp->name,
 		    &pTemp->rio, &pTemp->rmerge, &pTemp->rsect, &pTemp->ruse,
 		    &pTemp->wio, &pTemp->wmerge, &pTemp->wsect, &pTemp->wuse,
@@ -1259,6 +1296,11 @@ var_diskio(struct variable * vp,
     case DISKIO_LA15:
       long_ret = la_head.indices[indx].la15;
       return (u_char *) & long_ret;
+    case DISKIO_BUSYTIME:
+      *var_len = sizeof(struct counter64);
+      c64_ret.low = head.indices[indx].use*1000 & 0xffffffff;
+      c64_ret.high = head.indices[indx].use*1000 >> 32;
+      return (u_char *) & c64_ret;
     case DISKIO_NREADX:
       *var_len = sizeof(struct counter64);
       c64_ret.low = head.indices[indx].rsect * 512 & 0xffffffff;
diff --git a/agent/mibgroup/ucd-snmp/diskio.h b/agent/mibgroup/ucd-snmp/diskio.h
index 8cd206b..75b8193 100644
--- a/agent/mibgroup/ucd-snmp/diskio.h
+++ b/agent/mibgroup/ucd-snmp/diskio.h
@@ -34,5 +34,6 @@ config_add_mib(UCD-DISKIO-MIB)
 #define DISKIO_LA15             11
 #define DISKIO_NREADX           12
 #define DISKIO_NWRITTENX        13
+#define DISKIO_BUSYTIME		14
 
 #endif                          /* _MIBGROUP_DISKIO_H */
diff --git a/agent/mibgroup/ucd-snmp/dlmod.c b/agent/mibgroup/ucd-snmp/dlmod.c
index 0b711fb..34b615b 100644
--- a/agent/mibgroup/ucd-snmp/dlmod.c
+++ b/agent/mibgroup/ucd-snmp/dlmod.c
@@ -380,7 +380,7 @@ header_dlmod(struct variable *vp,
 
     memcpy(name, newname, (vp->namelen + 1) * sizeof(oid));
     *length = vp->namelen + 1;
-    *write_method = 0;
+    *write_method = NULL;
     *var_len = sizeof(long);    /* default to 'long' results */
     return MATCH_SUCCEEDED;
 }
@@ -397,7 +397,7 @@ var_dlmod(struct variable * vp,
      * variables we may use later
      */
 
-    *write_method = 0;         /* assume it isn't writable for the time being */
+    *write_method = NULL;      /* assume it isn't writable for the time being */
     *var_len = sizeof(int);    /* assume an integer and change later if not */
 
     if (header_dlmod(vp, name, length, exact,
@@ -556,7 +556,7 @@ header_dlmodEntry(struct variable *vp,
     unsigned int    dlmod_index;
 
     memcpy(newname, vp->name, vp->namelen * sizeof(oid));
-    *write_method = 0;
+    *write_method = NULL;
 
     for (dlmod_index = 1; dlmod_index < dlmod_next_index; dlmod_index++) {
         dlm = dlmod_get_by_index(dlmod_index);
diff --git a/agent/mibgroup/ucd-snmp/extensible.c b/agent/mibgroup/ucd-snmp/extensible.c
index 14b084a..a567ab1 100644
--- a/agent/mibgroup/ucd-snmp/extensible.c
+++ b/agent/mibgroup/ucd-snmp/extensible.c
@@ -106,6 +106,7 @@
 
 #include "struct.h"
 #include "extensible.h"
+#include "pass.h"
 #include "mibgroup/util_funcs.h"
 #include "utilities/execute.h"
 #include "util_funcs/header_simple_table.h"
@@ -113,18 +114,6 @@
 netsnmp_feature_require(get_exten_instance)
 netsnmp_feature_require(parse_miboid)
 
-extern struct myproc *procwatch;        /* moved to proc.c */
-extern int      numprocs;       /* ditto */
-extern struct extensible *extens;       /* In exec.c */
-extern struct extensible *relocs;       /* In exec.c */
-extern int      numextens;      /* ditto */
-extern int      numrelocs;      /* ditto */
-extern struct extensible *passthrus;    /* In pass.c */
-extern int      numpassthrus;   /* ditto */
-extern netsnmp_subtree *subtrees;
-extern struct variable2 extensible_relocatable_variables[];
-extern struct variable2 extensible_passthru_variables[];
-
 /*
  * the relocatable extensible commands variables 
  */
@@ -193,8 +182,6 @@ init_extensible(void)
                            extensible_unregister, NULL);
 }
 
-extern int pass_compare(const void *a, const void *b);
-
 void
 extensible_parse_config(const char *token, char *cptr)
 {
@@ -291,7 +278,7 @@ extensible_parse_config(const char *token, char *cptr)
         if (etmp == NULL)
             return;                 /* XXX memory alloc error */
         for (i = 0, ptmp = *pp;
-             i < scount && ptmp != 0; i++, ptmp = ptmp->next)
+             i < scount && ptmp != NULL; i++, ptmp = ptmp->next)
             etmp[i] = ptmp;
         qsort(etmp, scount, sizeof(struct extensible *),
               pass_compare);
@@ -429,7 +416,7 @@ var_extensible_shell(struct variable * vp,
                      size_t * var_len, WriteMethod ** write_method)
 {
 
-    static struct extensible *exten = 0;
+    static struct extensible *exten = NULL;
     static long     long_ret;
     int len;
 
@@ -530,7 +517,7 @@ var_extensible_relocatable(struct variable *vp,
 
     int             i;
     int             len;
-    struct extensible *exten = 0;
+    struct extensible *exten = NULL;
     static long     long_ret;
     static char     errmsg[STRMAX];
     char            *cp, *cp1;
@@ -643,7 +630,7 @@ find_extensible(netsnmp_subtree *tp, oid *tname, size_t tnamelen, int exact)
 {
     size_t          tmp;
     int             i;
-    struct extensible *exten = 0;
+    struct extensible *exten = NULL;
     struct variable myvp;
     oid             name[MAX_OID_LEN];
     static netsnmp_subtree mysubtree[2] =
diff --git a/agent/mibgroup/ucd-snmp/extensible.h b/agent/mibgroup/ucd-snmp/extensible.h
index 24bd16d..8d4afa9 100644
--- a/agent/mibgroup/ucd-snmp/extensible.h
+++ b/agent/mibgroup/ucd-snmp/extensible.h
@@ -11,6 +11,10 @@ config_require(util_funcs/header_simple_table)
 config_require(util_funcs)
 config_require(utilities/execute)
 
+     extern struct extensible *extens;
+     extern struct extensible *relocs;
+     extern int numextens, numrelocs;
+
      extern FindVarMethod var_extensible_shell;
      extern WriteMethod fixExecError;
      extern FindVarMethod var_extensible_relocatable;
diff --git a/agent/mibgroup/ucd-snmp/lmsensorsMib.c b/agent/mibgroup/ucd-snmp/lmsensorsMib.c
index 2557796..f8f80f7 100644
--- a/agent/mibgroup/ucd-snmp/lmsensorsMib.c
+++ b/agent/mibgroup/ucd-snmp/lmsensorsMib.c
@@ -7,13 +7,15 @@
 
 netsnmp_container *sensorContainer = NULL;
 
-void initialize_lmSensorsTable(const char *tableName, const oid *tableOID,
-                               netsnmp_container_op *filter, int mult );
-
-int _sensor_filter_temp( netsnmp_container *c, const void *v );
-int _sensor_filter_fan(  netsnmp_container *c, const void *v );
-int _sensor_filter_volt( netsnmp_container *c, const void *v );
-int _sensor_filter_misc( netsnmp_container *c, const void *v );
+static void initialize_lmSensorsTable(const char *tableName,
+                                      const oid *tableOID,
+                                      netsnmp_container_op *filter,
+                                      int mult);
+
+static int _sensor_filter_temp( netsnmp_container *c, const void *v );
+static int _sensor_filter_fan(  netsnmp_container *c, const void *v );
+static int _sensor_filter_volt( netsnmp_container *c, const void *v );
+static int _sensor_filter_misc( netsnmp_container *c, const void *v );
 
 static const oid lmTempSensorsTable_oid[]   = {1,3,6,1,4,1,2021,13,16,2};
 static const oid lmFanSensorsTable_oid[]    = {1,3,6,1,4,1,2021,13,16,3};
diff --git a/agent/mibgroup/ucd-snmp/logmatch.c b/agent/mibgroup/ucd-snmp/logmatch.c
index 83b4e4a..fa35805 100644
--- a/agent/mibgroup/ucd-snmp/logmatch.c
+++ b/agent/mibgroup/ucd-snmp/logmatch.c
@@ -157,7 +157,7 @@ updateLogmatch(int iindex)
 
             pos = counter = ccounter = 0;
 
-            if (fscanf(perfile, "%lu %lu %lu %s",
+            if (fscanf(perfile, "%lu %lu %lu %255s",
                        &pos, &ccounter, &counter, lastFilename)) {
 
 
diff --git a/agent/mibgroup/ucd-snmp/memory.c b/agent/mibgroup/ucd-snmp/memory.c
index 742186f..371a77e 100644
--- a/agent/mibgroup/ucd-snmp/memory.c
+++ b/agent/mibgroup/ucd-snmp/memory.c
@@ -26,7 +26,7 @@ init_memory(void)
         netsnmp_create_handler_registration("memory", handle_memory,
                                  memory_oid, OID_LENGTH(memory_oid),
                                              HANDLER_CAN_RONLY),
-                                 1, 17);
+                                 1, 26);
     netsnmp_register_scalar(
         netsnmp_create_handler_registration("memSwapError", handle_memory,
                            memSwapError_oid, OID_LENGTH(memSwapError_oid),
@@ -59,7 +59,9 @@ handle_memory(netsnmp_mib_handler *handler,
                 netsnmp_request_info *requests)
 {
     netsnmp_memory_info *mem_info;
-    int val;
+    unsigned long long val;
+    struct counter64 c64;
+    int type = ASN_INTEGER;
     char buf[1024];
 
     /*
@@ -184,6 +186,92 @@ handle_memory(netsnmp_mib_handler *handler,
             val  = (mem_info->size - mem_info->free);      /* cached */
             val *= (mem_info->units/1024);
             break;
+	case MEMORY_SWAP_TOTAL_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_SWAP, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->size;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_SWAP_AVAIL_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_SWAP, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->free;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_REAL_TOTAL_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_PHYSMEM, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->size;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_REAL_AVAIL_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_PHYSMEM, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->free;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_SWAP_MIN_X:
+	    type = ASN_COUNTER64;
+	    val = minimum_swap;
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_FREE_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_VIRTMEM, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->free;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_SHARED_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_SHARED, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->size;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_BUFFER_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_MBUF, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->size - mem_info->free;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
+	case MEMORY_CACHED_X:
+	    type = ASN_COUNTER64;
+            mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_CACHED, 0 );
+            if (!mem_info)
+               goto NOSUCH;
+            val  = mem_info->size - mem_info->free;
+            val *= (mem_info->units/1024);
+	    c64.low = val & 0xFFFFFFFF;
+	    c64.high = val >>32;
+            break;
         case MEMORY_SWAP_ERROR:
             mem_info = netsnmp_memory_get_byIdx( NETSNMP_MEM_TYPE_SWAP, 0 );
             if (!mem_info)
@@ -213,8 +301,12 @@ NOSUCH:
          * All non-integer objects (and errors) have already been
          * processed.  So return the integer value.
          */
-        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
-                                 (u_char *)&val, sizeof(val));
+	if (type == ASN_INTEGER)
+	    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+				     (u_char *)&val, sizeof(val));
+	else
+	    snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER64,
+				     (u_char *)&c64, sizeof(c64));
         break;
 
     default:
diff --git a/agent/mibgroup/ucd-snmp/memory.h b/agent/mibgroup/ucd-snmp/memory.h
index a44d82e..ded2140 100644
--- a/agent/mibgroup/ucd-snmp/memory.h
+++ b/agent/mibgroup/ucd-snmp/memory.h
@@ -32,6 +32,15 @@ Netsnmp_Node_Handler handle_memory;
 #define MEMORY_CACHED       15
 #define MEMORY_STXT_USED    16
 #define MEMORY_RTXT_USED    17
+#define MEMORY_SWAP_TOTAL_X 18
+#define MEMORY_SWAP_AVAIL_X 19
+#define MEMORY_REAL_TOTAL_X 20
+#define MEMORY_REAL_AVAIL_X 21
+#define MEMORY_FREE_X       22
+#define MEMORY_SWAP_MIN_X   23
+#define MEMORY_SHARED_X     24
+#define MEMORY_BUFFER_X     25
+#define MEMORY_CACHED_X     26
 #define MEMORY_SWAP_ERROR  100
 #define MEMORY_SWAP_ERRMSG 101
 #endif                          /* MEMORY_H */
diff --git a/agent/mibgroup/ucd-snmp/pass_common.c b/agent/mibgroup/ucd-snmp/pass_common.c
index e3d9a01..71e0450 100644
--- a/agent/mibgroup/ucd-snmp/pass_common.c
+++ b/agent/mibgroup/ucd-snmp/pass_common.c
@@ -135,7 +135,7 @@ netsnmp_internal_pass_parse(char * buf,
         c64.high = (unsigned long)(v64 >> 32);
         c64.low  = (unsigned long)(v64 & 0xffffffff);
         *var_len = sizeof(c64);
-        vp->type = ASN_INTEGER64;
+        vp->type = ASN_OPAQUE_I64;
         return ((unsigned char *) &c64);
     }
 #endif
diff --git a/agent/mibgroup/ucd-snmp/proxy.c b/agent/mibgroup/ucd-snmp/proxy.c
index 017fd5c..0e170b3 100644
--- a/agent/mibgroup/ucd-snmp/proxy.c
+++ b/agent/mibgroup/ucd-snmp/proxy.c
@@ -29,8 +29,6 @@ netsnmp_feature_require(request_set_error_idx)
 
 static struct simple_proxy *proxies = NULL;
 
-oid             testoid[] = { 1, 3, 6, 1, 4, 1, 2021, 8888, 1 };
-
 /*
  * this must be standardized somewhere, right? 
  */
@@ -80,24 +78,48 @@ proxy_parse_config(const char *token, char *line)
 
     netsnmp_session session, *ss;
     struct simple_proxy *newp, **listpp;
-    char            args[MAX_ARGS][SPRINT_MAX_LEN], *argv[MAX_ARGS];
+    char           *argv[MAX_ARGS];
     int             argn, arg;
     char           *cp;
+    char           *buff;
     netsnmp_handler_registration *reg;
 
     context_string = NULL;
 
     DEBUGMSGTL(("proxy_config", "entering\n"));
 
+    /* Put the first string into the array */
+    argv[0] = strdup("snmpd-proxy");
+    if (!argv[0]) {
+        config_perror("could not allocate memory for argv[0]");
+        return;
+    }
     /*
      * create the argv[] like array 
      */
-    strcpy(argv[0] = args[0], "snmpd-proxy");   /* bogus entry for getopt() */
+    /* Allocates memory to store the parameters value */     
+    buff = (char *) malloc (strlen(line)+1);
+    if (!buff) {
+        config_perror("could not allocate memory for buff");
+         /* Free the memory allocated */
+        SNMP_FREE(argv[0]);
+        return;
+    }
+
     for (argn = 1, cp = line; cp && argn < MAX_ARGS;) {
-	argv[argn] = args[argn];
-        cp = copy_nword(cp, argv[argn], SPRINT_MAX_LEN);
+        /* Copy a parameter into the buff */
+        cp = copy_nword(cp, buff, strlen(cp)+1);
+        argv[argn] = strdup(buff);
+        if (!argv[argn]) {
+            config_perror("could not allocate memory for argv[n]");
+            while(argn--)
+                SNMP_FREE(argv[argn]);
+            SNMP_FREE(buff);
+            return;
+        }
 	argn++;
     }
+    SNMP_FREE(buff);
 
     for (arg = 0; arg < argn; arg++) {
         DEBUGMSGTL(("proxy_args", "final args: %d = %s\n", arg,
@@ -116,12 +138,18 @@ proxy_parse_config(const char *token, char *line)
     
     if (arg < 0) {
         config_perror("failed to parse proxy args");
+        /* Free the memory allocated */
+        while(argn--)
+            SNMP_FREE(argv[argn]);
         return;
     }
     DEBUGMSGTL(("proxy_config", "done parsing args\n"));
 
     if (arg >= argn) {
         config_perror("missing base oid");
+        /* Free the memory allocated */
+        while(argn--)
+            SNMP_FREE(argv[argn]);   
         return;
     }
 
@@ -145,27 +173,37 @@ proxy_parse_config(const char *token, char *line)
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpget", &session);
-        SOCK_CLEANUP;
+        /* Free the memory allocated */
+        while(argn--)
+            SNMP_FREE(argv[argn]);
         return;
     }
 
     newp = (struct simple_proxy *) calloc(1, sizeof(struct simple_proxy));
 
     newp->sess = ss;
-    DEBUGMSGTL(("proxy_init", "name = %s\n", args[arg]));
+    DEBUGMSGTL(("proxy_init", "name = %s\n", argv[arg]));
     newp->name_len = MAX_OID_LEN;
-    if (!snmp_parse_oid(args[arg++], newp->name, &newp->name_len)) {
+    if (!snmp_parse_oid(argv[arg++], newp->name, &newp->name_len)) {
         snmp_perror("proxy");
         config_perror("illegal proxy oid specified\n");
+        /*deallocate the memory previously allocated*/
+        SNMP_FREE(newp);
+        while(argn--)
+            SNMP_FREE(argv[argn]);
         return;
     }
 
     if (arg < argn) {
-        DEBUGMSGTL(("proxy_init", "base = %s\n", args[arg]));
+        DEBUGMSGTL(("proxy_init", "base = %s\n", argv[arg]));
         newp->base_len = MAX_OID_LEN;
-        if (!snmp_parse_oid(args[arg++], newp->base, &newp->base_len)) {
+        if (!snmp_parse_oid(argv[arg++], newp->base, &newp->base_len)) {
             snmp_perror("proxy");
             config_perror("illegal variable name specified (base oid)\n");
+            SNMP_FREE(newp);
+            /* Free the memory allocated */
+            while(argn--)
+                SNMP_FREE(argv[argn]);
             return;
         }
     }
@@ -213,6 +251,9 @@ proxy_parse_config(const char *token, char *line)
         reg->contextName = strdup(context_string);
 
     netsnmp_register_handler(reg);
+    /* Free the memory allocated */
+    while(argn--)
+        SNMP_FREE(argv[argn]);
 }
 
 void
diff --git a/agent/mibgroup/ucd-snmp/versioninfo.c b/agent/mibgroup/ucd-snmp/versioninfo.c
index f7a8c63..a5151c1 100644
--- a/agent/mibgroup/ucd-snmp/versioninfo.c
+++ b/agent/mibgroup/ucd-snmp/versioninfo.c
@@ -132,7 +132,7 @@ var_extensible_version(struct variable *vp,
             *var_len = 1024;    /* mib imposed restriction */
         return (u_char *) config_opts;
 #else
-        strlcpy(errmsg, "", sizeof(errmsg)));
+        strlcpy(errmsg, "", sizeof(errmsg));
         *var_len = strlen(errmsg);
         return ((u_char *) errmsg);
 #endif
diff --git a/agent/mibgroup/ucd_snmp.h b/agent/mibgroup/ucd_snmp.h
index 0d87ec1..6fb8e56 100644
--- a/agent/mibgroup/ucd_snmp.h
+++ b/agent/mibgroup/ucd_snmp.h
@@ -12,7 +12,9 @@ config_require(ucd-snmp/file)
 config_require(ucd-snmp/dlmod)
 #endif
 config_require(ucd-snmp/proxy)
+#ifdef HAVE_REGEX_H
 config_require(ucd-snmp/logmatch)
+#endif
 config_require(ucd-snmp/memory)
 config_require(ucd-snmp/vmstat)
 config_add_mib(UCD-SNMP-MIB)
diff --git a/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c b/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c
index efb8bb6..7a87842 100644
--- a/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c
+++ b/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c
@@ -153,7 +153,11 @@ _load(netsnmp_container *container, u_int load_flags)
 #endif
 
 #if !defined(NETSNMP_ENABLE_IPV6)
+#ifdef INP_ISIPV6
+        if (INP_ISIPV6(&pcb.xi_inp))
+#else
         if (pcb.xi_inp.inp_vflag & INP_IPV6)
+#endif
 	    continue;
 #endif
 
@@ -169,7 +173,11 @@ _load(netsnmp_container *container, u_int load_flags)
         entry->pid = 0;
         
         /** the addr string may need work */
+#ifdef INP_ISIPV6
+	if (INP_ISIPV6(&pcb.xi_inp)) {
+#else
 	if (pcb.xi_inp.inp_vflag & INP_IPV6) {
+#endif
 	    entry->loc_addr_len = entry->rmt_addr_len = 16;
 	    memcpy(entry->loc_addr, &pcb.xi_inp.in6p_laddr, 16);
 	    memcpy(entry->rmt_addr, &pcb.xi_inp.in6p_faddr, 16);
@@ -187,6 +195,8 @@ _load(netsnmp_container *container, u_int load_flags)
         CONTAINER_INSERT(container, entry);
     }
 
+    free(udpcb_buf);
+
     if(rc<0)
         return rc;
 
diff --git a/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c b/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c
index 99b67dc..3ebde32 100644
--- a/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c
+++ b/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c
@@ -21,7 +21,25 @@
 #include <netinet/udp_var.h>
 #endif
 
+#if HAVE_KVM_GETFILES
+#if defined(HAVE_KVM_GETFILE2) || !defined(openbsd5)
+#undef HAVE_KVM_GETFILES
+#endif
+#endif
+
+#if HAVE_KVM_GETFILES
+#include <kvm.h>
+#include <sys/sysctl.h>
+#define _KERNEL /* for DTYPE_SOCKET */
+#include <sys/file.h>
+#undef _KERNEL
+#endif
+
+#ifdef HAVE_KVM_GETFILES
+static int _kvmload(netsnmp_container *container, u_int flags);
+#else
 static int _load(netsnmp_container *container, u_int flags);
+#endif
 
 /*
  * initialize arch specific storage
@@ -91,11 +109,80 @@ netsnmp_arch_udp_endpoint_container_load(netsnmp_container *container,
         return -1;
     }
 
+#ifdef HAVE_KVM_GETFILES
+    rc = _kvmload(container, load_flags);
+#else
     rc = _load(container, load_flags);
+#endif
+
+    return rc;
+}
+
+#ifdef HAVE_KVM_GETFILES
+/**
+ *
+ * @retval  0 no errors
+ * @retval !0 errors
+ */
+static int
+_kvmload(netsnmp_container *container, u_int load_flags)
+{
+    netsnmp_udp_endpoint_entry  *entry;
+    struct   kinfo_file *kf;
+    int      count;
+    int      rc = 0;
+
+    kf = kvm_getfiles(kd, KERN_FILE_BYFILE, DTYPE_SOCKET, sizeof(struct kinfo_file), &count);
+
+    while (count--) {
+	if (kf->so_protocol != IPPROTO_UDP)
+	    goto skip;
+#if !defined(NETSNMP_ENABLE_IPV6)
+        if (kf->so_family == AF_INET6)
+	    goto skip;
+#endif
 
+        entry = netsnmp_access_udp_endpoint_entry_create();
+        if(NULL == entry) {
+            rc = -3;
+            break;
+        }
+
+        /** oddly enough, these appear to already be in network order */
+        entry->loc_port = ntohs(kf->inp_lport);
+        entry->rmt_port = ntohs(kf->inp_fport);
+        entry->pid = kf->p_pid;
+        
+        /** the addr string may need work */
+	if (kf->so_family == AF_INET6) {
+	    entry->loc_addr_len = entry->rmt_addr_len = 16;
+	    memcpy(entry->loc_addr, &kf->inp_laddru, 16);
+	    memcpy(entry->rmt_addr, &kf->inp_faddru, 16);
+	}
+	else {
+	    entry->loc_addr_len = entry->rmt_addr_len = 4;
+	    memcpy(entry->loc_addr, &kf->inp_laddru[0], 4);
+	    memcpy(entry->rmt_addr, &kf->inp_faddru[0], 4);
+	}
+	DEBUGMSGTL(("udp-mib/data_access", "udp %d %d %d\n",
+	    entry->loc_addr_len, entry->loc_port, entry->rmt_port));
+
+        /*
+         * add entry to container
+         */
+        entry->index = CONTAINER_SIZE(container) + 1;
+        CONTAINER_INSERT(container, entry);
+skip:
+	kf++;
+    }
+
+    if (rc < 0)
     return rc;
+    return 0;
 }
 
+#else /* HAVE_KVM_GETFILES */
+
 /**
  *
  * @retval  0 no errors
@@ -175,3 +262,4 @@ _load(netsnmp_container *container, u_int load_flags)
 
     return 0;
 }
+#endif /* HAVE_KVM_GETFILES */
diff --git a/agent/mibgroup/udp-mib/data_access/udp_endpoint_private.h b/agent/mibgroup/udp-mib/data_access/udp_endpoint_private.h
index 3ca9b2a..81ac0e1 100644
--- a/agent/mibgroup/udp-mib/data_access/udp_endpoint_private.h
+++ b/agent/mibgroup/udp-mib/data_access/udp_endpoint_private.h
@@ -5,3 +5,4 @@ void netsnmp_arch_udp_endpoint_entry_cleanup(netsnmp_udp_endpoint_entry *);
 int netsnmp_arch_udp_endpoint_entry_delete(netsnmp_udp_endpoint_entry *);
 int netsnmp_arch_udp_endpoint_entry_copy(netsnmp_udp_endpoint_entry *,
                                     netsnmp_udp_endpoint_entry *);
+int netsnmp_arch_udp_endpoint_delete(netsnmp_udp_endpoint_entry *entry);
diff --git a/agent/mibgroup/udp-mib/udpEndpointTable/udpEndpointTable_data_access.c b/agent/mibgroup/udp-mib/udpEndpointTable/udpEndpointTable_data_access.c
index 0e25c21..776273c 100644
--- a/agent/mibgroup/udp-mib/udpEndpointTable/udpEndpointTable_data_access.c
+++ b/agent/mibgroup/udp-mib/udpEndpointTable/udpEndpointTable_data_access.c
@@ -286,7 +286,8 @@ udpEndpointTable_container_load(netsnmp_container *container)
         /*
          * insert into table container
          */
-        CONTAINER_INSERT(container, rowreq_ctx);
+        if (CONTAINER_INSERT(container, rowreq_ctx))
+	    udpEndpointTable_release_rowreq_ctx(rowreq_ctx);
     }
 
     ITERATOR_RELEASE(ep_it);
diff --git a/agent/mibgroup/util_funcs.c b/agent/mibgroup/util_funcs.c
index 54068c6..806deb7 100644
--- a/agent/mibgroup/util_funcs.c
+++ b/agent/mibgroup/util_funcs.c
@@ -6,6 +6,11 @@
  * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -83,6 +88,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/snmp_logging.h>
+#include <net-snmp/agent/netsnmp_close_fds.h>
 
 #include "struct.h"
 #include "util_funcs.h"
@@ -116,12 +122,10 @@ netsnmp_feature_child_of(find_prefix_info, prefix_info_all)
 netsnmp_feature_child_of(create_prefix_info, prefix_info_all)
 #endif /* HAVE_LINUX_RTNETLINK_H */
 
-#ifdef NETSNMP_EXCACHETIME
+#if defined(NETSNMP_EXCACHETIME) && defined(USING_UTILITIES_EXECUTE_MODULE) && defined(HAVE_EXECV)
 static long     cachetime;
 #endif
 
-extern int      numprocs, numextens;
-
 /** deprecated, use netsnmp_mktemp instead */
 const char *
 make_tempfile(void)
@@ -389,7 +393,7 @@ get_exec_output(struct extensible *ex)
     }
     return fd;
 #endif                          /* WIN32 */
-#endif
+#endif       /* HAVE_EXEC */
 #endif /* !defined(USING_UTILITIES_EXECUTE_MODULE) */
     return -1;
 }
@@ -463,16 +467,20 @@ get_exec_pipes(char *cmd, int *fdIn, int *fdOut, netsnmp_pid_t *pid)
         return 0;
     }
     if ((*pid = fork()) == 0) { /* First handle for the child */
+        close(fd[0][1]);
+        close(fd[1][0]);
         close(0);
         if (dup(fd[0][0]) != 0) {
             setPerrorstatus("dup 0");
             return 0;
         }
+        close(fd[0][0]);
         close(1);
         if (dup(fd[1][1]) != 1) {
             setPerrorstatus("dup 1");
             return 0;
         }
+        close(fd[1][1]);
 
         /*
          * write standard output and standard error to pipe. 
@@ -480,8 +488,7 @@ get_exec_pipes(char *cmd, int *fdIn, int *fdOut, netsnmp_pid_t *pid)
         /*
          * close all non-standard open file descriptors 
          */
-        for (cnt = getdtablesize() - 1; cnt >= 2; --cnt)
-            (void) close(cnt);
+        netsnmp_close_fds(1);
         (void) dup(1);          /* stderr */
 
         for (cnt = 1, cptr1 = cmd, cptr2 = argvs; *cptr1 != 0;
@@ -664,19 +671,19 @@ clear_cache(int action,
             size_t var_val_len,
             u_char * statP, oid * name, size_t name_len)
 {
-
-    long            tmp = 0;
-
     if (var_val_type != ASN_INTEGER) {
         snmp_log(LOG_NOTICE, "Wrong type != int\n");
         return SNMP_ERR_WRONGTYPE;
     }
-    tmp = *((long *) var_val);
-    if (tmp == 1 && action == COMMIT) {
-#ifdef NETSNMP_EXCACHETIME
-        cachetime = 0;          /* reset the cache next read */
-#endif
+#if defined(NETSNMP_EXCACHETIME) && defined(USING_UTILITIES_EXECUTE_MODULE) && defined(HAVE_EXECV)
+    else {
+        long            tmp = 0;
+        tmp = *((long *) var_val);
+        if (tmp == 1 && action == COMMIT) {
+            cachetime = 0;          /* reset the cache next read */
+        }
     }
+#endif
     return SNMP_ERR_NOERROR;
 }
 #endif /* NETSNMP_FEATURE_REMOVE_CLEAR_CACHE */
diff --git a/agent/mibgroup/util_funcs/restart.c b/agent/mibgroup/util_funcs/restart.c
index 5cad737..a2ed20a 100644
--- a/agent/mibgroup/util_funcs/restart.c
+++ b/agent/mibgroup/util_funcs/restart.c
@@ -21,6 +21,8 @@
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/library/snmp_logging.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "restart.h"
 
 #ifdef USING_UCD_SNMP_ERRORMIB_MODULE
 #include "ucd-snmp/errormib.h"
diff --git a/agent/mibgroup/util_funcs/restart.h b/agent/mibgroup/util_funcs/restart.h
index 82760a1..98cd36d 100644
--- a/agent/mibgroup/util_funcs/restart.h
+++ b/agent/mibgroup/util_funcs/restart.h
@@ -5,6 +5,8 @@
 extern "C" {
 #endif
 
+extern char **argvrestartp, *argvrestartname, *argvrestart;
+
 RETSIGTYPE      restart_doit(int);
 WriteMethod     restart_hook;
 
diff --git a/agent/mibgroup/utilities/execute.c b/agent/mibgroup/utilities/execute.c
index 68f3654..3d414c7 100644
--- a/agent/mibgroup/utilities/execute.c
+++ b/agent/mibgroup/utilities/execute.c
@@ -35,6 +35,8 @@
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <ucd-snmp/errormib.h>
 
+#include <net-snmp/agent/netsnmp_close_fds.h>
+
 #include "execute.h"
 #include "struct.h"
 
@@ -200,15 +202,18 @@ run_exec_command( char *command, char *input,
          */
         close(0);
         dup(  ipipe[0]);
+        close(ipipe[0]);
 	close(ipipe[1]);
 
         close(1);
         dup(  opipe[1]);
         close(opipe[0]);
+        close(opipe[1]);
+
         close(2);
         dup(1);
-        for (i = getdtablesize()-1; i>2; i--)
-            close(i);
+
+        netsnmp_close_fds(2);
 
         /*
          * Set up the argv array and execute it
diff --git a/agent/mibgroup/utilities/iquery.c b/agent/mibgroup/utilities/iquery.c
index 860590f..140c99b 100644
--- a/agent/mibgroup/utilities/iquery.c
+++ b/agent/mibgroup/utilities/iquery.c
@@ -3,6 +3,7 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
+#include "agentx/subagent.h"
 #include "utilities/iquery.h"
 
 netsnmp_feature_child_of(iquery_all, libnetsnmpmibs)
@@ -180,7 +181,6 @@ netsnmp_session *netsnmp_iquery_session(char* secName,   int   version,
      * It might be worth keeping track of which 'secNames' already
      * have iquery sessions created, and re-using the appropriate one.  
      */
-    extern int callback_master_num;
     netsnmp_session *ss = NULL;
 
 #ifdef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
diff --git a/agent/mibgroup/utilities/override.c b/agent/mibgroup/utilities/override.c
index 48ac281..14cc92c 100644
--- a/agent/mibgroup/utilities/override.c
+++ b/agent/mibgroup/utilities/override.c
@@ -14,6 +14,7 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "override.h"
 
 typedef struct override_data_s {
     int             type;
diff --git a/agent/netsnmp_close_fds.c b/agent/netsnmp_close_fds.c
new file mode 100644
index 0000000..9fc21ae
--- /dev/null
+++ b/agent/netsnmp_close_fds.c
@@ -0,0 +1,41 @@
+#include <net-snmp/net-snmp-config.h>
+
+#include <stdio.h>
+#if HAVE_DIRENT_H
+#include <dirent.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include <net-snmp/agent/netsnmp_close_fds.h>
+
+/**
+ * Close all file descriptors larger than @fd.
+ */
+void netsnmp_close_fds(int fd)
+{
+#if defined(HAVE_FORK)
+    DIR            *dir;
+    struct dirent  *ent;
+    int             i, largest_fd = -1;
+
+    if (fd < -1)
+        fd = -1;
+
+    if ((dir = opendir("/proc/self/fd"))) {
+        while ((ent = readdir(dir))) {
+            if (sscanf(ent->d_name, "%d", &i) == 1) {
+                if (i > largest_fd)
+                    largest_fd = i;
+            }
+        }
+        closedir(dir);
+    } else {
+        largest_fd = getdtablesize() - 1;
+    }
+
+    for (i = largest_fd; i > fd && i >= 0; i--)
+        close(i);
+#endif
+}
diff --git a/agent/snmp_agent.c b/agent/snmp_agent.c
index b96d650..6626d6e 100644
--- a/agent/snmp_agent.c
+++ b/agent/snmp_agent.c
@@ -3,10 +3,6 @@
  *
  * Simple Network Management Protocol (RFC 1067).
  */
-/* Portions of this file are subject to the following copyright(s).  See
- * the Net-SNMP's COPYING file for more details and other copyrights
- * that may apply:
- */
 /* Portions of this file are subject to the following copyrights.  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
@@ -37,6 +33,11 @@ SOFTWARE.
  * Copyright © 2003 Sun Microsystems, Inc. All rights 
  * reserved.  Use is subject to license terms specified in the 
  * COPYING file distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 /** @defgroup snmp_agent net-snmp agent related processing 
  *  @ingroup agent
@@ -189,8 +190,8 @@ netsnmp_free_agent_request_info(netsnmp_agent_request_info *ari)
     }
 }
 
-oid      version_sysoid[] = { NETSNMP_SYSTEM_MIB };
-int      version_sysoid_len = OID_LENGTH(version_sysoid);
+const oid version_sysoid[] = { NETSNMP_SYSTEM_MIB };
+const int version_sysoid_len = OID_LENGTH(version_sysoid);
 
 #define SNMP_ADDRCACHE_SIZE 10
 #define SNMP_ADDRCACHE_MAXAGE 300 /* in seconds */
@@ -225,31 +226,21 @@ netsnmp_agent_session *agent_delegated_list = NULL;
 netsnmp_agent_session *netsnmp_agent_queued_list = NULL;
 
 
-int             netsnmp_agent_check_packet(netsnmp_session *,
-                                           struct netsnmp_transport_s *,
-                                           void *, int);
-int             netsnmp_agent_check_parse(netsnmp_session *, netsnmp_pdu *,
-                                          int);
-void            delete_subnetsnmp_tree_cache(netsnmp_agent_session *asp);
 int             handle_pdu(netsnmp_agent_session *asp);
 int             netsnmp_handle_request(netsnmp_agent_session *asp,
                                        int status);
-int             netsnmp_wrap_up_request(netsnmp_agent_session *asp,
-                                        int status);
 int             check_delayed_request(netsnmp_agent_session *asp);
 int             handle_getnext_loop(netsnmp_agent_session *asp);
 int             handle_set_loop(netsnmp_agent_session *asp);
 
-int             netsnmp_check_queued_chain_for(netsnmp_agent_session *asp);
-int             netsnmp_add_queued(netsnmp_agent_session *asp);
 int             netsnmp_remove_from_delegated(netsnmp_agent_session *asp);
 
 
-static int      current_globalid = 0;
-
 int      netsnmp_running = 1;
 
 #ifndef NETSNMP_FEATURE_REMOVE_ALLOCATE_GLOBALCACHEID
+static int      current_globalid = 0;
+
 int
 netsnmp_allocate_globalcacheid(void)
 {
@@ -1570,6 +1561,7 @@ netsnmp_remove_delegated_requests_for_session(netsnmp_session *sess)
     return count;
 }
 
+#if 0
 int
 netsnmp_check_queued_chain_for(netsnmp_agent_session *asp)
 {
@@ -1580,6 +1572,7 @@ netsnmp_check_queued_chain_for(netsnmp_agent_session *asp)
     }
     return 0;
 }
+#endif
 
 int
 netsnmp_add_queued(netsnmp_agent_session *asp)
@@ -1695,6 +1688,7 @@ netsnmp_wrap_up_request(netsnmp_agent_session *asp, int status)
                     break;
             }
         }
+#endif /* NETSNMP_NO_WRITE_SUPPORT */
         /*
          * Similarly we may need to "dumb down" v2 exception
          *  types to throw an error for a v1 query.
@@ -1720,7 +1714,6 @@ netsnmp_wrap_up_request(netsnmp_agent_session *asp, int status)
                 ++i;
             }
         }
-#endif /* NETSNMP_NO_WRITE_SUPPORT */
 #endif /* snmpv1 support */
     } /** if asp->pdu */
 
@@ -1929,6 +1922,16 @@ handle_snmp_packet(int op, netsnmp_session * session, int reqid,
         status = asp->status;
     }
 
+#ifdef NETSNMP_DISABLE_SET_SUPPORT
+    if (pdu->command == SNMP_MSG_SET) {
+        /** Silvercreek protocol tests send set with 0 varbinds */
+        if (NULL == pdu->variables)
+            return netsnmp_wrap_up_request(asp, SNMP_ERR_NOERROR);
+        asp->index = 1;
+        return netsnmp_wrap_up_request(asp, SNMP_ERR_NOTWRITABLE);
+    }
+#endif /* NETSNMP_DISABLE_SET_SUPPORT */
+
     if ((access_ret = check_access(asp->pdu)) != 0) {
         if (access_ret == VACM_NOSUCHCONTEXT) {
             /*
@@ -3716,7 +3719,7 @@ netsnmp_get_agent_runtime(void)
 
     netsnmp_get_monotonic_clock(&now);
     NETSNMP_TIMERSUB(&now, &starttimeM, &delta);
-    return delta.tv_sec * (uint64_t)100 + delta.tv_usec / 10000;
+    return (uint64_t)(delta.tv_sec * (uint64_t)100 + delta.tv_usec / 10000);
 }
 
 /**
@@ -3753,7 +3756,7 @@ netsnmp_get_agent_uptime(void)
 
     netsnmp_get_monotonic_clock(&now);
     NETSNMP_TIMERSUB(&now, &starttimeM, &delta);
-    return delta.tv_sec * 100UL + delta.tv_usec / 10000;
+    return (u_long)(delta.tv_sec * 100UL + delta.tv_usec / 10000);
 }
 
 #ifndef NETSNMP_FEATURE_REMOVE_SET_AGENT_UPTIME
diff --git a/agent/snmp_vars.c b/agent/snmp_vars.c
index 2f9e6ef..330d0eb 100644
--- a/agent/snmp_vars.c
+++ b/agent/snmp_vars.c
@@ -177,8 +177,6 @@ struct module_init_list *noinitlist = NULL;
  */
 #define MIB_CLIENTS_ARE_EVIL 1
 
-extern netsnmp_subtree *subtrees;
-
 /*
  *      Each variable name is placed in the variable table, without the
  * terminating substring that determines the instance of the variable.  When
diff --git a/agent/snmpd.c b/agent/snmpd.c
index cfc7bce..abac5b1 100644
--- a/agent/snmpd.c
+++ b/agent/snmpd.c
@@ -149,9 +149,12 @@ typedef long    fd_mask;
 
 #include <net-snmp/agent/agent_trap.h>
 
+#include <net-snmp/agent/netsnmp_close_fds.h>
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 
+#include "mibgroup/util_funcs/restart.h"
+
 /*
  * Include winservice.h to support Windows Service
  */
@@ -194,13 +197,6 @@ LPCTSTR         app_name_long = _T("Net-SNMP Agent");     /* Application Name */
 
 const char     *app_name = "snmpd";
 
-extern int      netsnmp_running;
-#ifdef USING_UTIL_FUNCS_RESTART_MODULE
-extern char   **argvrestartp;
-extern char    *argvrestart;
-extern char    *argvrestartname;
-#endif /* USING_UTIL_FUNCS_RESTART_MODULE */
-
 #ifdef USING_SMUX_MODULE
 #include <mibgroup/smux/smux.h>
 #endif /* USING_SMUX_MODULE */
@@ -208,18 +204,11 @@ extern char    *argvrestartname;
 /*
  * Prototypes.
  */
-int             snmp_read_packet(int);
-int             snmp_input(int, netsnmp_session *, int, netsnmp_pdu *,
-                           void *);
 static void     usage(char *);
 static void     SnmpTrapNodeDown(void);
 static int      receive(void);
 #ifdef WIN32SERVICE
-void            StopSnmpAgent(void);
-int             SnmpDaemonMain(int argc, TCHAR * argv[]);
-int __cdecl     _tmain(int argc, TCHAR * argv[]);
-#else
-int             main(int, char **);
+static void     StopSnmpAgent(void);
 #endif
 
 /*
@@ -340,7 +329,6 @@ usage(char *prog)
            "  -S d|i|0-7\t\tuse -Ls <facility> instead\n"
            "\n"
            );
-    exit(1);
 }
 
 static void
@@ -350,15 +338,11 @@ version(void)
            "Web:               http://www.net-snmp.org/\n"
            "Email:             net-snmp-coders@lists.sourceforge.net\n\n",
            netsnmp_get_version());
-    exit(0);
 }
 
 RETSIGTYPE
 SnmpdShutDown(int a)
 {
-#ifdef WIN32SERVICE
-    extern netsnmp_session *main_session;
-#endif
     netsnmp_running = 0;
 #ifdef WIN32SERVICE
     /*
@@ -380,7 +364,6 @@ SnmpdReconfig(int a)
 #endif
 
 #ifdef SIGUSR1
-extern void     dump_registry(void);
 RETSIGTYPE
 SnmpdDump(int a)
 {
@@ -429,15 +412,16 @@ SnmpTrapNodeDown(void)
  *
  * Also successfully EXITs with zero for some options.
  */
-int
 #ifdef WIN32SERVICE
+static int
 SnmpDaemonMain(int argc, TCHAR * argv[])
 #else
+int
 main(int argc, char *argv[])
 #endif
 {
     char            options[128] = "aAc:CdD::fhHI:l:L:m:M:n:p:P:qrsS:UvV-:Y:";
-    int             arg, i, ret;
+    int             arg, i, ret, exit_code = 1;
     int             dont_fork = 0, do_help = 0;
     int             log_set = 0;
     int             agent_mode = -1;
@@ -448,15 +432,15 @@ main(int argc, char *argv[])
     FILE           *PID;
 #endif
 
+    SOCK_STARTUP;
+
 #ifndef WIN32
     /*
      * close all non-standard file descriptors we may have
      * inherited from the shell.
      */
-    for (i = getdtablesize() - 1; i > 2; --i) {
-        (void) close(i);
-    }
-#endif /* #WIN32 */
+    netsnmp_close_fds(2);
+#endif
     
     /*
      * register signals ASAP to prevent default action (usually core)
@@ -544,9 +528,12 @@ main(int argc, char *argv[])
         case '-':
             if (strcasecmp(optarg, "help") == 0) {
                 usage(argv[0]);
+                goto out;
             }
             if (strcasecmp(optarg, "version") == 0) {
                 version();
+                exit_code = 0;
+                goto out;
             }
 
             handle_long_opt(optarg);
@@ -584,7 +571,7 @@ main(int argc, char *argv[])
         case 'D':
 #ifdef NETSNMP_DISABLE_DEBUGGING
             fprintf(stderr, "Debugging not configured\n");
-            exit(1);
+            goto out;
 #else
             debug_register_tokens(optarg);
             snmp_set_do_debugging(1);
@@ -613,7 +600,7 @@ main(int argc, char *argv[])
 #endif
                 if (gid < 0) {
                     fprintf(stderr, "Bad group id: %s\n", optarg);
-                    exit(1);
+                    goto out;
                 }
                 netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_GROUPID, gid);
@@ -647,7 +634,7 @@ main(int argc, char *argv[])
                     fprintf(stderr,
                             "%s: logfile path too long (limit %d chars)\n",
                             argv[0], PATH_MAX);
-                    exit(1);
+                    goto out;
                 }
                 snmp_enable_filelog(optarg,
                                     netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
@@ -791,7 +778,7 @@ main(int argc, char *argv[])
 #endif
                 if (uid < 0) {
                     fprintf(stderr, "Bad user id: %s\n", optarg);
-                    exit(1);
+                    goto out;
                 }
                 netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_USERID, uid);
@@ -829,7 +816,7 @@ main(int argc, char *argv[])
             fprintf(stderr, "%s: Illegal argument -X:"
 		            "AgentX support not compiled in.\n", argv[0]);
             usage(argv[0]);
-            exit(1);
+            goto out;
 #endif
             break;
 
@@ -851,7 +838,8 @@ main(int argc, char *argv[])
         init_snmp(app_name);
         fprintf(stderr, "Configuration directives understood:\n");
         read_config_print_usage("  ");
-        exit(0);
+        exit_code = 0;
+        goto out;
     }
 
     if (optind < argc) {
@@ -867,7 +855,7 @@ main(int argc, char *argv[])
                 astring = (char*)malloc(strlen(c) + 2 + strlen(argv[i]));
                 if (astring == NULL) {
                     fprintf(stderr, "malloc failure processing argv[%d]\n", i);
-                    exit(1);
+                    goto out;
                 }
                 sprintf(astring, "%s,%s", c, argv[i]);
                 netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
@@ -883,7 +871,7 @@ main(int argc, char *argv[])
 					  NETSNMP_DS_AGENT_PORTS)));
 #else /* NETSNMP_NO_LISTEN_SUPPORT */
         fprintf(stderr, "You specified ports to open; this agent was built to only send notifications\n");
-        exit(1);
+        goto out;
 #endif /* NETSNMP_NO_LISTEN_SUPPORT */
     }
 
@@ -912,7 +900,7 @@ main(int argc, char *argv[])
         argvrestartname = (char *) malloc(strlen(argv[0]) + 1);
         if (!argvrestartp || !argvrestart || !argvrestartname) {
             fprintf(stderr, "malloc failure processing argvrestart\n");
-            exit(1);
+            goto out;
         }
         strcpy(argvrestartname, argv[0]);
 
@@ -937,10 +925,9 @@ main(int argc, char *argv[])
 			       NETSNMP_DS_AGENT_ROLE, agent_mode);
     }
 
-    SOCK_STARTUP;
     if (init_agent(app_name) != 0) {
         snmp_log(LOG_ERR, "Agent initialization failed\n");
-        exit(1);
+        goto out;
     }
     init_mib_modules();
 
@@ -954,7 +941,7 @@ main(int argc, char *argv[])
          * Some error opening one of the specified agent transports.  
          */
         snmp_log(LOG_ERR, "Server Exiting with code 1\n");
-        exit(1);
+        goto out;
     }
 
     /*
@@ -975,7 +962,7 @@ main(int argc, char *argv[])
          */
         if(ret != 0) {
             snmp_log(LOG_ERR, "Server Exiting with code 1\n");
-            exit(1);
+            goto out;
         }
     }
 
@@ -992,12 +979,12 @@ main(int argc, char *argv[])
             snmp_log_perror(pid_file);
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
                                         NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                goto out;
             }
         } else {
             if ((PID = fdopen(fd, "w")) == NULL) {
                 snmp_log_perror(pid_file);
-                exit(1);
+                goto out;
             } else {
                 fprintf(PID, "%d\n", (int) getpid());
                 fclose(PID);
@@ -1041,7 +1028,7 @@ main(int argc, char *argv[])
             snmp_log_perror("setgid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                goto out;
             }
         }
     }
@@ -1063,7 +1050,7 @@ main(int argc, char *argv[])
                 snmp_log_perror("initgroups failed");
                 if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
                                             NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                    exit(1);
+                    goto out;
                 }
             }
         }
@@ -1074,7 +1061,7 @@ main(int argc, char *argv[])
             snmp_log_perror("setuid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                goto out;
             }
         }
     }
@@ -1135,8 +1122,11 @@ main(int argc, char *argv[])
     SNMP_FREE(argvrestartp);
 #endif /* USING_UTIL_FUNCS_RESTART_MODULE */
 
+    exit_code = 0;
+
+out:
     SOCK_CLEANUP;
-    return 0;
+    return exit_code;
 }                               /* End main() -- snmpd */
 
 #if defined(WIN32)
@@ -1473,16 +1463,14 @@ _tmain(int argc, TCHAR * argv[])
          */
         InputOptions.Argc = argc;
         InputOptions.Argv = argv;
-        exit (RegisterService(lpszServiceName,
+        return RegisterService(lpszServiceName,
                         lpszServiceDisplayName,
-                        lpszServiceDescription, &InputOptions, quiet));
-        break;
+                        lpszServiceDescription, &InputOptions, quiet);
     case UN_REGISTER_SERVICE:
         /*
          * Unregister service 
          */
-        exit (UnregisterService(lpszServiceName, quiet));
-        break;
+        return UnregisterService(lpszServiceName, quiet);
     case RUN_AS_SERVICE:
         /*
          * Run as service 
@@ -1492,13 +1480,11 @@ _tmain(int argc, TCHAR * argv[])
          */
         RegisterStopFunction(StopSnmpAgent);
         return RunAsService(SnmpDaemonMain);
-        break;
     default:
         /*
          * Run in console mode 
          */
         return SnmpDaemonMain(argc, argv);
-        break;
     }
 }
 
diff --git a/apps/agentxtrap.c b/apps/agentxtrap.c
index 4df423c..245f666 100644
--- a/apps/agentxtrap.c
+++ b/apps/agentxtrap.c
@@ -14,6 +14,7 @@
 #include "../agent/mibgroup/agentx/agentx_config.h"
 #include "../agent/mibgroup/agentx/client.h"
 #include "../agent/mibgroup/agentx/protocol.h"
+#include "../agent/mibgroup/agentx/subagent.h"
 
 netsnmp_feature_require(snmp_split_pdu)
 netsnmp_feature_require(snmp_reset_var_types)
@@ -25,11 +26,6 @@ netsnmp_feature_require(snmp_reset_var_types)
 #define UNUSED
 #endif
 
-extern const oid sysuptime_oid[];
-extern const size_t sysuptime_oid_len;
-extern const oid snmptrap_oid[];
-extern const size_t snmptrap_oid_len;
-
 static void
 usage(const char* progname)
 {
@@ -429,9 +425,11 @@ main(int argc, char *argv[])
     int             arg;
     char           *prognam;
     char           *cp = NULL;
-
     const char*     sysUpTime = NULL;
 
+    /* initialize tcpip, if necessary */
+    SOCK_STARTUP;
+
     prognam = strrchr(argv[0], '/');
     if (prognam)
         ++prognam;
@@ -449,7 +447,8 @@ main(int argc, char *argv[])
         switch (arg) {
         case 'h':
             usage(prognam);
-            exit(0);
+            result = 0;
+            goto out;
         case 'm':
             setenv("MIBS", optarg, 1);
             break;
@@ -473,22 +472,21 @@ main(int argc, char *argv[])
             break;
         case 'V':
             fprintf(stderr, "NET-SNMP version: %s\n", netsnmp_get_version());
-            exit(0);
-            break;
+            result = 0;
+            goto out;
 #ifndef DISABLE_MIB_LOADING
         case 'P':
             cp = snmp_mib_toggle_options(optarg);
             if (cp != NULL) {
                 fprintf(stderr, "Unknown parser option to -P: %c.\n", *cp);
                 usage(prognam);
-                exit(1);
+                goto out;
             }
             break;
 #endif /* DISABLE_MIB_LOADING */
         case 'L':
-            if (snmp_log_options(optarg, argc, argv) < 0) {
-                exit(1);
-            }
+            if (snmp_log_options(optarg, argc, argv) < 0)
+                goto out;
             break;
         case 'x':
             if (optarg != NULL) {
@@ -501,22 +499,17 @@ main(int argc, char *argv[])
         case ':':
             fprintf(stderr, "Option -%c requires an operand\n", optopt);
             usage(prognam);
-            exit(1);
-            break;
+            goto out;
         case '?':
             fprintf(stderr, "Unrecognized option: -%c\n", optopt);
             usage(prognam);
-            exit(1);
-            break;
+            goto out;
         }
     }
 
     arg = optind;
 
-    /* initialize tcpip, if necessary */
-    SOCK_STARTUP;
-
-    init_snmp("snmpapp");
+    init_snmp(NETSNMP_APPLICATION_CONFIG_TYPE);
     agentx_config_init();
 
     /* NOTIFY varlist */
@@ -528,14 +521,12 @@ main(int argc, char *argv[])
     if (arg == argc) {
         fprintf(stderr, "Missing trap-oid parameter\n");
         usage(prognam);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     if (snmp_add_var(pdu, snmptrap_oid, snmptrap_oid_len, 'o', argv[arg])) {
         snmp_perror(argv[arg]);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
     ++arg;
 
@@ -546,19 +537,16 @@ main(int argc, char *argv[])
         if (arg > argc) {
             fprintf(stderr, "%s: Missing type/value for variable\n",
                     argv[arg - 3]);
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         if (!snmp_parse_oid(argv[arg - 3], name, &name_length)) {
             snmp_perror(argv[arg - 3]);
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         if (snmp_add_var(pdu, name, name_length, argv[arg - 2][0],
                          argv[arg - 1]) != 0) {
             snmp_perror(argv[arg - 3]);
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
     }
 
@@ -605,8 +593,9 @@ main(int argc, char *argv[])
     snmp_free_pdu(pdu);
     pdu = NULL;
 
-    snmp_shutdown("snmpapp");
+    snmp_shutdown(NETSNMP_APPLICATION_CONFIG_TYPE);
 
+out:
     SOCK_CLEANUP;
-    exit(result);
+    return result;
 }
diff --git a/apps/encode_keychange.c b/apps/encode_keychange.c
index 5bf8e4c..875f4d9 100644
--- a/apps/encode_keychange.c
+++ b/apps/encode_keychange.c
@@ -233,7 +233,8 @@ main(int argc, char **argv)
                     (unsigned long)engineid_len));
     } else {
         engineid_len = setup_engineID(&engineid, (char *) engineid);
-
+        if ((ssize_t)engineid_len < 0)
+            exit(1);
     }
 
 #ifdef NETSNMP_ENABLE_TESTING_CODE
@@ -403,7 +404,7 @@ usage_to_file(FILE * ofp)
    "-f will require reading from the stdin/terminal, ignoring a) and b).\n\
     -P will prevent prompts for passphrases to stdout from being printed.\n\
 \n\
-    <engineID> is interpreted as a hex string when preceeded by \"0x\",\n\
+    <engineID> is interpreted as a hex string when preceded by \"0x\",\n\
     otherwise it is created to contain \"text\".  If nothing is given,\n\
     <engineID> is constructed from the first IP address for the local host.\n");
 
diff --git a/apps/snmpbulkget.c b/apps/snmpbulkget.c
index 2e9ee34..2e72a2b 100644
--- a/apps/snmpbulkget.c
+++ b/apps/snmpbulkget.c
@@ -138,19 +138,22 @@ main(int argc, char *argv[])
     int             arg;
     int             count;
     int             status;
-    int             exitval = 0;
+    int             exitval = 1;
+
+    SOCK_STARTUP;
 
     /*
      * get the common command line arguments 
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -158,7 +161,7 @@ main(int argc, char *argv[])
     names = argc - arg;
     if (names < non_repeaters) {
         fprintf(stderr, "snmpbulkget: need more objects than <nonrep>\n");
-        exit(1);
+        goto out;
     }
 
     namep = name = (struct nameStruct *) calloc(names, sizeof(*name));
@@ -167,14 +170,12 @@ main(int argc, char *argv[])
         if (snmp_parse_oid(argv[arg], namep->name, &namep->name_len) ==
             NULL) {
             snmp_perror(argv[arg]);
-            exit(1);
+            goto out;
         }
         arg++;
         namep++;
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -184,10 +185,11 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpbulkget", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
+    exitval = 0;
+
     /*
      * create PDU for GETBULK request and add object name to request 
      */
@@ -245,6 +247,8 @@ main(int argc, char *argv[])
         snmp_free_pdu(response);
 
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmpbulkwalk.c b/apps/snmpbulkwalk.c
index 379d2ae..f1822d4 100644
--- a/apps/snmpbulkwalk.c
+++ b/apps/snmpbulkwalk.c
@@ -186,7 +186,9 @@ main(int argc, char *argv[])
     int             running;
     int             status = STAT_ERROR;
     int             check;
-    int             exitval = 0;
+    int             exitval = 1;
+
+    SOCK_STARTUP;
 
     netsnmp_ds_register_config(ASN_BOOLEAN, "snmpwalk", "includeRequested",
 			       NETSNMP_DS_APPLICATION_ID, 
@@ -203,12 +205,13 @@ main(int argc, char *argv[])
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -223,7 +226,7 @@ main(int argc, char *argv[])
         rootlen = MAX_OID_LEN;
         if (snmp_parse_oid(argv[arg], root, &rootlen) == NULL) {
             snmp_perror(argv[arg]);
-            exit(1);
+            goto out;
         }
     } else {
         /*
@@ -233,8 +236,6 @@ main(int argc, char *argv[])
         rootlen = sizeof(objid_mib) / sizeof(oid);
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -244,8 +245,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpbulkwalk", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     /*
@@ -263,6 +263,8 @@ main(int argc, char *argv[])
         snmp_get_and_print(ss, root, rootlen);
     }
 
+    exitval = 0;
+
     while (running) {
         /*
          * create PDU for GETBULK request and add object name to request 
@@ -381,6 +383,7 @@ main(int argc, char *argv[])
         printf("Variables found: %d\n", numprinted);
     }
 
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmpdelta.c b/apps/snmpdelta.c
index 08e2ebc..5c7c4cb 100644
--- a/apps/snmpdelta.c
+++ b/apps/snmpdelta.c
@@ -100,7 +100,7 @@ int             keepSeconds = 0, peaks = 0;
 int             tableForm = 0;
 int             varbindsPerPacket = 60;
 
-void            processFileArgs(char *fileName);
+static void     processFileArgs(char *fileName);
 
 void
 usage(void)
@@ -398,16 +398,19 @@ main(int argc, char *argv[])
     int             status;
     int             begin, end, last_end;
     int             print = 1;
-    int             exit_code = 0;
+    int             exit_code = 1;
+
+    SOCK_STARTUP;
 
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", &optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exit_code = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -418,27 +421,25 @@ main(int argc, char *argv[])
 	if (current_name >= MAX_ARGS) {
 	    fprintf(stderr, "%s: Too many variables specified (max %d)\n",
 	    	argv[optind], MAX_ARGS);
-	    exit(1);
+	    goto out;
 	}
         varinfo[current_name++].name = argv[optind];
     }
 
     if (current_name == 0) {
         usage();
-        exit(1);
+        goto out;
     }
 
     if (dosum) {
 	if (current_name >= MAX_ARGS) {
 	    fprintf(stderr, "Too many variables specified (max %d)\n",
 	    	MAX_ARGS);
-	    exit(1);
+	    goto out;
 	}
         varinfo[current_name++].name = NULL;
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -448,8 +449,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpdelta", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     if (tableForm && timestamp) {
@@ -463,8 +463,7 @@ main(int argc, char *argv[])
             if (snmp_parse_oid(vip->name, vip->info_oid, &vip->oidlen) ==
                 NULL) {
                 snmp_perror(vip->name);
-                SOCK_CLEANUP;
-                exit(1);
+                goto close_session;
             }
             sprint_descriptor(vip->descriptor, vip);
             if (tableForm)
@@ -591,7 +590,7 @@ main(int argc, char *argv[])
                         if (vip->type == ASN_COUNTER64) {
                             fprintf(stderr,
                                     "time delta and table form not supported for counter64s\n");
-                            exit(1);
+                            goto close_session;
                         } else {
                             printvalue =
                                 ((float) value * 100) / delta_time;
@@ -742,7 +741,13 @@ main(int argc, char *argv[])
             wait_for_period(period);
         }
     }
+
+    exit_code = 0;
+
+close_session:
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return (exit_code);
 }
diff --git a/apps/snmpdf.c b/apps/snmpdf.c
index 144a505..3f546d5 100644
--- a/apps/snmpdf.c
+++ b/apps/snmpdf.c
@@ -255,30 +255,31 @@ main(int argc, char *argv[])
     size_t          base_length;
     int             status;
     netsnmp_variable_list *saved = NULL, *vlp = saved, *vlp2;
-    int             count = 0;
+    int             count = 0, exit_code = 1;
+
+    SOCK_STARTUP;
 
     /*
      * get the common command line arguments 
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exit_code = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
 
     if (arg != argc) {
 	fprintf(stderr, "snmpdf: extra argument: %s\n", argv[arg]);
-	exit(1);
+	goto out;
     }
 
-    SOCK_STARTUP;
-
     /*
      * Open an SNMP session.
      */
@@ -288,8 +289,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpdf", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     if (human_units) {
@@ -332,7 +332,7 @@ main(int argc, char *argv[])
             status = snmp_synch_response(ss, pdu, &response);
             if (status != STAT_SUCCESS || !response) {
                 snmp_sess_perror("snmpdf", ss);
-                exit(1);
+                goto close_session;
             }
 
             vlp2 = response->variables;
@@ -411,7 +411,7 @@ main(int argc, char *argv[])
             status = snmp_synch_response(ss, pdu, &response);
             if (status != STAT_SUCCESS || !response) {
                 snmp_sess_perror("snmpdf", ss);
-                exit(1);
+                goto close_session;
             }
 
             vlp2 = response->variables;
@@ -452,11 +452,15 @@ main(int argc, char *argv[])
 
     if (count == 0) {
         fprintf(stderr, "Failed to locate any partitions.\n");
-        exit(1);
+        goto close_session;
     }
 
+    exit_code = 0;
+
+close_session:
     snmp_close(ss);
-    SOCK_CLEANUP;
-    return 0;
 
+out:
+    SOCK_CLEANUP;
+    return exit_code;
 }                               /* end main() */
diff --git a/apps/snmpget.c b/apps/snmpget.c
index 701f536..a5487c2 100644
--- a/apps/snmpget.c
+++ b/apps/snmpget.c
@@ -117,20 +117,22 @@ main(int argc, char *argv[])
     size_t          name_length;
     int             status;
     int             failures = 0;
-    int             exitval = 0;
+    int             exitval = 1;
 
+    SOCK_STARTUP;
 
     /*
      * get the common command line arguments 
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -138,13 +140,13 @@ main(int argc, char *argv[])
     if (arg >= argc) {
         fprintf(stderr, "Missing object name\n");
         usage();
-        exit(1);
+        goto out;
     }
     if ((argc - arg) > SNMP_MAX_CMDLINE_OIDS) {
         fprintf(stderr, "Too many object identifiers specified. ");
         fprintf(stderr, "Only %d allowed in one request.\n", SNMP_MAX_CMDLINE_OIDS);
         usage();
-        exit(1);
+        goto out;
     }
 
     /*
@@ -153,9 +155,6 @@ main(int argc, char *argv[])
     for (; arg < argc; arg++)
         names[current_name++] = argv[arg];
 
-    SOCK_STARTUP;
-
-
     /*
      * Open an SNMP session.
      */
@@ -165,8 +164,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpget", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
 
@@ -182,12 +180,10 @@ main(int argc, char *argv[])
         } else
             snmp_add_null_var(pdu, name, name_length);
     }
-    if (failures) {
-        snmp_close(ss);
-        SOCK_CLEANUP;
-        exit(1);
-    }
+    if (failures)
+        goto close_session;
 
+    exitval = 0;
 
     /*
      * Perform the request.
@@ -248,8 +244,11 @@ main(int argc, char *argv[])
 
     if (response)
         snmp_free_pdu(response);
+
+close_session:
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return exitval;
-
 }                               /* end main() */
diff --git a/apps/snmpgetnext.c b/apps/snmpgetnext.c
index 7de13f3..7f49851 100644
--- a/apps/snmpgetnext.c
+++ b/apps/snmpgetnext.c
@@ -114,19 +114,22 @@ main(int argc, char *argv[])
     size_t          name_length;
     int             status;
     int             failures = 0;
-    int             exitval = 0;
+    int             exitval = 1;
+
+    SOCK_STARTUP;
 
     /*
      * get the common command line arguments 
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", &optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -134,13 +137,13 @@ main(int argc, char *argv[])
     if (arg >= argc) {
         fprintf(stderr, "Missing object name\n");
         usage();
-        exit(1);
+        goto out;
     }
     if ((argc - arg) > SNMP_MAX_CMDLINE_OIDS) {
         fprintf(stderr, "Too many object identifiers specified. ");
         fprintf(stderr, "Only %d allowed in one request.\n", SNMP_MAX_CMDLINE_OIDS);
         usage();
-        exit(1);
+        goto out;
     }
 
     /*
@@ -149,8 +152,6 @@ main(int argc, char *argv[])
     for (; arg < argc; arg++)
         names[current_name++] = argv[arg];
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -160,8 +161,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpgetnext", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     /*
@@ -177,11 +177,10 @@ main(int argc, char *argv[])
         } else
             snmp_add_null_var(pdu, name, name_length);
     }
-    if (failures) {
-        snmp_close(ss);
-        SOCK_CLEANUP;
-        exit(1);
-    }
+    if (failures)
+        goto close_session;
+
+    exitval = 0;
 
     /*
      * do the request 
@@ -230,7 +229,11 @@ main(int argc, char *argv[])
 
     if (response)
         snmp_free_pdu(response);
+
+close_session:
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmpnetstat/ffs.c b/apps/snmpnetstat/ffs.c
index 5997339..dffd59d 100644
--- a/apps/snmpnetstat/ffs.c
+++ b/apps/snmpnetstat/ffs.c
@@ -5,6 +5,8 @@
  * Written by Dale Rahn.
  */
 
+#include "ffs.h"
+
 /*
  * ffs -- vax ffs instruction
  */
diff --git a/apps/snmpnetstat/ffs.h b/apps/snmpnetstat/ffs.h
new file mode 100644
index 0000000..717d309
--- /dev/null
+++ b/apps/snmpnetstat/ffs.h
@@ -0,0 +1 @@
+int _ffs(int mask);
diff --git a/apps/snmpnetstat/inet.c b/apps/snmpnetstat/inet.c
index 0537340..da140ac 100644
--- a/apps/snmpnetstat/inet.c
+++ b/apps/snmpnetstat/inet.c
@@ -75,8 +75,7 @@ struct stat_table {
     char            description[80];
 };
 
-char	*inetname(struct in_addr *);
-void	inetprint(struct in_addr *, int, const char *, int);
+static char *inetname(struct in_addr *);
 
 	/*
 	 * Print a summary of connections related to
@@ -414,23 +413,23 @@ ip_stats(const char *name)
     oid               ipstats_oid[] = { 1, 3, 6, 1, 2, 1, 4, 0, 0 };
     size_t            ipstats_len   = OID_LENGTH( ipstats_oid );
     struct stat_table ipstats_tbl[] = {
-        { 3, "%14d total datagram%s received"},
-        { 4, "%14d datagram%s with header errors"},
-        { 5, "%14d datagram%s with an invalid destination address"},
-        { 6, "%14d datagram%s forwarded"},
-        { 7, "%14d datagram%s with unknown protocol"},
-        { 8, "%14d datagram%s discarded"},
-        { 9, "%14d datagram%s delivered"},
-        {10, "%14d output datagram request%s"},
-        {11, "%14d output datagram%s discarded"},
-        {12, "%14d datagram%s with no route"},
-        {14, "%14d fragment%s received"},
-        {15, "%14d datagram%s reassembled"},
-        {16, "%14d reassembly failure%s"},
-        {17, "%14d datagram%s fragmented"},
-        {18, "%14d fragmentation failure%s"},
-        {19, "%14d fragment%s created"},
-        {23, "%14d route%s discarded"},
+        { 3, "%14lu total datagram%s received"},
+        { 4, "%14lu datagram%s with header errors"},
+        { 5, "%14lu datagram%s with an invalid destination address"},
+        { 6, "%14lu datagram%s forwarded"},
+        { 7, "%14lu datagram%s with unknown protocol"},
+        { 8, "%14lu datagram%s discarded"},
+        { 9, "%14lu datagram%s delivered"},
+        {10, "%14lu output datagram request%s"},
+        {11, "%14lu output datagram%s discarded"},
+        {12, "%14lu datagram%s with no route"},
+        {14, "%14lu fragment%s received"},
+        {15, "%14lu datagram%s reassembled"},
+        {16, "%14lu reassembly failure%s"},
+        {17, "%14lu datagram%s fragmented"},
+        {18, "%14lu fragmentation failure%s"},
+        {19, "%14lu fragment%s created"},
+        {23, "%14lu route%s discarded"},
         { 0, ""}
     };
 
@@ -447,38 +446,38 @@ icmp_stats(const char *name)
     oid               icmpstats_oid[] = { 1, 3, 6, 1, 2, 1, 5, 0, 0 };
     size_t            icmpstats_len   = OID_LENGTH( icmpstats_oid );
     struct stat_table icmpstats_tbl[] = {
-        { 1, "%14d total message%s received"},
-        { 2, "%14d message%s dropped due to errors"},
-        {14, "%14d ouput message request%s"},
-        {15, "%14d output message%s discarded"},
+        { 1, "%14lu total message%s received"},
+        { 2, "%14lu message%s dropped due to errors"},
+        {14, "%14lu ouput message request%s"},
+        {15, "%14lu output message%s discarded"},
         { 0, ""}
     };
     struct stat_table icmp_inhistogram[] = {
-        { 3, "        Destination unreachable: %d"},
-        { 4, "        Time Exceeded: %d"},
-        { 5, "        Parameter Problem: %d"},
-        { 6, "        Source Quench: %d"},
-        { 7, "        Redirect: %d"},
-        { 8, "        Echo Request: %d"},
-        { 9, "        Echo Reply: %d"},
-        {10, "        Timestamp Request: %d"},
-        {11, "        Timestamp Reply: %d"},
-        {12, "        Address Mask Request: %d"},
-        {13, "        Address Mask Reply: %d"},
+        { 3, "        Destination unreachable: %lu"},
+        { 4, "        Time Exceeded: %lu"},
+        { 5, "        Parameter Problem: %lu"},
+        { 6, "        Source Quench: %lu"},
+        { 7, "        Redirect: %lu"},
+        { 8, "        Echo Request: %lu"},
+        { 9, "        Echo Reply: %lu"},
+        {10, "        Timestamp Request: %lu"},
+        {11, "        Timestamp Reply: %lu"},
+        {12, "        Address Mask Request: %lu"},
+        {13, "        Address Mask Reply: %lu"},
         { 0, ""}
     };
     struct stat_table icmp_outhistogram[] = {
-        {16, "        Destination unreachable: %d"},
-        {17, "        Time Exceeded: %d"},
-        {18, "        Parameter Problem: %d"},
-        {19, "        Source Quench: %d"},
-        {20, "        Redirect: %d"},
-        {21, "        Echo Request: %d"},
-        {22, "        Echo Reply: %d"},
-        {23, "        Timestamp Request: %d"},
-        {24, "        Timestamp Reply: %d"},
-        {25, "        Address Mask Request: %d"},
-        {26, "        Address Mask Reply: %d"},
+        {16, "        Destination unreachable: %lu"},
+        {17, "        Time Exceeded: %lu"},
+        {18, "        Parameter Problem: %lu"},
+        {19, "        Source Quench: %lu"},
+        {20, "        Redirect: %lu"},
+        {21, "        Echo Request: %lu"},
+        {22, "        Echo Reply: %lu"},
+        {23, "        Timestamp Request: %lu"},
+        {24, "        Timestamp Reply: %lu"},
+        {25, "        Address Mask Request: %lu"},
+        {26, "        Address Mask Reply: %lu"},
         {0, ""}
     };
 
@@ -499,16 +498,16 @@ tcp_stats(const char *name)
     oid               tcpstats_oid[] = { 1, 3, 6, 1, 2, 1, 6, 0, 0 };
     size_t            tcpstats_len   = OID_LENGTH( tcpstats_oid );
     struct stat_table tcpstats_tbl[] = {
-        { 5, "%14d active open%s"},
-        { 6, "%14d passive open%s"},
-        { 7, "%14d failed attempt%s"},
-        { 8, "%14d reset%s of established connections"},
-        { 9, "%14d currently established connection%s"},
-        {10, "%14d segment%s received"},
-        {11, "%14d segment%s sent"},
-        {12, "%14d segment%s retransmitted"},
-        {14, "%14d invalid segment%s received"},
-        {15, "%14d reset%s sent"},
+        { 5, "%14lu active open%s"},
+        { 6, "%14lu passive open%s"},
+        { 7, "%14lu failed attempt%s"},
+        { 8, "%14lu reset%s of established connections"},
+        { 9, "%14lu currently established connection%s"},
+        {10, "%14lu segment%s received"},
+        {11, "%14lu segment%s sent"},
+        {12, "%14lu segment%s retransmitted"},
+        {14, "%14lu invalid segment%s received"},
+        {15, "%14lu reset%s sent"},
         { 0, ""}
     };
     _dump_stats( "tcp", tcpstats_oid, tcpstats_len, tcpstats_tbl );
@@ -524,10 +523,10 @@ udp_stats(const char *name)
     oid               udpstats_oid[] = { 1, 3, 6, 1, 2, 1, 7, 0, 0 };
     size_t            udpstats_len   = OID_LENGTH( udpstats_oid );
     struct stat_table udpstats_tbl[] = {
-        {1, "%14d total datagram%s received"},
-        {2, "%14d datagram%s to invalid port"},
-        {3, "%14d datagram%s dropped due to errors"},
-        {4, "%14d output datagram request%s"},
+        {1, "%14lu total datagram%s received"},
+        {2, "%14lu datagram%s to invalid port"},
+        {3, "%14lu datagram%s dropped due to errors"},
+        {4, "%14lu output datagram request%s"},
         {0, ""}
     };
     _dump_stats( "udp", udpstats_oid, udpstats_len, udpstats_tbl );
diff --git a/apps/snmpnetstat/inet6.c b/apps/snmpnetstat/inet6.c
index 7109b87..31c7495 100644
--- a/apps/snmpnetstat/inet6.c
+++ b/apps/snmpnetstat/inet6.c
@@ -79,8 +79,7 @@ struct stat_table {
     char            description[80];
 };
 
-char	*inet6name(const unsigned char *);
-void	inet6print(unsigned char *, int, const char *, int);
+static char *inet6name(const unsigned char *);
 
 /*
  * Print a summary of TCPv6 connections
diff --git a/apps/snmpnetstat/main.c b/apps/snmpnetstat/main.c
index 0e977ad..8b621b2 100644
--- a/apps/snmpnetstat/main.c
+++ b/apps/snmpnetstat/main.c
@@ -32,7 +32,7 @@
 
 #ifndef lint
 char copyright[] =
-"@(#) Copyright (c) 1983, 1988, 1993\n\
+    "@(#) Copyright (c) 1983, 1988, 1993\n\
 	Regents of the University of California.  All rights reserved.\n";
 #endif /* not lint */
 
@@ -87,54 +87,54 @@ int     max_getbulk = 32;  /* specifies the max-repeaters value to use with GETB
 
 char    *progname = NULL;
 const char *pname;
-    /*
-     * struct nlist nl[] - Omitted
-     */
+/*
+ * struct nlist nl[] - Omitted
+ */
 
 typedef void (stringfun)(const char*);
 
 struct protox {
-        /* pr_index/pr_sindex - Omitted */ 
-	int		pr_wanted;	/* 1 if wanted, 0 otherwise */
-	stringfun	*pr_cblocks;	/* control blocks printing routine */
-	stringfun	*pr_stats;	/* statistics printing routine */
-	const char	*pr_name;	/* well-known name */
+    /* pr_index/pr_sindex - Omitted */
+    int		pr_wanted;	/* 1 if wanted, 0 otherwise */
+    stringfun	*pr_cblocks;	/* control blocks printing routine */
+    stringfun	*pr_stats;	/* statistics printing routine */
+    const char	*pr_name;	/* well-known name */
 };
 
 struct protox protox[] = {
-	{ 1,	tcpprotopr,	tcp_stats,	"tcp" },	
-	{ 1,	udpprotopr,	udp_stats,	"udp" },	
+    { 1,	tcpprotopr,	tcp_stats,	"tcp" },
+    { 1,	udpprotopr,	udp_stats,	"udp" },
 
-	{ 1,	(stringfun*)0,	ip_stats,	"ip" },	/* protopr Omitted */
-	{ 1,	(stringfun*)0,	icmp_stats,	"icmp" },
-	/* igmp/ah/esp/ipencap/etherip/ipcomp/carp/pfsync/pim - Omitted */
-	{ 0,	(stringfun*)0,	(stringfun*)0,	NULL }
+    { 1,	(stringfun*)0,	ip_stats,	"ip" },	/* protopr Omitted */
+    { 1,	(stringfun*)0,	icmp_stats,	"icmp" },
+    /* igmp/ah/esp/ipencap/etherip/ipcomp/carp/pfsync/pim - Omitted */
+    { 0,	(stringfun*)0,	(stringfun*)0,	NULL }
 };
 
 struct protox ip6protox[] = {
-	{ 1,	tcp6protopr,	(stringfun*)0,	"tcp6" },
-	{ 1,	udp6protopr,	(stringfun*)0,	"udp6" },
+    { 1,	tcp6protopr,	(stringfun*)0,	"tcp6" },
+    { 1,	udp6protopr,	(stringfun*)0,	"udp6" },
 
-	{ 1,	(stringfun*)0,	ip6_stats,	"ip6" },/* ip6protopr Omitted */
-	{ 1,	(stringfun*)0,	icmp6_stats,	"icmp6" },
-	/* pim6/rip6 - Omitted */
-	{ 0,	(stringfun*)0,	(stringfun*)0,	NULL }
+    { 1,	(stringfun*)0,	ip6_stats,	"ip6" },/* ip6protopr Omitted */
+    { 1,	(stringfun*)0,	icmp6_stats,	"icmp6" },
+    /* pim6/rip6 - Omitted */
+    { 0,	(stringfun*)0,	(stringfun*)0,	NULL }
 };
 
 struct protox ipxprotox[] = {
-	{ 1,	tcpxprotopr,	tcp_stats,	"tcp" },	
-	{ 1,	udpxprotopr,	udp_stats,	"udp" },	
-	{ 1,	(stringfun*)0,	ipx_stats,	"ip" },/* ip6protopr Omitted */
-	{ 1,	(stringfun*)0,	ipx_stats,	"ip6" },/* ip6protopr Omitted */
-	{ 1,	(stringfun*)0,	icmpx_stats,	"icmp" },
-	{ 1,	(stringfun*)0,	icmpx_stats,	"icmp6" },
-	{ 0,	(stringfun*)0,	(stringfun*)0,	NULL }
+    { 1,	tcpxprotopr,	tcp_stats,	"tcp" },
+    { 1,	udpxprotopr,	udp_stats,	"udp" },
+    { 1,	(stringfun*)0,	ipx_stats,	"ip" },/* ip6protopr Omitted */
+    { 1,	(stringfun*)0,	ipx_stats,	"ip6" },/* ip6protopr Omitted */
+    { 1,	(stringfun*)0,	icmpx_stats,	"icmp" },
+    { 1,	(stringfun*)0,	icmpx_stats,	"icmp6" },
+    { 0,	(stringfun*)0,	(stringfun*)0,	NULL }
 };
 
-	/* {ipx,ns,atalk}protox Omitted */
+/* {ipx,ns,atalk}protox Omitted */
 
 struct protox *protoprotox[] = {
-	protox, ip6protox, NULL
+    protox, ip6protox, NULL
 };
 
 static void printproto(struct protox *, const char *);
@@ -152,158 +152,159 @@ optProc( int argc, char *const *argv, int opt )
     case 'C':
         while (*optarg) {
             switch (*optarg++) {
-		case 'a':
-			aflag = 1;
-			break;
-		case 'b':
-			bflag = 1;
-			break;
-		case 'd':
-			dflag = 1;
-			break;
-		case 'f':
-                        if (!*optarg)
-                            optarg = argv[optind++];
-			if (strcmp(optarg, "inet") == 0)
-				af = AF_INET;
-			else if (strcmp(optarg, "inet6") == 0)
-				af = AF_INET6;
-			/*
-			else if (strcmp(optarg, "local") == 0)
-				af = AF_LOCAL;
-			else if (strcmp(optarg, "unix") == 0)
-				af = AF_UNIX;
-			else if (strcmp(optarg, "ipx") == 0)
-				af = AF_IPX;
-			else if (strcmp(optarg, "ns") == 0)
-				af = AF_NS;
-			else if (strcmp(optarg, "encap") == 0)
-				af = PF_KEY;
-			else if (strcmp(optarg, "atalk") == 0)
-				af = AF_APPLETALK;
-			*/
-			else {
-				(void)fprintf(stderr,
-				    "%s: %s: unknown address family\n",
-				    progname, optarg);
-				exit(1);
-			}
-			return;
-		case 'g':
-			gflag = 1;
-			break;
-		case 'I':
-			iflag = 1;
-                        if (!*optarg)
-                            optarg = argv[optind++];
-			intrface = optarg;
-			return;
-		case 'i':
-			iflag = 1;
-			break;
-		case 'L':
-			Lflag = 1;
-			break;
-	    /*  case 'L':		FreeBSD: Display listen queue lengths
-					NetBSD:  Suppress link-level routes */
-	    /*	case 'l':		OpenBSD: Wider IPv6 display
-					Linux:   Listening sockets only
+            case 'a':
+                aflag = 1;
+                break;
+            case 'b':
+                bflag = 1;
+                break;
+            case 'd':
+                dflag = 1;
+                break;
+            case 'f':
+                if (!*optarg)
+                    optarg = argv[optind++];
+                if (strcmp(optarg, "inet") == 0)
+                    af = AF_INET;
+                else if (strcmp(optarg, "inet6") == 0)
+                    af = AF_INET6;
+                /*
+                  else if (strcmp(optarg, "local") == 0)
+                  af = AF_LOCAL;
+                  else if (strcmp(optarg, "unix") == 0)
+                  af = AF_UNIX;
+                  else if (strcmp(optarg, "ipx") == 0)
+                  af = AF_IPX;
+                  else if (strcmp(optarg, "ns") == 0)
+                  af = AF_NS;
+                  else if (strcmp(optarg, "encap") == 0)
+                  af = PF_KEY;
+                  else if (strcmp(optarg, "atalk") == 0)
+                  af = AF_APPLETALK;
+                */
+                else {
+                    (void)fprintf(stderr,
+                                  "%s: %s: unknown address family\n",
+                                  progname, optarg);
+                    exit(1);
+                }
+                return;
+            case 'g':
+                gflag = 1;
+                break;
+            case 'I':
+                iflag = 1;
+                if (!*optarg)
+                    optarg = argv[optind++];
+                intrface = optarg;
+                return;
+            case 'i':
+                iflag = 1;
+                break;
+            case 'L':
+                Lflag = 1;
+                break;
+                /*  case 'L':		FreeBSD: Display listen queue lengths
+                    NetBSD:  Suppress link-level routes */
+                /*	case 'l':		OpenBSD: Wider IPv6 display
+                        Linux:   Listening sockets only
 			lflag = 1;
 			break;
-		case 'M':		*BSD:    Memory image
-					Linux:   Masqueraded connections
+                        case 'M':		*BSD:    Memory image
+                        Linux:   Masqueraded connections
 			memf = optarg;
 			break;
-	     */
-		case 'm':
-			mflag = 1;
-			break;
-	    /*	case 'N':		*BSD:    Kernel image
+                */
+            case 'm':
+                mflag = 1;
+                break;
+                /*	case 'N':		*BSD:    Kernel image
 			nlistf = optarg;
 			break;
-	     */
-		case 'n':
-			nflag = 1;
-			break;
-		case 'o':
-			oflag = 1;
-			break;
-	    /*  case 'P':		NetBSD:
-					OpenBSD: dump PCB block */
-		case 'p':
-                        if (!*optarg)
-                            optarg = argv[optind++];
-			if ((tp = name2protox(optarg)) == NULL) {
-				(void)fprintf(stderr,
-				    "%s: %s: unknown protocol\n",
-				    progname, optarg);
-				exit(1);
-			}
-			pflag = 1;
-			pname = tp->pr_name;
-			return;
-	    /*	case 'q':		NetBSD:  IRQ information
-					OpenBSD: Suppress inactive I/Fs
+                */
+            case 'n':
+                nflag = 1;
+                break;
+            case 'o':
+                oflag = 1;
+                break;
+                /*  case 'P':		NetBSD:
+                    OpenBSD: dump PCB block */
+            case 'p':
+                if (!*optarg)
+                    optarg = argv[optind++];
+                if ((tp = name2protox(optarg)) == NULL) {
+                    (void)fprintf(stderr,
+                                  "%s: %s: unknown protocol\n",
+                                  progname, optarg);
+                    exit(1);
+                }
+                pflag = 1;
+                pname = tp->pr_name;
+                return;
+                /*	case 'q':		NetBSD:  IRQ information
+                        OpenBSD: Suppress inactive I/Fs
 			qflag = 1;
 			break;
-	     */
-		case 'r':
-			rflag = 1;
-			break;
-		case 'R':
-                        if (optind < argc) {
-                            if (argv[optind]) {
-                                max_getbulk = atoi(argv[optind]);
-                                if (max_getbulk == 0) {
-                                    usage();
-                                    fprintf(stderr, "Bad -CR option: %s\n", 
-                                            argv[optind]);
-                                    exit(1);
-                                }
-                            }
-                        } else {
+                */
+            case 'r':
+                rflag = 1;
+                break;
+            case 'R':
+                if (optind < argc) {
+                    if (argv[optind]) {
+                        max_getbulk = atoi(argv[optind]);
+                        if (max_getbulk == 0) {
                             usage();
-                            fprintf(stderr, "Bad -CR option: no argument given\n");
+                            fprintf(stderr, "Bad -CR option: %s\n",
+                                    argv[optind]);
                             exit(1);
                         }
-                        optind++;
-                        break;
-		case 'S':	     /* FreeBSD:
-					NetBSD:  Semi-numeric display
-					OpenBSD: Show route source selector */
-			Sflag = 1;
-			break;
-		case 's':
-			++sflag;
-			break;
-	     /*	case 't':		FreeBSD:
-					OpenBSD: Display watchdog timers
+                    }
+                } else {
+                    usage();
+                    fprintf(stderr, "Bad -CR option: no argument given\n");
+                    exit(1);
+                }
+                optind++;
+                break;
+            case 'S':	     /* FreeBSD:
+                                NetBSD:  Semi-numeric display
+                                OpenBSD: Show route source selector */
+                Sflag = 1;
+                break;
+            case 's':
+                ++sflag;
+                break;
+                /*	case 't':		FreeBSD:
+                        OpenBSD: Display watchdog timers
 			tflag = 1;
 			break;
-		case 'u':		OpenBSD: unix sockets only
+                        case 'u':		OpenBSD: unix sockets only
 			af = AF_UNIX;
 			break;
-	      */
-		case 'v':
-			vflag = 1;
-			break;
-		case 'w':
-                        if (!*optarg)
-                            optarg = argv[optind++];
-			interval = atoi(optarg);
-			iflag = 1;
-			return;
-		case '?':
-		default:
-			usage();
+                */
+            case 'v':
+                vflag = 1;
+                break;
+            case 'w':
+                if (!*optarg)
+                    optarg = argv[optind++];
+                interval = atoi(optarg);
+                iflag = 1;
+                return;
+            case '?':
+            default:
+                usage();
+                exit(1);
             }
         }
         break;   /* End of '-Cx' switch */
 
-    /*
-     *  Backward compatability for the main display modes
-     *    (where this doesn't clash with standard SNMP flags)
-     */
+        /*
+         *  Backward compatability for the main display modes
+         *    (where this doesn't clash with standard SNMP flags)
+         */
     case 'i':
 	iflag = 1;
 	break;
@@ -319,160 +320,172 @@ optProc( int argc, char *const *argv, int opt )
 int
 main(int argc, char *argv[])
 {
-	netsnmp_session session;
-	struct protoent *p;
-        char *cp;
-
-	af = AF_UNSPEC;
-        cp = strrchr( argv[0], '/' );
-        if (cp)
-            progname = cp+1;
-        else
-            progname = argv[0];
-
-	switch (snmp_parse_args( argc, argv, &session, "C:iRs", optProc)) {
-	case NETSNMP_PARSE_ARGS_ERROR:
-	    exit(1);
-	case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-	    exit(0);
-	case NETSNMP_PARSE_ARGS_ERROR_USAGE:
-	    usage();
-	    exit(1);
-	default:
-	    break;
-	}
-
-	    /*
-	     * Check argc vs optind ??
-	     */
-	argv += optind;
-	argc -= optind;
+    netsnmp_session session;
+    struct protoent *p;
+    char *cp;
+    int exit_code = 1;
+
+    SOCK_STARTUP;
+
+    af = AF_UNSPEC;
+    cp = strrchr( argv[0], '/' );
+    if (cp)
+        progname = cp+1;
+    else
+        progname = argv[0];
+
+    switch (snmp_parse_args( argc, argv, &session, "C:iRs", optProc)) {
+    case NETSNMP_PARSE_ARGS_ERROR:
+        goto out;
+    case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
+        exit_code = 0;
+        goto out;
+    case NETSNMP_PARSE_ARGS_ERROR_USAGE:
+        usage();
+        goto out;
+    default:
+        break;
+    }
+
+    /*
+     * Check argc vs optind ??
+     */
+    argv += optind;
+    argc -= optind;
 
     /*
      * Open an SNMP session.
      */
-    SOCK_STARTUP;
     ss = snmp_open(&session);
     if (ss == NULL) {
         /*
-         * diagnose snmp_open errors with the input netsnmp_session pointer 
+         * diagnose snmp_open errors with the input netsnmp_session pointer
          */
         snmp_sess_perror("snmpnetstat", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
-	/*
-	 * Omitted:
-	 *     Privilege handling
-	 *    "Backward Compatibility"
-	 *     Kernel namelis handling
-	 */
+    /*
+     * Omitted:
+     *     Privilege handling
+     *    "Backward Compatibility"
+     *     Kernel namelis handling
+     */
 
 #if 0
-	if (mflag) {
-            /*
-		mbpr(nl[N_MBSTAT].n_value, nl[N_MBPOOL].n_value,
-		    nl[N_MCLPOOL].n_value);
-             */
-		exit(0);
-	}
-	if (pflag) {
-		printproto(tp, tp->pr_name);
-		exit(0);
-	}
-#endif
-	/*
-	 * Keep file descriptors open to avoid overhead
-	 * of open/close on each call to get* routines.
-	 */
-	sethostent(1);
-	setnetent(1);
-	if (iflag) {
-		intpr(interval);
-		exit(0);
-	}
-	if (rflag) {
-             /*
-		if (sflag)
-			rt_stats();
-		else
-              */
-		if (Lflag || routexpr(af) == 0) {
-		    if (route4pr(af) == 0 && af == AF_INET) routepr();
-		    route6pr(af);
-		}
-		exit(0);
-	}
-     /*
-	if (gflag) {
-		if (sflag) {
-			if (af == AF_INET || af == AF_UNSPEC)
-				mrt_stats(nl[N_MRTPROTO].n_value,
-				    nl[N_MRTSTAT].n_value);
-#ifdef NETSNMP_ENABLE_IPV6
-			if (af == AF_INET6 || af == AF_UNSPEC)
-				mrt6_stats(nl[N_MRT6PROTO].n_value,
-				    nl[N_MRT6STAT].n_value);
-#endif
-		}
-		else {
-			if (af == AF_INET || af == AF_UNSPEC)
-				mroutepr(nl[N_MRTPROTO].n_value,
-				    nl[N_MFCHASHTBL].n_value,
-				    nl[N_MFCHASH].n_value,
-				    nl[N_VIFTABLE].n_value);
-#ifdef NETSNMP_ENABLE_IPV6
-			if (af == AF_INET6 || af == AF_UNSPEC)
-				mroute6pr(nl[N_MRT6PROTO].n_value,
-				    nl[N_MF6CTABLE].n_value,
-				    nl[N_MIF6TABLE].n_value);
+    if (mflag) {
+        /*
+          mbpr(nl[N_MBSTAT].n_value, nl[N_MBPOOL].n_value,
+          nl[N_MCLPOOL].n_value);
+        */
+        exit_code = 0;
+        goto out;
+    }
+    if (pflag) {
+        printproto(tp, tp->pr_name);
+        exit_code = 0;
+        goto out;
+    }
 #endif
-		}
-		exit(0);
-	}
+    /*
+     * Keep file descriptors open to avoid overhead
+     * of open/close on each call to get* routines.
      */
-	setservent(1);
-        if (Lflag) {
-            switch (af) {
-            case AF_UNSPEC:
-		setprotoent(1);
-		/* ugh, this is O(MN) ... why do we do this? */
-		while ((p = getprotoent())) {
-			for (tp = protox; tp->pr_name; tp++)
-				if (strcmp(tp->pr_name, p->p_name) == 0)
-					if (tp->pr_name && tp->pr_wanted)
-					    printproto(tp, p->p_name);
-		}
-		endprotoent();
-                break;
-            case AF_INET:
-                    for (tp = protox; tp->pr_name; tp++)
-                            printproto(tp, tp->pr_name);
-            case AF_INET6:
-                    for (tp = ip6protox; tp->pr_name; tp++)
-                            printproto(tp, tp->pr_name);
+    sethostent(1);
+    setnetent(1);
+    if (iflag) {
+        intpr(interval);
+        exit_code = 0;
+        goto out;
+    }
+    if (rflag) {
+        /*
+          if (sflag)
+          rt_stats();
+          else
+        */
+        if (Lflag || routexpr(af) == 0) {
+            if (route4pr(af) == 0 && af == AF_INET) routepr();
+            route6pr(af);
+        }
+        exit_code = 0;
+        goto out;
+    }
+    /*
+      if (gflag) {
+      if (sflag) {
+      if (af == AF_INET || af == AF_UNSPEC)
+      mrt_stats(nl[N_MRTPROTO].n_value,
+      nl[N_MRTSTAT].n_value);
+      #ifdef NETSNMP_ENABLE_IPV6
+      if (af == AF_INET6 || af == AF_UNSPEC)
+      mrt6_stats(nl[N_MRT6PROTO].n_value,
+      nl[N_MRT6STAT].n_value);
+      #endif
+      }
+      else {
+      if (af == AF_INET || af == AF_UNSPEC)
+      mroutepr(nl[N_MRTPROTO].n_value,
+      nl[N_MFCHASHTBL].n_value,
+      nl[N_MFCHASH].n_value,
+      nl[N_VIFTABLE].n_value);
+      #ifdef NETSNMP_ENABLE_IPV6
+      if (af == AF_INET6 || af == AF_UNSPEC)
+      mroute6pr(nl[N_MRT6PROTO].n_value,
+      nl[N_MF6CTABLE].n_value,
+      nl[N_MIF6TABLE].n_value);
+      #endif
+      }
+      exit_code = 0;
+      goto out;
+      }
+    */
+    setservent(1);
+    if (Lflag) {
+        switch (af) {
+        case AF_UNSPEC:
+            setprotoent(1);
+            /* ugh, this is O(MN) ... why do we do this? */
+            while ((p = getprotoent())) {
+                for (tp = protox; tp->pr_name; tp++)
+                    if (strcmp(tp->pr_name, p->p_name) == 0)
+                        if (tp->pr_name && tp->pr_wanted)
+                            printproto(tp, p->p_name);
             }
-	}
-        else {
-	    for (tp = ipxprotox; tp->pr_name; tp++)
-		if (!pname || strcmp(pname,tp->pr_name) == 0)
-		    printproto(tp, pname);
-	}
+            endprotoent();
+            break;
+        case AF_INET:
+            for (tp = protox; tp->pr_name; tp++)
+                printproto(tp, tp->pr_name);
+        case AF_INET6:
+            for (tp = ip6protox; tp->pr_name; tp++)
+                printproto(tp, tp->pr_name);
+        }
+    }
+    else {
+        for (tp = ipxprotox; tp->pr_name; tp++)
+            if (!pname || strcmp(pname,tp->pr_name) == 0)
+                printproto(tp, pname);
+    }
     /*
-	if (af == AF_IPX || af == AF_UNSPEC)
-		for (tp = ipxprotox; tp->pr_name; tp++)
-			printproto(tp, tp->pr_name);
-	if (af == AF_NS || af == AF_UNSPEC)
-		for (tp = nsprotox; tp->pr_name; tp++)
-			printproto(tp, tp->pr_name);
-	if ((af == AF_UNIX || af == AF_UNSPEC) && !sflag)
-		unixpr(nl[N_UNIXSW].n_value);
-	if (af == AF_APPLETALK || af == AF_UNSPEC)
-		for (tp = atalkprotox; tp->pr_name; tp++)
-			printproto(tp, tp->pr_name);
-     */
-	exit(0);
+      if (af == AF_IPX || af == AF_UNSPEC)
+      for (tp = ipxprotox; tp->pr_name; tp++)
+      printproto(tp, tp->pr_name);
+      if (af == AF_NS || af == AF_UNSPEC)
+      for (tp = nsprotox; tp->pr_name; tp++)
+      printproto(tp, tp->pr_name);
+      if ((af == AF_UNIX || af == AF_UNSPEC) && !sflag)
+      unixpr(nl[N_UNIXSW].n_value);
+      if (af == AF_APPLETALK || af == AF_UNSPEC)
+      for (tp = atalkprotox; tp->pr_name; tp++)
+      printproto(tp, tp->pr_name);
+    */
+
+    exit_code = 0;
+
+out:
+    SOCK_CLEANUP;
+    return exit_code;
 }
 
 /*
@@ -482,15 +495,15 @@ main(int argc, char *argv[])
 static void
 printproto(struct protox *tp, const char *name)
 {
-	void (*pr)(const char *);
-
-	if (sflag) {
-		pr = tp->pr_stats;
-	} else {
-		pr = tp->pr_cblocks;
-	}
-	if (pr != NULL)
-		(*pr)(name);
+    void (*pr)(const char *);
+
+    if (sflag) {
+        pr = tp->pr_stats;
+    } else {
+        pr = tp->pr_cblocks;
+    }
+    if (pr != NULL)
+        (*pr)(name);
 }
 
 /*
@@ -500,7 +513,7 @@ printproto(struct protox *tp, const char *name)
 const char *
 plural(int n)
 {
-	return (n != 1 ? "s" : "");
+    return (n != 1 ? "s" : "");
 }
 
 /*
@@ -509,13 +522,13 @@ plural(int n)
 static struct protox *
 knownname(const char *name)
 {
-	struct protox **tpp, *tp;
+    struct protox **tpp, *tp;
 
-	for (tpp = protoprotox; *tpp; tpp++)
-		for (tp = *tpp; tp->pr_name; tp++)
-			if (strcmp(tp->pr_name, name) == 0)
-				return (tp);
-	return (NULL);
+    for (tpp = protoprotox; *tpp; tpp++)
+        for (tp = *tpp; tp->pr_name; tp++)
+            if (strcmp(tp->pr_name, name) == 0)
+                return (tp);
+    return (NULL);
 }
 
 /*
@@ -524,40 +537,39 @@ knownname(const char *name)
 static struct protox *
 name2protox(const char *name)
 {
-	struct protox *tp;
-	char **alias;			/* alias from p->aliases */
-	struct protoent *p;
-
-	/*
-	 * Try to find the name in the list of "well-known" names. If that
-	 * fails, check if name is an alias for an Internet protocol.
-	 */
-	if ((tp = knownname(name)))
-		return (tp);
-
-	setprotoent(1);			/* make protocol lookup cheaper */
-	while ((p = getprotoent())) {
-		/* netsnmp_assert: name not same as p->name */
-		for (alias = p->p_aliases; *alias; alias++)
-			if (strcmp(name, *alias) == 0) {
-				endprotoent();
-				return (knownname(p->p_name));
-			}
-	}
-	endprotoent();
-	return (NULL);
+    struct protox *tp;
+    char **alias;			/* alias from p->aliases */
+    struct protoent *p;
+
+    /*
+     * Try to find the name in the list of "well-known" names. If that
+     * fails, check if name is an alias for an Internet protocol.
+     */
+    if ((tp = knownname(name)))
+        return (tp);
+
+    setprotoent(1);			/* make protocol lookup cheaper */
+    while ((p = getprotoent())) {
+        /* netsnmp_assert: name not same as p->name */
+        for (alias = p->p_aliases; *alias; alias++)
+            if (strcmp(name, *alias) == 0) {
+                endprotoent();
+                return (knownname(p->p_name));
+            }
+    }
+    endprotoent();
+    return (NULL);
 }
 
 static void
 usage(void)
 {
-	(void)fprintf(stderr,
-"usage: %s [snmp_opts] [-Canv] [-Cf address_family]\n", progname);
-	(void)fprintf(stderr,
-"       %s [snmp_opts] [-Cibodnv] [-CI interface] [-Cw wait]\n", progname);
-	(void)fprintf(stderr,
-"       %s [snmp_opts] [-Cs[s]] [-Cp protocol]\n", progname);
-	(void)fprintf(stderr,
-"       %s [snmp_opts] [-Crnv] [-Cf address_family]\n", progname);
-	exit(1);
+    (void)fprintf(stderr,
+                  "usage: %s [snmp_opts] [-Canv] [-Cf address_family]\n", progname);
+    (void)fprintf(stderr,
+                  "       %s [snmp_opts] [-Cibodnv] [-CI interface] [-Cw wait]\n", progname);
+    (void)fprintf(stderr,
+                  "       %s [snmp_opts] [-Cs[s]] [-Cp protocol]\n", progname);
+    (void)fprintf(stderr,
+                  "       %s [snmp_opts] [-Crnv] [-Cf address_family]\n", progname);
 }
diff --git a/apps/snmpnetstat/route.c b/apps/snmpnetstat/route.c
index 1dba74d..753916b 100644
--- a/apps/snmpnetstat/route.c
+++ b/apps/snmpnetstat/route.c
@@ -68,6 +68,7 @@ static char *rcsid = "$OpenBSD: route.c,v 1.66 2004/11/17 01:47:20 itojun Exp $"
 
 #include "main.h"
 #include "netstat.h"
+#include "ffs.h"
 #if HAVE_WINSOCK_H
 #include "winstub.h"
 #endif
@@ -92,7 +93,6 @@ struct route_entry {
 };
 
 void p_rtnode( struct route_entry *rp );
-extern int _ffs(int mask);
 
 /*
  * Print routing tables.
diff --git a/apps/snmpnetstat/winstub.c b/apps/snmpnetstat/winstub.c
index 5e2dd64..13bfe99 100644
--- a/apps/snmpnetstat/winstub.c
+++ b/apps/snmpnetstat/winstub.c
@@ -29,7 +29,15 @@
 #include <netinet/in.h>
 #endif
 #if HAVE_NETDB_H
+#ifdef cygwin
+#define getnetent cygwin_getnetent
+#define getnetbyaddr cygwin_getnetbyaddr
+#endif
 #include <netdb.h>
+#ifdef cygwin
+#undef getnetent
+#undef getnetbyaddr
+#endif
 #endif
 
 static int      h_stay_open, s_stay_open, p_stay_open, n_stay_open;
diff --git a/apps/snmpset.c b/apps/snmpset.c
index 1b29a6c..a2374bc 100644
--- a/apps/snmpset.c
+++ b/apps/snmpset.c
@@ -127,7 +127,9 @@ main(int argc, char *argv[])
     size_t          name_length;
     int             status;
     int             failures = 0;
-    int             exitval = 0;
+    int             exitval = 1;
+
+    SOCK_STARTUP;
 
     putenv(strdup("POSIXLY_CORRECT=1"));
 
@@ -136,12 +138,13 @@ main(int argc, char *argv[])
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -149,13 +152,13 @@ main(int argc, char *argv[])
     if (arg >= argc) {
         fprintf(stderr, "Missing object name\n");
         usage();
-        exit(1);
+        goto out;
     }
     if ((argc - arg) > 3*SNMP_MAX_CMDLINE_OIDS) {
         fprintf(stderr, "Too many assignments specified. ");
         fprintf(stderr, "Only %d allowed in one request.\n", SNMP_MAX_CMDLINE_OIDS);
         usage();
-        exit(1);
+        goto out;
     }
 
     /*
@@ -190,22 +193,20 @@ main(int argc, char *argv[])
             default:
                 fprintf(stderr, "%s: Bad object type: %c\n", argv[arg - 1],
                         *argv[arg]);
-                exit(1);
+                goto out;
             }
         } else {
             fprintf(stderr, "%s: Needs type and value\n", argv[arg - 1]);
-            exit(1);
+            goto out;
         }
         if (arg < argc)
             values[current_value++] = argv[arg];
         else {
             fprintf(stderr, "%s: Needs value\n", argv[arg - 2]);
-            exit(1);
+            goto out;
         }
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -215,8 +216,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpset", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     /*
@@ -236,11 +236,10 @@ main(int argc, char *argv[])
         }
     }
 
-    if (failures) {
-        snmp_close(ss);
-        SOCK_CLEANUP;
-        exit(1);
-    }
+    if (failures)
+        goto close_session;
+
+    exitval = 0;
 
     /*
      * do the request 
@@ -278,7 +277,11 @@ main(int argc, char *argv[])
 
     if (response)
         snmp_free_pdu(response);
+
+close_session:
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmpstatus.c b/apps/snmpstatus.c
index 0443c4d..d2f6504 100644
--- a/apps/snmpstatus.c
+++ b/apps/snmpstatus.c
@@ -147,25 +147,26 @@ main(int argc, char *argv[])
     char            buf[40];
     int             interfaces;
     int             count;
-    int             exitval = 0;
+    int             exitval = 1;
+
+    SOCK_STARTUP;
 
     /*
      * get the common command line arguments 
      */
     switch (snmp_parse_args(argc, argv, &session, "C:", &optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -175,8 +176,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpstatus", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     /*
@@ -251,14 +251,15 @@ main(int argc, char *argv[])
     } else if (status == STAT_TIMEOUT) {
         fprintf(stderr, "Timeout: No Response from %s\n",
                 session.peername);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     } else {                    /* status == STAT_ERROR */
         snmp_sess_perror("snmpstatus", ss);
-        SOCK_CLEANUP;
-        exit(2);
+        exitval = 2;
+        goto out;
     }
 
+    exitval = 0;
+
     transport = snmp_sess_transport(snmp_sess_pointer(ss));
     if (transport != NULL && transport->f_fmtaddr != NULL) {
         char *addr_string = transport->f_fmtaddr(transport,
@@ -306,30 +307,38 @@ main(int argc, char *argv[])
                         continue;
                     }
                     if (vars->name_length >= length_ifOperStatus
-                        && !memcmp(objid_ifOperStatus, vars->name,
-                                   sizeof(objid_ifOperStatus))) {
+                            && !memcmp(objid_ifOperStatus, vars->name,
+                                    sizeof(objid_ifOperStatus))
+                            && vars->type == ASN_INTEGER
+                            && vars->val.integer) {
                         if (*vars->val.integer != MIB_IFSTATUS_UP)
                             down_interfaces++;
                         snmp_add_null_var(pdu, vars->name,
                                           vars->name_length);
                         good_var++;
-                    } else if (vars->name_length >= length_ifInUCastPkts &&
-                               !memcmp(objid_ifInUCastPkts, vars->name,
-                                       sizeof(objid_ifInUCastPkts))) {
+                    } else if (vars->name_length >= length_ifInUCastPkts
+                            &&!memcmp(objid_ifInUCastPkts, vars->name,
+                                    sizeof(objid_ifInUCastPkts))
+                            && vars->type == ASN_COUNTER
+                            && vars->val.integer) {
                         ipackets += *vars->val.integer;
                         snmp_add_null_var(pdu, vars->name,
                                           vars->name_length);
                         good_var++;
                     } else if (vars->name_length >= length_ifInNUCastPkts
                                && !memcmp(objid_ifInNUCastPkts, vars->name,
-                                          sizeof(objid_ifInNUCastPkts))) {
+                                          sizeof(objid_ifInNUCastPkts))
+                               && vars->type == ASN_COUNTER
+                               && vars->val.integer) {
                         ipackets += *vars->val.integer;
                         snmp_add_null_var(pdu, vars->name,
                                           vars->name_length);
                         good_var++;
                     } else if (vars->name_length >= length_ifOutUCastPkts
                                && !memcmp(objid_ifOutUCastPkts, vars->name,
-                                          sizeof(objid_ifOutUCastPkts))) {
+                                          sizeof(objid_ifOutUCastPkts))
+                               && vars->type == ASN_COUNTER
+                               && vars->val.integer) {
                         opackets += *vars->val.integer;
                         snmp_add_null_var(pdu, vars->name,
                                           vars->name_length);
@@ -337,7 +346,9 @@ main(int argc, char *argv[])
                     } else if (vars->name_length >= length_ifOutNUCastPkts
                                && !memcmp(objid_ifOutNUCastPkts,
                                           vars->name,
-                                          sizeof(objid_ifOutNUCastPkts))) {
+                                          sizeof(objid_ifOutNUCastPkts))
+                               && vars->type == ASN_COUNTER
+                               && vars->val.integer) {
                         opackets += *vars->val.integer;
                         snmp_add_null_var(pdu, vars->name,
                                           vars->name_length);
@@ -381,6 +392,8 @@ main(int argc, char *argv[])
     }
 
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmptable.c b/apps/snmptable.c
index c9c7d26..7d914d0 100644
--- a/apps/snmptable.c
+++ b/apps/snmptable.c
@@ -93,7 +93,7 @@ static size_t   name_length;
 static oid      root[MAX_OID_LEN];
 static size_t   rootlen;
 static int      localdebug;
-static int      exitval = 0;
+static int      exitval = 1;
 static int      use_getbulk = 1;
 static int      max_getbulk = 10;
 static int      extra_columns = 0;
@@ -250,6 +250,8 @@ main(int argc, char *argv[])
     netsnmp_session session, *ss;
     int            total_entries = 0;
 
+    SOCK_STARTUP;
+
     netsnmp_set_line_buffering(stdout);
 
     netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
@@ -260,12 +262,13 @@ main(int argc, char *argv[])
      */
     switch (snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -279,13 +282,13 @@ main(int argc, char *argv[])
     if (optind + 1 != argc) {
         fprintf(stderr, "Must have exactly one table name\n");
         usage();
-        exit(1);
+        goto out;
     }
 
     rootlen = MAX_OID_LEN;
     if (!snmp_parse_oid(argv[optind], root, &rootlen)) {
         snmp_perror(argv[optind]);
-        exit(1);
+        goto out;
     }
     localdebug = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
                                         NETSNMP_DS_LIB_DUMP_PACKET);
@@ -296,15 +299,13 @@ main(int argc, char *argv[])
     /*
      * open an SNMP session 
      */
-    SOCK_STARTUP;
     ss = snmp_open(&session);
     if (ss == NULL) {
         /*
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmptable", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
 #ifndef NETSNMP_DISABLE_SNMPV1
@@ -312,6 +313,8 @@ main(int argc, char *argv[])
         use_getbulk = 0;
 #endif
 
+    exitval = 0;
+
     do {
         entries = 0;
         allocated = 0;
@@ -322,11 +325,8 @@ main(int argc, char *argv[])
                 get_table_entries(ss);
         }
 
-        if (exitval) {
-            snmp_close(ss);
-            SOCK_CLEANUP;
-            return exitval;
-        }
+        if (exitval)
+            goto close_session;
 
         if (entries || headers_only)
             print_table();
@@ -345,15 +345,19 @@ main(int argc, char *argv[])
 
     } while (!end_of_table);
 
-    snmp_close(ss);
-    SOCK_CLEANUP;
-
     if (total_entries == 0)
         printf("%s: No entries\n", table_name);
     if (extra_columns)
 	printf("%s: WARNING: More columns on agent than in MIB\n", table_name);
 
-    return 0;
+    exitval = 0;
+
+close_session:
+    snmp_close(ss);
+
+out:
+    SOCK_CLEANUP;
+    return exitval;
 }
 
 void
diff --git a/apps/snmptest.c b/apps/snmptest.c
index 24de47b..b10cb6e 100644
--- a/apps/snmptest.c
+++ b/apps/snmptest.c
@@ -68,7 +68,7 @@ SOFTWARE.
 
 int             command = SNMP_MSG_GET;
 
-int             input_variable(netsnmp_variable_list *);
+static int      input_variable(netsnmp_variable_list *);
 
 void
 usage(void)
@@ -87,27 +87,29 @@ main(int argc, char *argv[])
     netsnmp_variable_list *vars, *vp;
     netsnmp_transport *transport = NULL;
     int             ret;
+    int             exit_code = 1;
     int             status, count;
     char            input[128];
     int             varcount, nonRepeaters = -1, maxRepetitions;
 
+    SOCK_STARTUP;
+
     /*
      * get the common command line arguments 
      */
     switch (snmp_parse_args(argc, argv, &session, NULL, NULL)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exit_code = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -117,8 +119,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmptest", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     varcount = 0;
@@ -165,8 +166,8 @@ main(int argc, char *argv[])
                         fflush(stdout);
                         if (!fgets(input, sizeof(input), stdin)) {
                             printf("Quitting,  Goodbye\n");
-                            SOCK_CLEANUP;
-                            exit(0);
+                            exit_code = 0;
+                            goto out;
                         }
                         maxRepetitions = atoi(input);
                         pdu->non_repeaters = nonRepeaters;
@@ -279,6 +280,10 @@ main(int argc, char *argv[])
         nonRepeaters = -1;
     }
     /* NOTREACHED */
+
+out:
+    SOCK_CLEANUP;
+    return exit_code;
 }
 
 int
diff --git a/apps/snmptranslate.c b/apps/snmptranslate.c
index 2b19777..87516ab 100644
--- a/apps/snmptranslate.c
+++ b/apps/snmptranslate.c
@@ -103,7 +103,6 @@ usage(void)
     fprintf(stderr,
             "  -L LOGOPTS\t\tToggle various defaults controlling logging:\n");
     snmp_log_options_usage("\t\t\t  ", stderr);
-    exit(1);
 }
 
 int
@@ -117,15 +116,20 @@ main(int argc, char *argv[])
     int             print = 0;
     int             find_all = 0;
     int             width = 1000000;
+    int             exit_code = 1;
+    netsnmp_session dummy;
+
+    SOCK_STARTUP;
 
     /*
      * usage: snmptranslate name
      */
+    snmp_sess_init(&dummy);
     while ((arg = getopt(argc, argv, "Vhm:M:w:D:P:T:O:I:L:")) != EOF) {
         switch (arg) {
         case 'h':
             usage();
-            exit(1);
+            goto out;
 
         case 'm':
             setenv("MIBS", optarg, 1);
@@ -140,13 +144,14 @@ main(int argc, char *argv[])
         case 'V':
             fprintf(stderr, "NET-SNMP version: %s\n",
                     netsnmp_get_version());
-            exit(0);
+            exit_code = 0;
+            goto out;
             break;
         case 'w':
 	    width = atoi(optarg);
 	    if (width <= 0) {
 		fprintf(stderr, "Invalid width specification: %s\n", optarg);
-		exit (1);
+		goto out;
 	    }
 	    break;
 #ifndef NETSNMP_DISABLE_MIB_LOADING
@@ -155,7 +160,7 @@ main(int argc, char *argv[])
             if (cp != NULL) {
                 fprintf(stderr, "Unknown parser option to -P: %c.\n", *cp);
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
@@ -164,7 +169,7 @@ main(int argc, char *argv[])
             if (cp != NULL) {
                 fprintf(stderr, "Unknown OID option to -O: %c.\n", *cp);
                 usage();
-                exit(1);
+                goto out;
             }
             break;
         case 'I':
@@ -172,7 +177,7 @@ main(int argc, char *argv[])
             if (cp != NULL) {
                 fprintf(stderr, "Unknown OID option to -I: %c.\n", *cp);
                 usage();
-                exit(1);
+                goto out;
             }
             break;
         case 'T':
@@ -218,25 +223,23 @@ main(int argc, char *argv[])
                     fprintf(stderr, "Invalid -T<lostpad> character: %c\n",
                             *cp);
                     usage();
-                    exit(1);
-                    break;
+                    goto out;
                 }
             }
             break;
         case 'L':
-            if (snmp_log_options(optarg, argc, argv) < 0) {
-                return (-1);
-            }
+            if (snmp_log_options(optarg, argc, argv) < 0)
+                goto out;
             break;
         default:
             fprintf(stderr, "invalid option: -%c\n", arg);
             usage();
-            exit(1);
-            break;
+            goto out;
         }
     }
 
-    init_snmp("snmpapp");
+    init_snmp(NETSNMP_APPLICATION_CONFIG_TYPE);
+
     if (optind < argc)
         current_name = argv[optind];
 
@@ -244,7 +247,7 @@ main(int argc, char *argv[])
         switch (print) {
         default:
             usage();
-            exit(1);
+            goto out;
 #ifndef NETSNMP_DISABLE_MIB_LOADING
         case 1:
             print_mib_tree(stdout, get_tree_head(), width);
@@ -257,7 +260,8 @@ main(int argc, char *argv[])
             break;
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
         }
-        exit(0);
+        exit_code = 0;
+        goto out;
     }
 
     do {
@@ -269,7 +273,8 @@ main(int argc, char *argv[])
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
                 fprintf(stderr, "Unknown object identifier: %s\n",
                         current_name);
-                exit(2);
+                exit_code = 2;
+                goto out;
 #ifndef NETSNMP_DISABLE_MIB_LOADING
             }
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
@@ -280,9 +285,9 @@ main(int argc, char *argv[])
                 fprintf(stderr,
                         "Unable to find a matching object identifier for \"%s\"\n",
                         current_name);
-                exit(1);
+                goto out;
             }
-            exit(0);
+            break;
         } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
 					  NETSNMP_DS_LIB_REGEX_ACCESS)) {
 #ifndef NETSNMP_DISABLE_MIB_LOADING
@@ -291,14 +296,15 @@ main(int argc, char *argv[])
                 fprintf(stderr,
                         "Unable to find a matching object identifier for \"%s\"\n",
                         current_name);
-                exit(1);
+                goto out;
 #ifndef NETSNMP_DISABLE_MIB_LOADING
             }
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
         } else {
             if (!read_objid(current_name, name, &name_length)) {
                 snmp_perror(current_name);
-                exit(2);
+                exit_code = 2;
+                goto out;
             }
         }
 
@@ -312,7 +318,7 @@ main(int argc, char *argv[])
                 snmp_log(LOG_ERR,
                         "Unable to find a matching object identifier for \"%s\"\n",
                         current_name);
-                exit(1);
+                goto out;
 #ifndef NETSNMP_DISABLE_MIB_LOADING
             }
             print_mib_tree(stdout, tp, width);
@@ -330,7 +336,11 @@ main(int argc, char *argv[])
             printf("\n");
     } while (optind < argc);
 
-    return (0);
+    exit_code = 0;
+
+out:
+    SOCK_CLEANUP;
+    return exit_code;
 }
 
 /*
diff --git a/apps/snmptrap.c b/apps/snmptrap.c
index 7c086db..d69f423 100644
--- a/apps/snmptrap.c
+++ b/apps/snmptrap.c
@@ -67,7 +67,6 @@ SOFTWARE.
 #include <net-snmp/net-snmp-includes.h>
 
 oid             objid_enterprise[] = { 1, 3, 6, 1, 4, 1, 3, 1, 1 };
-oid             objid_sysdescr[] = { 1, 3, 6, 1, 2, 1, 1, 1, 0 };
 oid             objid_sysuptime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
 oid             objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
 int             inform = 0;
@@ -128,12 +127,14 @@ main(int argc, char *argv[])
     int             status;
     char           *trap = NULL;
     char           *prognam;
-    int             exitval = 0;
+    int             exitval = 1;
 #ifndef NETSNMP_DISABLE_SNMPV1
     char           *specific = NULL, *description = NULL, *agent = NULL;
     in_addr_t      *pdu_in_addr_t;
 #endif
 
+    SOCK_STARTUP;
+
     prognam = strrchr(argv[0], '/');
     if (prognam)
         prognam++;
@@ -146,18 +147,17 @@ main(int argc, char *argv[])
         inform = 1;
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
 
-    SOCK_STARTUP;
-
     session.callback = snmp_input;
     session.callback_magic = NULL;
 
@@ -223,29 +223,25 @@ main(int argc, char *argv[])
          * the input netsnmp_session pointer
          */
         snmp_sess_perror("snmptrap", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
 #ifndef NETSNMP_DISABLE_SNMPV1
     if (session.version == SNMP_VERSION_1) {
         if (inform) {
             fprintf(stderr, "Cannot send INFORM as SNMPv1 PDU\n");
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         pdu = snmp_pdu_create(SNMP_MSG_TRAP);
         if ( !pdu ) {
             fprintf(stderr, "Failed to create trap PDU\n");
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         pdu_in_addr_t = (in_addr_t *) pdu->agent_addr;
         if (arg == argc) {
             fprintf(stderr, "No enterprise oid\n");
             usage();
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         if (argv[arg][0] == 0) {
             pdu->enterprise = (oid *) malloc(sizeof(objid_enterprise));
@@ -258,8 +254,7 @@ main(int argc, char *argv[])
             if (!snmp_parse_oid(argv[arg], name, &name_length)) {
                 snmp_perror(argv[arg]);
                 usage();
-                SOCK_CLEANUP;
-                exit(1);
+                goto out;
             }
             pdu->enterprise = (oid *) malloc(name_length * sizeof(oid));
             memcpy(pdu->enterprise, name, name_length * sizeof(oid));
@@ -268,15 +263,14 @@ main(int argc, char *argv[])
         if (++arg >= argc) {
             fprintf(stderr, "Missing agent parameter\n");
             usage();
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         agent = argv[arg];
         if (agent != NULL && strlen(agent) != 0) {
             int ret = netsnmp_gethostbyname_v4(agent, pdu_in_addr_t);
             if (ret < 0) {
                 fprintf(stderr, "unknown host: %s\n", agent);
-                exit(1);
+                goto out;
             }
         } else {
             *pdu_in_addr_t = get_myaddr();
@@ -284,24 +278,21 @@ main(int argc, char *argv[])
         if (++arg == argc) {
             fprintf(stderr, "Missing generic-trap parameter\n");
             usage();
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         trap = argv[arg];
         pdu->trap_type = atoi(trap);
         if (++arg == argc) {
             fprintf(stderr, "Missing specific-trap parameter\n");
             usage();
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         specific = argv[arg];
         pdu->specific_type = atoi(specific);
         if (++arg == argc) {
             fprintf(stderr, "Missing uptime parameter\n");
             usage();
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         description = argv[arg];
         if (description == NULL || *description == 0)
@@ -317,14 +308,12 @@ main(int argc, char *argv[])
         pdu = snmp_pdu_create(inform ? SNMP_MSG_INFORM : SNMP_MSG_TRAP2);
         if ( !pdu ) {
             fprintf(stderr, "Failed to create notification PDU\n");
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         if (arg == argc) {
             fprintf(stderr, "Missing up-time parameter\n");
             usage();
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         trap = argv[arg];
         if (*trap == 0) {
@@ -337,15 +326,13 @@ main(int argc, char *argv[])
         if (++arg == argc) {
             fprintf(stderr, "Missing trap-oid parameter\n");
             usage();
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         if (snmp_add_var
             (pdu, objid_snmptrap, sizeof(objid_snmptrap) / sizeof(oid),
              'o', argv[arg]) != 0) {
             snmp_perror(argv[arg]);
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
     }
     arg++;
@@ -355,21 +342,18 @@ main(int argc, char *argv[])
         if (arg > argc) {
             fprintf(stderr, "%s: Missing type/value for variable\n",
                     argv[arg - 3]);
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         name_length = MAX_OID_LEN;
         if (!snmp_parse_oid(argv[arg - 3], name, &name_length)) {
             snmp_perror(argv[arg - 3]);
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
         if (snmp_add_var
             (pdu, name, name_length, argv[arg - 2][0],
              argv[arg - 1]) != 0) {
             snmp_perror(argv[arg - 3]);
-            SOCK_CLEANUP;
-            exit(1);
+            goto out;
         }
     }
 
@@ -381,12 +365,17 @@ main(int argc, char *argv[])
         snmp_sess_perror(inform ? "snmpinform" : "snmptrap", ss);
         if (!inform)
             snmp_free_pdu(pdu);
-        exitval = 1;
+        goto close_session;
     } else if (inform)
         snmp_free_pdu(response);
 
+    exitval = 0;
+
+close_session:
     snmp_close(ss);
-    snmp_shutdown("snmpapp");
+    snmp_shutdown(NETSNMP_APPLICATION_CONFIG_TYPE);
+
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmptrapd.c b/apps/snmptrapd.c
index bce0d47..9d86b04 100644
--- a/apps/snmptrapd.c
+++ b/apps/snmptrapd.c
@@ -97,9 +97,15 @@ SOFTWARE.
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/fd_event_manager.h>
+#include <net-snmp/agent/netsnmp_close_fds.h>
+#include "../agent/mibgroup/snmpv3/snmpEngine.h"
+#include "../agent/mibgroup/snmpv3/usmUser.h"
+#include "../agent/mibgroup/agent/nsVacmAccessTable.h"
+#include "../agent/mibgroup/agentx/subagent.h"
 #include "snmptrapd_handlers.h"
 #include "snmptrapd_log.h"
 #include "snmptrapd_auth.h"
+#include "snmptrapd_sql.h"
 #include "notification-log-mib/notification_log.h"
 #include "tlstm-mib/snmpTlstmCertToTSNTable/snmpTlstmCertToTSNTable.h"
 #include "mibII/vacm_conf.h"
@@ -141,8 +147,6 @@ typedef long    fd_mask;
 #endif
 
 char           *logfile = NULL;
-extern int      SyslogTrap;
-extern int      dropauth;
 static int      reconfig = 0;
 char            ddefault_port[] = "udp:162";	/* Default default port */
 char           *default_port = ddefault_port;
@@ -150,17 +154,9 @@ char           *default_port = ddefault_port;
     FILE           *PID;
     char           *pid_file = NULL;
 #endif
-extern void parse_format(const char *token, char *line);
 char           *trap1_fmt_str_remember = NULL;
 int             dofork = 1;
 
-extern int      netsnmp_running;
-
-#ifdef NETSNMP_USE_MYSQL
-extern int      netsnmp_mysql_init(void);
-extern void     snmptrapd_register_sql_configs( void );
-#endif
-
 /*
  * These definitions handle 4.2 systems without additional syslog facilities.
  */
@@ -220,15 +216,7 @@ const char     *app_name = "snmptrapd";
 void            trapd_update_config(void);
 
 #ifdef WIN32SERVICE
-void            StopSnmpTrapd(void);
-int             SnmpTrapdMain(int argc, TCHAR * argv[]);
-int __cdecl     _tmain(int argc, TCHAR * argv[]);
-#else
-int             main(int, char **);
-#endif
-
-#if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
-extern void            subagent_init(void);
+static void     StopSnmpTrapd(void);
 #endif
 
 
@@ -305,15 +293,11 @@ version(void)
     printf("\nNET-SNMP Version:  %s\n", netsnmp_get_version());
     printf("Web:               http://www.net-snmp.org/\n");
     printf("Email:             net-snmp-coders@lists.sourceforge.net\n\n");
-    exit(0);
 }
 
 RETSIGTYPE
 term_handler(int sig)
 {
-#ifdef WIN32SERVICE
-    extern netsnmp_session *main_session;
-#endif
     netsnmp_running = 0;
 
 #ifdef WIN32SERVICE
@@ -430,7 +414,7 @@ parse_trapd_address(const char *token, char *cptr)
     } else {
         p = malloc(strlen(buf) + 1 + strlen(default_port) + 1);
         if (p) {
-            strcat(p, buf);
+            strcpy(p, buf);
             strcat(p, ",");
             strcat(p, default_port );
         }
@@ -652,6 +636,7 @@ main(int argc, char *argv[])
     netsnmp_transport *transport = NULL;
     int             arg, i = 0;
     int             uid = 0, gid = 0;
+    int             exit_code = 1;
     char           *cp, *listen_ports = NULL;
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
     int             agentx_subagent = 1;
@@ -664,10 +649,8 @@ main(int argc, char *argv[])
      * close all non-standard file descriptors we may have
      * inherited from the shell.
      */
-    for (i = getdtablesize() - 1; i > 2; --i) {
-        (void) close(i);
-    }
-#endif /* #WIN32 */
+    netsnmp_close_fds(2);
+#endif
     
 #ifdef SIGTERM
     signal(SIGTERM, term_handler);
@@ -740,13 +723,11 @@ main(int argc, char *argv[])
     while ((arg = getopt(argc, argv, options)) != EOF) {
         switch (arg) {
         case '-':
-            if (strcasecmp(optarg, "help") == 0) {
-                usage();
-                exit(0);
-            }
-            if (strcasecmp(optarg, "version") == 0) {
+            if (strcasecmp(optarg, "help") == 0 ||
+                strcasecmp(optarg, "version") == 0) {
                 version();
-                exit(0);
+                exit_code = 0;
+                goto out;
             }
 
             handle_long_opt(optarg);
@@ -767,7 +748,7 @@ main(int argc, char *argv[])
 				      NETSNMP_DS_LIB_OPTIONALCONFIG, optarg);
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 
@@ -807,7 +788,7 @@ main(int argc, char *argv[])
                 }
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 
@@ -818,14 +799,15 @@ main(int argc, char *argv[])
 				   NETSNMP_DS_AGENT_GROUPID, gid = atoi(optarg));
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 #endif
 
         case 'h':
             usage();
-            exit(0);
+            exit_code = 0;
+            goto out;
 
         case 'H':
             init_agent("snmptrapd");
@@ -838,7 +820,8 @@ main(int argc, char *argv[])
             init_snmp("snmptrapd");
             fprintf(stderr, "Configuration directives understood:\n");
             read_config_print_usage("  ");
-            exit(0);
+            exit_code = 0;
+            goto out;
 
         case 'I':
             if (optarg != NULL) {
@@ -851,15 +834,14 @@ main(int argc, char *argv[])
 	case 'S':
             fprintf(stderr,
                     "Warning: -S option has been withdrawn; use -Ls <facility> instead\n");
-            exit(1);
-            break;
+            goto out;
 
         case 'm':
             if (optarg != NULL) {
                 setenv("MIBS", optarg, 1);
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 
@@ -868,7 +850,7 @@ main(int argc, char *argv[])
                 setenv("MIBDIRS", optarg, 1);
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 
@@ -880,8 +862,7 @@ main(int argc, char *argv[])
         case 'o':
             fprintf(stderr,
                     "Warning: -o option has been withdrawn; use -Lf <file> instead\n");
-            exit(1);
-            break;
+            goto out;
 
         case 'O':
             cp = snmp_out_toggle_options(optarg);
@@ -889,14 +870,14 @@ main(int argc, char *argv[])
                 fprintf(stderr, "Unknown output option passed to -O: %c\n",
 			*cp);
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 
         case 'L':
 	    if  (snmp_log_options( optarg, argc, argv ) < 0 ) {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 
@@ -906,7 +887,7 @@ main(int argc, char *argv[])
                 parse_config_pidFile(NULL, optarg);
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 #endif
@@ -914,14 +895,12 @@ main(int argc, char *argv[])
         case 'P':
             fprintf(stderr,
                     "Warning: -P option has been withdrawn; use -f -Le instead\n");
-            exit(1);
-            break;
+            goto out;
 
         case 's':
             fprintf(stderr,
                     "Warning: -s option has been withdrawn; use -Lsd instead\n");
-            exit(1);
-            break;
+            goto out;
 
         case 't':
             SyslogTrap++;
@@ -944,13 +923,13 @@ main(int argc, char *argv[])
 #endif
                 if (uid < 0) {
                     fprintf(stderr, "Bad user id: %s\n", optarg);
-                    exit(1);
+                    goto out;
                 }
                 netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_USERID, uid);
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 #endif
@@ -967,7 +946,7 @@ main(int argc, char *argv[])
                                       NETSNMP_DS_AGENT_X_SOCKET, optarg);
             } else {
                 usage();
-                exit(1);
+                goto out;
             }
             break;
 
@@ -979,7 +958,7 @@ main(int argc, char *argv[])
         default:
             fprintf(stderr, "invalid option: -%c\n", arg);
             usage();
-            exit(1);
+            goto out;
             break;
         }
     }
@@ -994,7 +973,7 @@ main(int argc, char *argv[])
                 astring = malloc(strlen(listen_ports) + 2 + strlen(argv[i]));
                 if (astring == NULL) {
                     fprintf(stderr, "malloc failure processing argv[%d]\n", i);
-                    exit(1);
+                    goto out;
                 }
                 sprintf(astring, "%s,%s", listen_ports, argv[i]);
                 free(listen_ports);
@@ -1003,7 +982,7 @@ main(int argc, char *argv[])
                 listen_ports = strdup(argv[i]);
                 if (listen_ports == NULL) {
                     fprintf(stderr, "malloc failure processing argv[%d]\n", i);
-                    exit(1);
+                    goto out;
                 }
             }
         }
@@ -1073,9 +1052,6 @@ main(int argc, char *argv[])
      * initialize local modules 
      */
     if (agentx_subagent) {
-#ifdef USING_SNMPV3_SNMPENGINE_MODULE
-        extern void register_snmpEngine_scalars_context(const char *);
-#endif
         subagent_init();
 #ifdef USING_NOTIFICATION_LOG_MIB_NOTIFICATION_LOG_MODULE
         /* register the notification log table */
@@ -1105,14 +1081,10 @@ main(int argc, char *argv[])
 
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
     if (agentx_subagent) {
-#ifdef USING_AGENT_NSVACMACCESSTABLE_MODULE
-        extern void init_register_nsVacm_context(const char *);
-#endif
 #ifdef USING_SNMPV3_USMUSER_MODULE
 #ifdef NETSNMP_FEATURE_CHECKING
         netsnmp_feature_require(init_register_usmUser_context)
 #endif /* NETSNMP_FEATURE_CHECKING */
-        extern void init_register_usmUser_context(const char *);
         /* register ourselves as having a USM user database */
         init_register_usmUser_context("snmptrapd");
 #endif
@@ -1191,8 +1163,7 @@ main(int argc, char *argv[])
             snmp_log(LOG_ERR, "couldn't open %s -- errno %d (\"%s\")\n",
                      cp, errno, strerror(errno));
             snmptrapd_close_sessions(sess_list);
-            SOCK_CLEANUP;
-            exit(1);
+            goto sock_cleanup;
         } else {
             ss = snmptrapd_add_session(transport);
             if (ss == NULL) {
@@ -1202,8 +1173,7 @@ main(int argc, char *argv[])
                  */
                 snmptrapd_close_sessions(sess_list);
                 snmp_log(LOG_ERR, "couldn't open snmp - %s", strerror(errno));
-                SOCK_CLEANUP;
-                exit(1);
+                goto sock_cleanup;
             } else {
                 ss->next = sess_list;
                 sess_list = ss;
@@ -1226,7 +1196,7 @@ main(int argc, char *argv[])
 #ifdef NETSNMP_USE_MYSQL
     if( netsnmp_mysql_init() ) {
         fprintf(stderr, "MySQL initialization failed\n");
-        exit(1);
+        goto sock_cleanup;
     }
 #endif
 
@@ -1237,10 +1207,14 @@ main(int argc, char *argv[])
     if (dofork && netsnmp_running) {
         int             fd;
 
+#if HAVE_FORKALL
+        switch (forkall()) {
+#else
         switch (fork()) {
+#endif
         case -1:
             fprintf(stderr, "bad fork - %s\n", strerror(errno));
-            _exit(1);
+            goto sock_cleanup;
 
         case 0:
             /*
@@ -1248,17 +1222,19 @@ main(int argc, char *argv[])
              */
             if (setsid() == -1) {
                 fprintf(stderr, "bad setsid - %s\n", strerror(errno));
-                _exit(1);
+                goto sock_cleanup;
             }
 
             /*
              * if we are forked, we don't want to print out to stdout or stderr 
              */
             fd = open("/dev/null", O_RDWR);
-            dup2(fd, STDIN_FILENO);
-            dup2(fd, STDOUT_FILENO);
-            dup2(fd, STDERR_FILENO);
-            close(fd);
+            if (fd >= 0) {
+                dup2(fd, STDIN_FILENO);
+                dup2(fd, STDOUT_FILENO);
+                dup2(fd, STDERR_FILENO);
+                close(fd);
+            }
             break;
 
         default:
@@ -1270,7 +1246,7 @@ main(int argc, char *argv[])
     if (pid_file != NULL) {
         if ((PID = fopen(pid_file, "w")) == NULL) {
             snmp_log_perror("fopen");
-            exit(1);
+            goto sock_cleanup;
         }
         fprintf(PID, "%d\n", (int) getpid());
         fclose(PID);
@@ -1288,7 +1264,7 @@ main(int argc, char *argv[])
 #if HAVE_UNISTD_H
 #ifdef HAVE_SETGID
     if ((gid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
-				  NETSNMP_DS_AGENT_GROUPID)) != 0) {
+				  NETSNMP_DS_AGENT_GROUPID)) > 0) {
         DEBUGMSGTL(("snmptrapd/main", "Changing gid to %d.\n", gid));
         if (setgid(gid) == -1
 #ifdef HAVE_SETGROUPS
@@ -1298,7 +1274,7 @@ main(int argc, char *argv[])
             snmp_log_perror("setgid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                goto sock_cleanup;
             }
         }
     }
@@ -1311,7 +1287,7 @@ main(int argc, char *argv[])
             snmp_log_perror("setuid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                goto sock_cleanup;
             }
         }
     }
@@ -1345,8 +1321,14 @@ main(int argc, char *argv[])
     trapd_status = SNMPTRAPD_STOPPED;
 #endif
     snmp_disable_log();
+
+    exit_code = 0;
+
+sock_cleanup:
     SOCK_CLEANUP;
-    return 0;
+
+out:
+    return exit_code;
 }
 
 /*
@@ -1365,18 +1347,6 @@ trapd_update_config(void)
     read_configs();
 }
 
-
-#if !defined(HAVE_GETDTABLESIZE) && !defined(WIN32)
-#include <sys/resource.h>
-int
-getdtablesize(void)
-{
-    struct rlimit   rl;
-    getrlimit(RLIMIT_NOFILE, &rl);
-    return (rl.rlim_cur);
-}
-#endif
-
 /*
  * Windows Service Related functions 
  */
diff --git a/apps/snmptrapd_handlers.c b/apps/snmptrapd_handlers.c
index 5a8e3c8..b84abfe 100644
--- a/apps/snmptrapd_handlers.c
+++ b/apps/snmptrapd_handlers.c
@@ -102,6 +102,7 @@ snmptrapd_parse_traphandle(const char *token, char *line)
     }
     if ( !cptr ) {
         netsnmp_config_error("Missing traphandle command (%s)", buf);
+        free(format);
         return;
     }
 
@@ -126,6 +127,7 @@ snmptrapd_parse_traphandle(const char *token, char *line)
         if (!read_objid(buf, obuf, &olen)) {
 	    netsnmp_config_error("Bad trap OID in traphandle directive: %s",
 				 buf);
+            free(format);
             return;
         }
         DEBUGMSGOID(("read_config:traphandle", obuf, olen));
@@ -138,9 +140,12 @@ snmptrapd_parse_traphandle(const char *token, char *line)
         traph->flags = flags;
         traph->authtypes = TRAP_AUTH_EXE;
         traph->token = strdup(cptr);
-        if (format)
+        if (format) {
             traph->format = format;
+            format = NULL;
+        }
     }
+    free(format);
 }
 
 
@@ -189,6 +194,7 @@ parse_forward(const char *token, char *line)
 
         if (!read_objid(buf, obuf, &olen)) {
 	    netsnmp_config_error("Bad trap OID in forward directive: %s", buf);
+            free(format);
             return;
         }
         DEBUGMSGOID(("read_config:forward", obuf, olen));
@@ -206,6 +212,8 @@ parse_forward(const char *token, char *line)
         traph->token = strdup(cptr);
         if (format)
             traph->format = format;
+    } else {
+        free(format);
     }
 }
 
@@ -909,9 +917,12 @@ int   forward_handler( netsnmp_pdu           *pdu,
         pdu2->transport_data        = NULL;
         pdu2->transport_data_length = 0;
     }
-    if (!snmp_send( ss, pdu2 )) {
-	snmp_sess_perror("Forward failed", ss);
-	snmp_free_pdu(pdu2);
+
+    ss->s_snmp_errno = SNMPERR_SUCCESS;
+    if (!snmp_send( ss, pdu2 ) &&
+            ss->s_snmp_errno != SNMPERR_SUCCESS) {
+        snmp_sess_perror("Forward failed", ss);
+        snmp_free_pdu(pdu2);
     }
     snmp_close( ss );
     return NETSNMPTRAPD_HANDLER_OK;
diff --git a/apps/snmptrapd_handlers.h b/apps/snmptrapd_handlers.h
index 097c02d..7b93320 100644
--- a/apps/snmptrapd_handlers.h
+++ b/apps/snmptrapd_handlers.h
@@ -41,6 +41,8 @@ void free_trap1_fmt(void);
 void free_trap2_fmt(void);
 extern char *print_format1;
 extern char *print_format2;
+extern int   SyslogTrap;
+extern int   dropauth;
 
 #define NETSNMPTRAPD_AUTH_HANDLER    1
 #define NETSNMPTRAPD_PRE_HANDLER     2
@@ -65,4 +67,6 @@ void do_external(char *cmd, struct hostent *host,
 int snmp_input(int op, netsnmp_session *session,
            int reqid, netsnmp_pdu *pdu, void *magic);
 
+void parse_format(const char *token, char *line);
+
 #endif                          /* SNMPTRAPD_HANDLERS_H */
diff --git a/apps/snmptrapd_log.c b/apps/snmptrapd_log.c
index 774f797..fb7eaba 100644
--- a/apps/snmptrapd_log.c
+++ b/apps/snmptrapd_log.c
@@ -85,6 +85,7 @@ SOFTWARE.
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
+#include "snmptrapd_handlers.h"
 #include "snmptrapd_log.h"
 
 
@@ -302,11 +303,6 @@ typedef enum {
       *    var - the parameter to reference
       */
 
-/*
- * prototypes 
- */
-extern const char *trap_description(int trap);
-
 static void
 init_options(options_type * options)
 
diff --git a/apps/snmptrapd_sql.c b/apps/snmptrapd_sql.c
index 671e542..70856a4 100644
--- a/apps/snmptrapd_sql.c
+++ b/apps/snmptrapd_sql.c
@@ -15,6 +15,20 @@
 
 #ifdef NETSNMP_USE_MYSQL
 
+/*
+ * SQL includes
+ */
+#undef PACKAGE_BUGREPORT
+#undef PACKAGE_NAME
+#undef PACKAGE_STRING
+#undef PACKAGE_TARNAME
+#undef PACKAGE_VERSION
+#include <my_config.h>
+#include <my_global.h>
+#include <my_sys.h>
+#include <mysql.h>
+#include <errmsg.h>
+
 #if HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
@@ -41,19 +55,7 @@
 #include "snmptrapd_handlers.h"
 #include "snmptrapd_auth.h"
 #include "snmptrapd_log.h"
-
-/*
- * SQL includes
- */
-#undef PACKAGE_BUGREPORT
-#undef PACKAGE_NAME
-#undef PACKAGE_STRING
-#undef PACKAGE_TARNAME
-#undef PACKAGE_VERSION
-#include <my_global.h>
-#include <my_sys.h>
-#include <mysql.h>
-#include <errmsg.h>
+#include "snmptrapd_sql.h"
 
 netsnmp_feature_require(container_fifo)
 
@@ -444,7 +446,11 @@ netsnmp_mysql_init(void)
 #endif
 
     /** load .my.cnf values */
+#if HAVE_MY_LOAD_DEFAULTS
+    my_load_defaults ("my", _sql.groups, &not_argc, &not_argv, 0);
+#else
     load_defaults ("my", _sql.groups, &not_argc, &not_argv);
+#endif
     for(i=0; i < not_argc; ++i) {
         if (NULL == not_argv[i])
             continue;
@@ -879,7 +885,7 @@ _sql_save_varbind_info(sql_buf *sqlb, netsnmp_pdu  *pdu)
         tmp_size = 0;
         buf_val_len_t = 0;
         sprint_realloc_by_type((u_char**)&sqlvb->val, &tmp_size,
-                               &buf_val_len_t, 1, var, 0, 0, 0);
+                               &buf_val_len_t, 1, var, NULL, NULL, NULL);
         sqlvb->val_len = buf_val_len_t;
 #else
         sqlvb->val = netsnmp_memdup(var->val.string, var->val_len);
@@ -936,7 +942,7 @@ mysql_handler(netsnmp_pdu           *pdu,
     if(rc) {
         snmp_log(LOG_ERR, "Could not log queue sql trap buffer\n");
         _sql_log(sqlb, NULL);
-        _sql_buf_free(sqlb, 0);
+        _sql_buf_free(sqlb, NULL);
         return -1;
     }
 
diff --git a/apps/snmptrapd_sql.h b/apps/snmptrapd_sql.h
new file mode 100644
index 0000000..05e2b0c
--- /dev/null
+++ b/apps/snmptrapd_sql.h
@@ -0,0 +1,2 @@
+void snmptrapd_register_sql_configs(void);
+int netsnmp_mysql_init(void);
diff --git a/apps/snmpusm.c b/apps/snmpusm.c
index 42919bd..8ccf9e7 100644
--- a/apps/snmpusm.c
+++ b/apps/snmpusm.c
@@ -61,8 +61,6 @@
 
 #include <net-snmp/net-snmp-includes.h>
 
-int             main(int, char **);
-
 #define CMD_PASSWD_NAME    "passwd"
 #define CMD_PASSWD         1
 #define CMD_CREATE_NAME    "create"
@@ -150,7 +148,7 @@ usage(void)
     fprintf(stderr, "\t\t\t(it won't be active until you active it)\n");
     fprintf(stderr, "\t-Cx\t\tChange the privacy key.\n");
     fprintf(stderr, "\t-Ca\t\tChange the authentication key.\n");
-    fprintf(stderr, "\t-Ck\t\tAllows to use localized key (must start with 0x)\n");
+    fprintf(stderr, "\t-Ck\t\tAllows one to use localized key (must start with 0x)\n");
     fprintf(stderr, "\t\t\tinstead of passphrase.\n");
 }
 
@@ -352,7 +350,7 @@ main(int argc, char *argv[])
     size_t          name_length = USM_OID_LEN;
     size_t          name_length2 = USM_OID_LEN;
     int             status;
-    int             exitval = 0;
+    int             exitval = 1;
     int             rval;
     int             command = 0;
     long            longvar;
@@ -375,6 +373,8 @@ main(int argc, char *argv[])
         newkul[SNMP_MAXBUF_SMALL], keychange[SNMP_MAXBUF_SMALL],
         keychangepriv[SNMP_MAXBUF_SMALL];
 
+    SOCK_STARTUP;
+
     authKeyChange = authKeyOid;
     privKeyChange = privKeyOid;
 
@@ -383,12 +383,13 @@ main(int argc, char *argv[])
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -396,11 +397,9 @@ main(int argc, char *argv[])
     if (arg >= argc) {
         fprintf(stderr, "Please specify an operation to perform.\n");
         usage();
-        exit(1);
+        goto out;
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -414,7 +413,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpusm", &session);
-        exit(1);
+        goto out;
     }
 
     /*
@@ -432,7 +431,7 @@ main(int argc, char *argv[])
     pdu = snmp_pdu_create(SNMP_MSG_SET);
     if (!pdu) {
         fprintf(stderr, "Failed to create request\n");
-        exit(1);
+        goto close_session;
     }
 
 
@@ -458,14 +457,14 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "New passphrase must be greater than %d characters in length.\n",
                     USM_LENGTH_P_MIN);
-            exit(1);
+            goto close_session;
         }
 
         if (oldpass == NULL || strlen(oldpass) < USM_LENGTH_P_MIN) {
             fprintf(stderr,
                     "Old passphrase must be greater than %d characters in length.\n",
                     USM_LENGTH_P_MIN);
-            exit(1);
+            goto close_session;
         }
 
         /* 
@@ -534,7 +533,7 @@ main(int argc, char *argv[])
 	    if (!snmp_hex_to_binary((u_char **) (&buf), &buf_len, &oldkul_len, 0, oldpass)) {
 	      snmp_perror(argv[0]);
 	      fprintf(stderr, "generating the old Kul from localized key failed\n");
-	      exit(1);
+	      goto close_session;
 	    }
 	    
 	    memcpy(oldkul, buf, oldkul_len);
@@ -552,7 +551,7 @@ main(int argc, char *argv[])
 	    if (rval != SNMPERR_SUCCESS) {
 	        snmp_perror(argv[0]);
 	        fprintf(stderr, "generating the old Ku failed\n");
-	        exit(1);
+	        goto close_session;
 	    }
 
 	    /*
@@ -566,7 +565,7 @@ main(int argc, char *argv[])
 	    if (rval != SNMPERR_SUCCESS) {
 	        snmp_perror(argv[0]);
 		fprintf(stderr, "generating the old Kul failed\n");
-		exit(1);
+		goto close_session;
 	    }
 	}
 	if (uselocalizedkey && (strncmp(newpass, "0x", 2) == 0)) {
@@ -581,7 +580,7 @@ main(int argc, char *argv[])
 	    if (!snmp_hex_to_binary((u_char **) (&buf), &buf_len, &newkul_len, 0, newpass)) {
 	      snmp_perror(argv[0]);
 	      fprintf(stderr, "generating the new Kul from localized key failed\n");
-	      exit(1);
+	      goto close_session;
 	    }
 	    
 	    memcpy(newkul, buf, newkul_len);
@@ -595,7 +594,7 @@ main(int argc, char *argv[])
             if (rval != SNMPERR_SUCCESS) {
                 snmp_perror(argv[0]);
                 fprintf(stderr, "generating the new Ku failed\n");
-                exit(1);
+                goto close_session;
             }
 
 	    rval = generate_kul(session.securityAuthProto,
@@ -606,7 +605,7 @@ main(int argc, char *argv[])
 	    if (rval != SNMPERR_SUCCESS) {
 	        snmp_perror(argv[0]);
 		fprintf(stderr, "generating the new Kul failed\n");
-		exit(1);
+		goto close_session;
 	    }
 	}
 
@@ -618,7 +617,7 @@ main(int argc, char *argv[])
         if (doprivkey) {
             if (!session.securityPrivProto) {
                 snmp_log(LOG_ERR, "no encryption type specified, which I need in order to know to change the key\n");
-                exit(1);
+                goto close_session;
             }
                 
 #ifndef NETSNMP_DISABLE_DES
@@ -651,7 +650,7 @@ main(int argc, char *argv[])
 	    snmp_perror(argv[0]);
             fprintf(stderr, "encoding the keychange failed\n");
             usage();
-            exit(1);
+            goto close_session;
 	  }
 	}
 
@@ -668,7 +667,7 @@ main(int argc, char *argv[])
             snmp_perror(argv[0]);
             fprintf(stderr, "encoding the keychange failed\n");
             usage();
-            exit(1);
+            goto close_session;
 	  }
 	}
 
@@ -700,7 +699,7 @@ main(int argc, char *argv[])
         if (++arg >= argc) {
             fprintf(stderr, "You must specify the user name to create\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_CREATE;
@@ -755,7 +754,7 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "You must specify the user name to operate on\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_CLONEFROM;
@@ -773,7 +772,7 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "You must specify the user name to clone from\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         setup_oid(usmUserSecurityName, &name_length2,
@@ -791,7 +790,7 @@ main(int argc, char *argv[])
          */
         if (++arg >= argc) {
             fprintf(stderr, "You must specify the user name to delete\n");
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_DELETE;
@@ -809,7 +808,7 @@ main(int argc, char *argv[])
          */
         if (++arg >= argc) {
             fprintf(stderr, "You must specify the user name to activate\n");
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_ACTIVATE;
@@ -827,7 +826,7 @@ main(int argc, char *argv[])
          */
         if (++arg >= argc) {
             fprintf(stderr, "You must specify the user name to deactivate\n");
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_DEACTIVATE;
@@ -882,7 +881,7 @@ main(int argc, char *argv[])
         dhpdu = snmp_pdu_create(SNMP_MSG_GET);
         if (!dhpdu) {
             fprintf(stderr, "Failed to create DH request\n");
-            exit(1);
+            goto close_session;
         }
 
         /* get the current DH parameters */
@@ -960,7 +959,7 @@ main(int argc, char *argv[])
     } else {
         fprintf(stderr, "Unknown command\n");
         usage();
-        exit(1);
+        goto close_session;
     }
 
     /*
@@ -1012,12 +1011,17 @@ main(int argc, char *argv[])
         exitval = 1;
     }
 
+    exitval = 0;
 #if defined(HAVE_OPENSSL_DH_H) && defined(HAVE_LIBCRYPTO)
   begone:
 #endif /* HAVE_OPENSSL_DH_H && HAVE_LIBCRYPTO */
     if (response)
         snmp_free_pdu(response);
+
+close_session:
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmpvacm.c b/apps/snmpvacm.c
index f88ede6..9c1162d 100644
--- a/apps/snmpvacm.c
+++ b/apps/snmpvacm.c
@@ -44,8 +44,6 @@
 
 #include <net-snmp/net-snmp-includes.h>
 
-int             main(int, char **);
-
 #define CMD_CREATESEC2GROUP_NAME    "createSec2Group"
 #define CMD_CREATESEC2GROUP         1
 #define CMD_DELETESEC2GROUP_NAME    "deleteSec2Group"
@@ -269,7 +267,7 @@ main(int argc, char *argv[])
 #endif
     size_t          name_length;
     int             status;
-    int             exitval = 0;
+    int             exitval = 1;
     int             command = 0;
     long            longvar;
     int             secModel, secLevel, contextMatch;
@@ -278,25 +276,24 @@ main(int argc, char *argv[])
     u_char          viewMask[VACMSTRINGLEN];
     char           *st;
 
+    SOCK_STARTUP;
 
     /*
      * get the common command line arguments 
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
 
-
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -309,7 +306,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpvacm", &session);
-        exit(1);
+        goto out;
     }
 
     /*
@@ -320,7 +317,7 @@ main(int argc, char *argv[])
     if (arg >= argc) {
         fprintf(stderr, "Please specify a operation to perform.\n");
         usage();
-        exit(1);
+        goto close_session;
     }
 
     if (strcmp(argv[arg], CMD_DELETEVIEW_NAME) == 0)
@@ -334,7 +331,7 @@ main(int argc, char *argv[])
         if (++arg + 2 != argc) {
             fprintf(stderr, "You must specify the view to delete\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_DELETEVIEW;
@@ -356,7 +353,7 @@ main(int argc, char *argv[])
         if (++arg + 2 > argc) {
             fprintf(stderr, "You must specify name, subtree and mask\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         command = CMD_CREATEVIEW;
         name_length = VIEW_OID_LEN;
@@ -374,11 +371,11 @@ main(int argc, char *argv[])
             for (mask = strtok_r(mask, ".:", &st); mask; mask = strtok_r(NULL, ".:", &st)) {
                 if (i >= sizeof(viewMask)) {
                     printf("MASK too long\n");
-                    exit(1);
+                    goto close_session;
                 }
                 if (sscanf(mask, "%x", &val) == 0) {
                     printf("invalid MASK\n");
-                    exit(1);
+                    goto close_session;
                 }
                 viewMask[i] = val;
                 i++;
@@ -409,7 +406,7 @@ main(int argc, char *argv[])
         if (++arg + 2 != argc) {
             fprintf(stderr, "You must specify the sec2group to delete\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_DELETESEC2GROUP;
@@ -417,7 +414,7 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg], "%d", &secModel) == 0) {
             printf("invalid security model\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         sec2group_oid(vacmSec2GroupStatus, &name_length, secModel,
                       argv[arg + 1]);
@@ -437,7 +434,7 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "You must specify model, security name and group name\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_CREATESEC2GROUP;
@@ -445,7 +442,7 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg], "%d", &secModel) == 0) {
             printf("invalid security model\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         sec2group_oid(vacmSec2GroupStatus, &name_length, secModel,
                       argv[arg + 1]);
@@ -470,7 +467,7 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "You must specify the access entry to delete\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_DELETEACCESS;
@@ -484,12 +481,12 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg + 1], "%d", &secModel) == 0) {
             printf("invalid security model\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         if (sscanf(argv[arg + 2], "%d", &secLevel) == 0) {
             printf("invalid security level\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         access_oid(vacmAccessStatus, &name_length, groupName, prefix,
                    secModel, secLevel);
@@ -509,7 +506,7 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "You must specify the access entry to create\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_CREATEACCESS;
@@ -523,12 +520,12 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg + 1], "%d", &secModel) == 0) {
             printf("invalid security model\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         if (sscanf(argv[arg + 2], "%d", &secLevel) == 0) {
             printf("invalid security level\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         access_oid(vacmAccessStatus, &name_length, groupName, prefix,
                    secModel, secLevel);
@@ -542,7 +539,7 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg + 3], "%d", &contextMatch) == 0) {
             printf("invalid contextMatch\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         snmp_pdu_add_variable(pdu, vacmAccessContextMatch, name_length,
                               ASN_INTEGER, (u_char *) & contextMatch,
@@ -577,7 +574,7 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "You must specify the authAccess entry to delete\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_DELETEAUTH;
@@ -591,12 +588,12 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg + 1], "%d", &secModel) == 0) {
             printf("invalid security model\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         if (sscanf(argv[arg + 2], "%d", &secLevel) == 0) {
             printf("invalid security level\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         authtype = argv[arg+3];
         auth_oid(nsVacmRowStatus, &name_length, groupName, prefix,
@@ -617,7 +614,7 @@ main(int argc, char *argv[])
             fprintf(stderr,
                     "You must specify the authAccess entry to create\n");
             usage();
-            exit(1);
+            goto close_session;
         }
 
         command = CMD_CREATEAUTH;
@@ -631,12 +628,12 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg + 1], "%d", &secModel) == 0) {
             printf("invalid security model\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         if (sscanf(argv[arg + 2], "%d", &secLevel) == 0) {
             printf("invalid security level\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         authtype = argv[arg+3];
         auth_oid(nsVacmRowStatus, &name_length, groupName, prefix,
@@ -651,7 +648,7 @@ main(int argc, char *argv[])
         if (sscanf(argv[arg + 4], "%d", &contextMatch) == 0) {
             printf("invalid contextMatch\n");
             usage();
-            exit(1);
+            goto close_session;
         }
         snmp_pdu_add_variable(pdu, nsVacmContextPfx, name_length,
                               ASN_INTEGER, (u_char *) & contextMatch,
@@ -665,9 +662,11 @@ main(int argc, char *argv[])
     } else {
         printf("Unknown command\n");
         usage();
-        exit(1);
+        goto close_session;
     }
 
+    exitval = 0;
+
     /*
      * do the request 
      */
@@ -705,7 +704,10 @@ main(int argc, char *argv[])
     if (response)
         snmp_free_pdu(response);
 
+close_session:
     snmp_close(ss);
+
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/snmpwalk.c b/apps/snmpwalk.c
index 659d7de..f58c453 100644
--- a/apps/snmpwalk.c
+++ b/apps/snmpwalk.c
@@ -187,9 +187,11 @@ main(int argc, char *argv[])
     int             running;
     int             status = STAT_ERROR;
     int             check;
-    int             exitval = 0;
+    int             exitval = 1;
     struct timeval  tv1, tv2, tv_a, tv_b;
 
+    SOCK_STARTUP;
+
     netsnmp_ds_register_config(ASN_BOOLEAN, "snmpwalk", "includeRequested",
 			       NETSNMP_DS_APPLICATION_ID, 
 			       NETSNMP_DS_WALK_INCLUDE_REQUESTED);
@@ -219,12 +221,13 @@ main(int argc, char *argv[])
      */
     switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+        goto out;
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+        exitval = 0;
+        goto out;
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
         usage();
-        exit(1);
+        goto out;
     default:
         break;
     }
@@ -239,7 +242,7 @@ main(int argc, char *argv[])
         rootlen = MAX_OID_LEN;
         if (snmp_parse_oid(argv[arg], root, &rootlen) == NULL) {
             snmp_perror(argv[arg]);
-            exit(1);
+            goto out;
         }
     } else {
         /*
@@ -258,7 +261,7 @@ main(int argc, char *argv[])
         end_len = MAX_OID_LEN;
         if (snmp_parse_oid(end_name, end_oid, &end_len) == NULL) {
             snmp_perror(end_name);
-            exit(1);
+            goto out;
         }
     } else {
         memmove(end_oid, root, rootlen*sizeof(oid));
@@ -266,8 +269,6 @@ main(int argc, char *argv[])
         end_oid[end_len-1]++;
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -277,8 +278,7 @@ main(int argc, char *argv[])
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpwalk", &session);
-        SOCK_CLEANUP;
-        exit(1);
+        goto out;
     }
 
     /*
@@ -299,6 +299,7 @@ main(int argc, char *argv[])
     if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                                NETSNMP_DS_WALK_TIME_RESULTS))
         netsnmp_get_monotonic_clock(&tv1);
+    exitval = 0;
     while (running) {
         /*
          * create PDU for GETNEXT request and add object name to request 
@@ -427,6 +428,7 @@ main(int argc, char *argv[])
                  (double) (tv2.tv_sec - tv1.tv_sec));
     }
 
+out:
     SOCK_CLEANUP;
     return exitval;
 }
diff --git a/apps/sshtosnmp.c b/apps/sshtosnmp.c
index d26067d..cc84dc1 100644
--- a/apps/sshtosnmp.c
+++ b/apps/sshtosnmp.c
@@ -44,10 +44,10 @@
 
 #undef DEBUGGING
 
-#ifdef DEBUGGING
 #define DEBUG(x) deb(x)
+#ifdef DEBUGGING
 FILE *debf = NULL;
-void
+static void
 deb(const char *string) {
     if (NULL == debf) {
         debf = fopen("/tmp/sshtosnmp.log", "a");
@@ -58,7 +58,8 @@ deb(const char *string) {
     }
 }
 #else  /* !DEBUGGING */
-#define DEBUG(x)
+NETSNMP_STATIC_INLINE void
+deb(const char *string) { }
 #endif /* DEBUGGING code */
 
 int
diff --git a/configure b/configure
index 433ba5b..a09ca32 100755
--- a/configure
+++ b/configure
@@ -659,6 +659,11 @@ NETSNMP_BUILD_TLS_PROG_FALSE
 NETSNMP_BUILD_TLS_PROG_TRUE
 NETSNMP_BUILD_SSH_PROG_FALSE
 NETSNMP_BUILD_SSH_PROG_TRUE
+LIBNL3_LIBS
+LIBNL3_CFLAGS
+PKG_CONFIG_LIBDIR
+PKG_CONFIG_PATH
+PKG_CONFIG
 NETSNMP_HAVE_AGENTX_LIBS_FALSE
 NETSNMP_HAVE_AGENTX_LIBS_TRUE
 NETSNMP_DEFAULT_MIBS
@@ -1048,7 +1053,12 @@ CFLAGS
 LDFLAGS
 LIBS
 CPPFLAGS
-CPP'
+CPP
+PKG_CONFIG
+PKG_CONFIG_PATH
+PKG_CONFIG_LIBDIR
+LIBNL3_CFLAGS
+LIBNL3_LIBS'
 
 
 # Initialize some variables set by options.
@@ -1695,7 +1705,7 @@ Optional Features:
   --disable-privacy               Don't compile in support for privacy (encryption).
   --disable-md5                   Do not support MD5 authentication.
   --enable-internal-md5           Use the internal MD5 support.
-  --enable-ipv6                   Generate IPv6 ready version.
+  --disable-ipv6                  Disable IPv6 support.
   --disable-snmpv1                Do not include code that implements SNMPv1.
   --disable-snmpv2c               Do not include code that implements SNMPv2c.
   --enable-debugging              Outputs extra debugging information at all
@@ -2006,6 +2016,14 @@ Some influential environment variables:
   CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
+  PKG_CONFIG  path to pkg-config utility
+  PKG_CONFIG_PATH
+              directories to add to pkg-config's search path
+  PKG_CONFIG_LIBDIR
+              path overriding pkg-config's built-in search path
+  LIBNL3_CFLAGS
+              C compiler flags for LIBNL3, overriding pkg-config
+  LIBNL3_LIBS linker flags for LIBNL3, overriding pkg-config
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -3288,6 +3306,10 @@ CONFIGURE_OPTIONS="\"$ac_configure_args\""
 #     checks for library functions
 #     checks for system services
 
+
+
+
+
 # -*- autoconf -*-
 #########################################
 ##
@@ -4002,11 +4024,9 @@ fi
 
 # Check whether --enable-ipv6 was given.
 if test "${enable_ipv6+set}" = set; then :
-  enableval=$enable_ipv6; if test "x$enable_ipv6" = "xyes"; then
-
-$as_echo "#define NETSNMP_ENABLE_IPV6 1" >>confdefs.h
-
-    fi
+  enableval=$enable_ipv6;
+else
+      enable_ipv6="yes"
 fi
 
 
@@ -4015,6 +4035,11 @@ if test "${with_ipv6+set}" = set; then :
   withval=$with_ipv6; as_fn_error $? "Invalid option. Use --enable-ipv6/--disable-ipv6 instead" "$LINENO" 5
 fi
 
+if test "x$enable_ipv6" != "xno"; then
+
+$as_echo "#define NETSNMP_ENABLE_IPV6 1" >>confdefs.h
+
+fi
 
 
 # Check whether --with-logfile was given.
@@ -5215,6 +5240,14 @@ $as_echo "#define NETSNMP_USE_MYSQL 1" >>confdefs.h
 
 fi
 
+##
+# Protect against CFLAGS with -Werror which causes failures for some tests
+#   (e.g. it causes type mismatches in the AC_CV_FUNCS call)
+##
+noerr_CFLAGS="$CFLAGS"
+CFLAGS=`echo $CFLAGS | sed 's/-Werror[^ ]*//g'`
+CFLAGS_without_Werror=$CFLAGS
+export CFLAGS
 # -*- autoconf -*-
 #
 # Prompt for various bits of user information
@@ -6257,6 +6290,7 @@ done
   done
 IFS=$as_save_IFS
 
+  test -z "$ac_cv_path_AUTOCONF" && ac_cv_path_AUTOCONF=":"
   ;;
 esac
 fi
@@ -6297,6 +6331,7 @@ done
   done
 IFS=$as_save_IFS
 
+  test -z "$ac_cv_path_AUTOHEADER" && ac_cv_path_AUTOHEADER=":"
   ;;
 esac
 fi
@@ -6477,15 +6512,6 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
-if test "x$ac_cv_prog_AUTOCONF" = "x"; then
-	AUTOCONF=":"
-
-fi
-if test "x$ac_cv_prog_AUTOHEADER" = "x"; then
-	AUTOHEADER=":"
-
-fi
-
 MAKE=${MAKE-"make"}
 $MAKE -v -f /dev/null 2>/dev/null | $GREP GNU >/dev/null
 have_gnu_make=$?
@@ -15597,6 +15623,8 @@ esac
 #   Compiler flags:
 #
 
+CFLAGS="-DNETSNMP_REMOVE_U64 $CFLAGS"
+
 # The Net-SNMP source code is not strict-aliasing safe, so add
 # -fno-strict-aliasing to $CFLAGS if the compiler supports it.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-strict-aliasing" >&5
@@ -15658,7 +15686,7 @@ $as_echo "none" >&6; }
 	fi
 	;;
 
-    darwin8*|darwin9*|darwin10*|darwin11*|darwin12*|darwin13*)
+    darwin8*|darwin9*|darwin1[0-4]*)
         #   Flat Namespace linking                      (Mac OS/X)
         #
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether darwin ld might need -flat_namespace" >&5
@@ -20222,6 +20250,156 @@ $as_echo "$netsnmp_cv_func_kvm_getproc2_LMIBLIBS" >&6; }
  fi
 
 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing kvm_getfiles" >&5
+$as_echo_n "checking for library containing kvm_getfiles... " >&6; }
+if ${netsnmp_cv_func_kvm_getfiles_LMIBLIBS+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  netsnmp_func_search_save_LIBS="$LIBS"
+     netsnmp_target_val="$LMIBLIBS"
+          netsnmp_temp_LIBS="${netsnmp_target_val}  ${LIBS}"
+     netsnmp_result=no
+     LIBS="${netsnmp_temp_LIBS}"
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char kvm_getfiles ();
+int
+main ()
+{
+return kvm_getfiles ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  netsnmp_result="none required"
+else
+  for netsnmp_cur_lib in kvm ; do
+              LIBS="-l${netsnmp_cur_lib} ${netsnmp_temp_LIBS}"
+              cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char kvm_getfiles ();
+int
+main ()
+{
+return kvm_getfiles ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  netsnmp_result=-l${netsnmp_cur_lib}
+                   break
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+          done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     LIBS="${netsnmp_func_search_save_LIBS}"
+     netsnmp_cv_func_kvm_getfiles_LMIBLIBS="${netsnmp_result}"
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $netsnmp_cv_func_kvm_getfiles_LMIBLIBS" >&5
+$as_echo "$netsnmp_cv_func_kvm_getfiles_LMIBLIBS" >&6; }
+ if test "${netsnmp_cv_func_kvm_getfiles_LMIBLIBS}" != "no" ; then
+    if test "${netsnmp_cv_func_kvm_getfiles_LMIBLIBS}" != "none required" ; then
+       LMIBLIBS="${netsnmp_result} ${netsnmp_target_val}"
+    fi
+
+
+ fi
+
+
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing kvm_getfile2" >&5
+$as_echo_n "checking for library containing kvm_getfile2... " >&6; }
+if ${netsnmp_cv_func_kvm_getfile2_LMIBLIBS+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  netsnmp_func_search_save_LIBS="$LIBS"
+     netsnmp_target_val="$LMIBLIBS"
+          netsnmp_temp_LIBS="${netsnmp_target_val}  ${LIBS}"
+     netsnmp_result=no
+     LIBS="${netsnmp_temp_LIBS}"
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char kvm_getfile2 ();
+int
+main ()
+{
+return kvm_getfile2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  netsnmp_result="none required"
+else
+  for netsnmp_cur_lib in kvm ; do
+              LIBS="-l${netsnmp_cur_lib} ${netsnmp_temp_LIBS}"
+              cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char kvm_getfile2 ();
+int
+main ()
+{
+return kvm_getfile2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  netsnmp_result=-l${netsnmp_cur_lib}
+                   break
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+          done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     LIBS="${netsnmp_func_search_save_LIBS}"
+     netsnmp_cv_func_kvm_getfile2_LMIBLIBS="${netsnmp_result}"
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $netsnmp_cv_func_kvm_getfile2_LMIBLIBS" >&5
+$as_echo "$netsnmp_cv_func_kvm_getfile2_LMIBLIBS" >&6; }
+ if test "${netsnmp_cv_func_kvm_getfile2_LMIBLIBS}" != "no" ; then
+    if test "${netsnmp_cv_func_kvm_getfile2_LMIBLIBS}" != "none required" ; then
+       LMIBLIBS="${netsnmp_result} ${netsnmp_target_val}"
+    fi
+
+
+ fi
+
+
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing kvm_getswapinfo" >&5
 $as_echo_n "checking for library containing kvm_getswapinfo... " >&6; }
 if ${netsnmp_cv_func_kvm_getswapinfo_LMIBLIBS+:} false; then :
@@ -20298,7 +20476,7 @@ $as_echo "$netsnmp_cv_func_kvm_getswapinfo_LMIBLIBS" >&6; }
 
 netsnmp_save_LIBS="$LIBS"
 LIBS="$LAGENTLIBS $LMIBLIBS $LIBS"
-for ac_func in kvm_openfiles kvm_getprocs kvm_getproc2 kvm_getswapinfo
+for ac_func in kvm_openfiles kvm_getprocs kvm_getproc2 kvm_getswapinfo kvm_getfiles kvm_getfile2
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
@@ -22676,8 +22854,245 @@ fi
 if test "x$with_nl" != "xno"; then
     case $target_os in
     linux*) # Check for libnl (linux)
+        # The test below verifies whether the libnl-3 package been installed.
+        # This test works as follows:
+        # - If pkg-config was not installed at the time autogen.sh was run,
+        #   the definition of the PKG_CHECK_EXISTS() macro will not be found by
+        #   autogen.sh. Augogen.sh will generate a configure script that prints
+        #   a warning about pkg-config and proceeds as if libnl-3 has not been
+        #   installed.
+        # - If pkg-config was installed at the time autogen.sh was run,
+        #   the generated configure script will try to detect the presence of
+        #   the libnl-3 library by looking up compile and linker flags in the
+        #   file called libnl-3.pc.
+        # - pkg-config settings can be overridden via the configure variables
+        #   LIBNL3_CFLAGS and LIBNL3_LIBS (added by the pkg-config m4 macro's to
+        #   the configure script -- see also ./configure --help).
+        # - The LIBNL3_CFLAGS and LIBNL3_LIBS configure variables can be used
+        #   even if the pkg-config executable is not present on the system on
+        #   which the configure script is run.
+
+
+
+
+
+
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}pkg-config", so it can be a program name with args.
+set dummy ${ac_tool_prefix}pkg-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_PKG_CONFIG+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+PKG_CONFIG=$ac_cv_path_PKG_CONFIG
+if test -n "$PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+$as_echo "$PKG_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_path_PKG_CONFIG"; then
+  ac_pt_PKG_CONFIG=$PKG_CONFIG
+  # Extract the first word of "pkg-config", so it can be a program name with args.
+set dummy pkg-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_ac_pt_PKG_CONFIG+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $ac_pt_PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_ac_pt_PKG_CONFIG="$ac_pt_PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_ac_pt_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+ac_pt_PKG_CONFIG=$ac_cv_path_ac_pt_PKG_CONFIG
+if test -n "$ac_pt_PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_pt_PKG_CONFIG" >&5
+$as_echo "$ac_pt_PKG_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_pt_PKG_CONFIG" = x; then
+    PKG_CONFIG=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    PKG_CONFIG=$ac_pt_PKG_CONFIG
+  fi
+else
+  PKG_CONFIG="$ac_cv_path_PKG_CONFIG"
+fi
+
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=0.9.0
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking pkg-config is at least version $_pkg_min_version" >&5
+$as_echo_n "checking pkg-config is at least version $_pkg_min_version... " >&6; }
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	else
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		PKG_CONFIG=""
+	fi
+fi
+if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libnl-3.0\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libnl-3.0") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+
+pkg_failed=no
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBNL3" >&5
+$as_echo_n "checking for LIBNL3... " >&6; }
+
+if test -n "$LIBNL3_CFLAGS"; then
+    pkg_cv_LIBNL3_CFLAGS="$LIBNL3_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libnl-3.0\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libnl-3.0") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBNL3_CFLAGS=`$PKG_CONFIG --cflags "libnl-3.0" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+if test -n "$LIBNL3_LIBS"; then
+    pkg_cv_LIBNL3_LIBS="$LIBNL3_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libnl-3.0\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libnl-3.0") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBNL3_LIBS=`$PKG_CONFIG --libs "libnl-3.0" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+
+
+
+if test $pkg_failed = yes; then
+   	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi
+        if test $_pkg_short_errors_supported = yes; then
+	        LIBNL3_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "libnl-3.0" 2>&1`
+        else
+	        LIBNL3_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "libnl-3.0" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$LIBNL3_PKG_ERRORS" >&5
+
+	as_fn_error $? "Package requirements (libnl-3.0) were not met:
+
+$LIBNL3_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+Alternatively, you may set the environment variables LIBNL3_CFLAGS
+and LIBNL3_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details." "$LINENO" 5
+elif test $pkg_failed = untried; then
+     	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+Alternatively, you may set the environment variables LIBNL3_CFLAGS
+and LIBNL3_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.
+See \`config.log' for more details" "$LINENO" 5; }
+else
+	LIBNL3_CFLAGS=$pkg_cv_LIBNL3_CFLAGS
+	LIBNL3_LIBS=$pkg_cv_LIBNL3_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+fi
+fi
+
+
         netsnmp_save_CPPFLAGS="$CPPFLAGS"
-        CPPFLAGS="-I/usr/include/libnl3 $CPPFLAGS"
+        CPPFLAGS="${LIBNL3_CFLAGS} $CPPFLAGS"
 
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing nl_connect" >&5
 $as_echo_n "checking for library containing nl_connect... " >&6; }
@@ -22761,7 +23176,7 @@ fi
 
 done
 
-            EXTERNAL_MIBGROUP_INCLUDES="$EXTERNAL_MIBGROUP_INCLUDES -I/usr/include/libnl3"
+            EXTERNAL_MIBGROUP_INCLUDES="$EXTERNAL_MIBGROUP_INCLUDES ${LIBNL3_CFLAGS}"
  else
     CPPFLAGS="$netsnmp_save_CPPFLAGS"
  fi
@@ -23713,6 +24128,33 @@ $as_echo "#define HAVE_BROKEN_LIBMYSQLCLIENT 1" >>confdefs.h
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether my_load_defaults() exists" >&5
+$as_echo_n "checking whether my_load_defaults() exists... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+    #include <my_global.h>
+        #include <my_sys.h>
+int
+main ()
+{
+my_load_defaults("my_init_test")
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define HAVE_MY_LOAD_DEFAULTS 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
   CPPFLAGS="${_cppflags}"
   LIBS="${_libs}"
 
@@ -23924,7 +24366,7 @@ if test "x$install_perl" != "xno" ; then
 
     #       What compiler was used to build the perl binary?
     #
-    if test "xenable_perl_cc_checks" != "xno" ; then
+    if test "x$enable_perl_cc_checks" != "xno" ; then
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Perl cc" >&5
 $as_echo_n "checking for Perl cc... " >&6; }
 
@@ -25132,6 +25574,11 @@ rm -f confcache
 # Checks for library functions.
 ##
 #########################################
+#
+# Portions of this file are copyrighted by:
+# Copyright (c) 2016 VMware, Inc. All rights reserved.
+# Use is subject to license terms specified in the COPYING file
+# distributed with the Net-SNMP package.
 
 ##
 #   Standard checks:
@@ -25753,7 +26200,7 @@ fi
 
 
 #  Agent:
-for ac_func in cgetnext        chown          execv                           gai_strerror                   getgrnam                        gethostname     getloadavg                                     getpid          getpwnam                                       hasmntopt       initgroups                                     if_nameindex    if_indextoname if_nametoindex                  localtime_r     mkstemp        mktime                          poll            regcomp                                        setgid          setgroups                                      setmntent       setuid                                         sigaction       sigblock      sighold                          sigprocmask                                                    statfs          statvfs       stime                            strncasecmp     system                                         uname           usleep
+for ac_func in cgetnext        chown          execv                           forkall         gai_strerror   getgrnam                        gethostname     getloadavg                                     getpid          getpwnam                                       hasmntopt       initgroups                                     if_nameindex    if_indextoname if_nametoindex                  localtime_r     mkstemp        mktime                          poll            regcomp                                        setgid          setgroups                                      setmntent       setuid                                         sigaction       sigblock      sighold                          sigprocmask                                                    statfs          statvfs       stime                            strncasecmp     system                                         uname           usleep
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
@@ -25932,7 +26379,7 @@ fi
 #
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether static inline functions are broken (Unixware)" >&5
 $as_echo_n "checking whether static inline functions are broken (Unixware)... " >&6; }
-if ${netsnmp_cv_c_broken_inline+:} false; then :
+if ${netsnmp_cv_broken_inline+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -25947,15 +26394,6 @@ inline int main_inline_function( void ) {
 
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
-  netsnmp_cv_broken_inline=no
-else
-  netsnmp_cv_broken_inline=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $netsnmp_cv_c_broken_inline" >&5
-$as_echo "$netsnmp_cv_c_broken_inline" >&6; }
-
 
 #       Yes -  static inline functions are broken       (Solaris 2.x)
 #
@@ -25964,8 +26402,18 @@ case "$target_os" in
         netsnmp_cv_broken_inline=yes
         ;;
     *)
+        netsnmp_cv_broken_inline=no
         ;;
 esac
+else
+
+    netsnmp_cv_broken_inline=yes
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $netsnmp_cv_broken_inline" >&5
+$as_echo "$netsnmp_cv_broken_inline" >&6; }
 
 if test "$netsnmp_cv_broken_inline" = yes ; then
 
@@ -26744,6 +27192,7 @@ fi
 ac_fn_c_check_member "$LINENO" "struct uvmexp" "pgswapin" "ac_cv_member_struct_uvmexp_pgswapin" "
     $ac_includes_default
 
+#include <sys/sysctl.h>
 #include <uvm/uvm_extern.h>
 
 "
@@ -29763,6 +30212,11 @@ $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
   fi
 fi
 rm -f confcache
+##
+# Add back in the original CFLAGS setting
+##
+CFLAGS="$noerr_CFLAGS ${CFLAGS#$CFLAGS_without_Werror}"
+export CFLAGS
 
 #
 # define the agent libraries variables
diff --git a/configure.ac b/configure.ac
index ecf761f..687ac1e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -6,6 +6,11 @@
 # Use is subject to license terms specified in the COPYING file
 # distributed with the Net-SNMP package.
 #
+# Portions of this file are copyrighted by:
+# Copyright (c) 2016 VMware, Inc. All rights reserved.
+# Use is subject to license terms specified in the COPYING file
+# distributed with the Net-SNMP package.
+#
 
 #
 # Process this file with autoconf to produce a configure script.
@@ -41,7 +46,16 @@ AC_SUBST(CONFIGURE_OPTIONS)
 #     checks for library functions
 #     checks for system services
 
+m4_include([configure.d/config_net_snmp_config_h])
 m4_include([configure.d/config_project_with_enable])
+##
+# Protect against CFLAGS with -Werror which causes failures for some tests
+#   (e.g. it causes type mismatches in the AC_CV_FUNCS call)
+##
+noerr_CFLAGS="$CFLAGS"
+CFLAGS=`echo $CFLAGS | sed 's/-Werror[[^ ]]*//g'`
+CFLAGS_without_Werror=$CFLAGS
+export CFLAGS
 m4_include([configure.d/config_project_manual])
 m4_include([configure.d/config_os_progs])
 m4_include([configure.d/config_project_paths])
@@ -64,6 +78,11 @@ m4_include([configure.d/config_os_functions])
 m4_include([configure.d/config_os_struct_members])
 m4_include([configure.d/config_os_misc4])
 AC_CACHE_SAVE
+##
+# Add back in the original CFLAGS setting
+##
+CFLAGS="$noerr_CFLAGS ${CFLAGS#$CFLAGS_without_Werror}"
+export CFLAGS
 
 #
 # define the agent libraries variables
diff --git a/configure.d/config_net_snmp_config_h b/configure.d/config_net_snmp_config_h
new file mode 100644
index 0000000..07fac5c
--- /dev/null
+++ b/configure.d/config_net_snmp_config_h
@@ -0,0 +1,820 @@
+AH_TOP([/*
+ * net-snmp configuration header file
+ *
+ * NOTE: DO NOT EDIT include/net-snmp/net-snmp-config.h.in as your changes
+ *       will be overwritten. This content is in acconfig.h and merged
+ *       into include/net-snmp/net-snmp-config.h.in by autoheader.
+ */
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+#ifndef NET_SNMP_CONFIG_H
+#define NET_SNMP_CONFIG_H
+
+
+/* ********* NETSNMP_MARK_BEGIN_AUTOCONF_DEFINITIONS ********* */
+/*
+ * put all autoconf-specific definitions below here
+ *
+ */
+#ifndef NETSNMP_NO_AUTOCONF_DEFINITIONS
+
+/* definitions added by configure on-the-fly */])
+
+AH_BOTTOM([/* end of definitions added by configure on-the-fly */
+
+/* If you have openssl 0.9.7 or above, you likely have AES support. */
+#undef NETSNMP_USE_OPENSSL
+#if (defined(NETSNMP_USE_OPENSSL) && defined(HAVE_OPENSSL_AES_H) && defined(HAVE_AES_CFB128_ENCRYPT)) || defined(NETSNMP_USE_INTERNAL_CRYPTO)
+#define HAVE_AES 1
+#endif
+
+/* define random functions */
+
+#ifndef HAVE_RANDOM
+#ifdef HAVE_LRAND48
+#define random lrand48
+#define srandom(s) srand48(s)
+#else
+#ifdef HAVE_RAND
+#define random rand
+#define srandom(s) srand(s)
+#endif
+#endif
+#endif
+
+/* define signal if DNE */
+
+#ifndef HAVE_SIGNAL
+#ifdef HAVE_SIGSET
+#define signal(a,b) sigset(a,b)
+#endif
+#endif
+
+#ifdef HAVE_DMALLOC_H
+#define DMALLOC_FUNC_CHECK
+#endif
+
+#endif /* NETSNMP_NO_AUTOCONF_DEFINITIONS */
+
+
+
+
+/* ********* NETSNMP_MARK_BEGIN_CLEAN_NAMESPACE ********* */
+/* 
+ * put all new net-snmp-specific definitions here
+ *
+ * all definitions MUST have a NETSNMP_ prefix
+ *
+ */
+
+/* Default (SNMP) version number for the tools to use */
+#define NETSNMP_DEFAULT_SNMP_VERSION 3
+
+/* don't change these values! */
+#define NETSNMP_SNMPV1      0xAAAA       /* readable by anyone */
+#define NETSNMP_SNMPV2ANY   0xA000       /* V2 Any type (includes NoAuth) */
+#define NETSNMP_SNMPV2AUTH  0x8000       /* V2 Authenticated requests only */
+
+/* default list of mibs to load */
+#define NETSNMP_DEFAULT_MIBS "IP-MIB:IF-MIB:TCP-MIB:UDP-MIB:SNMPv2-MIB:RFC1213-MIB"
+
+/* debugging stuff */
+/* if defined, we optimize the code to exclude all debugging calls. */
+#undef NETSNMP_NO_DEBUGGING
+/* ignore the -D flag and always print debugging information */
+#define NETSNMP_ALWAYS_DEBUG 0
+
+/* reverse encoding BER packets is both faster and more efficient in space. */
+#define NETSNMP_USE_REVERSE_ASNENCODING       1
+#define NETSNMP_DEFAULT_ASNENCODING_DIRECTION 1 /* 1 = reverse, 0 = forwards */
+
+/* PERSISTENT_DIRECTORY: If defined, the library is capabile of saving
+   persisant information to this directory in the form of configuration
+   lines: PERSISTENT_DIRECTORY/NAME.persistent.conf */
+#define NETSNMP_PERSISTENT_DIRECTORY "/var/snmp"
+
+/* AGENT_DIRECTORY_MODE: the mode the agents should use to create
+   directories with. Since the data stored here is probably sensitive, it
+   probably should be read-only by root/administrator. */
+#define NETSNMP_AGENT_DIRECTORY_MODE 0700
+
+/* MAX_PERSISTENT_BACKUPS:
+ *   The maximum number of persistent backups the library will try to
+ *   read from the persistent cache directory.  If an application fails to
+ *   close down successfully more than this number of times, data will be lost.
+ */
+#define NETSNMP_MAX_PERSISTENT_BACKUPS 10
+
+/* define the system type include file here */
+#define NETSNMP_SYSTEM_INCLUDE_FILE <net-snmp/system/generic.h>
+
+/* define the machine (cpu) type include file here */
+#define NETSNMP_MACHINE_INCLUDE_FILE <net-snmp/machine/generic.h>
+
+/* define the UDP buffer defaults undefined means use the OS buffers
+ * by default */
+#undef NETSNMP_DEFAULT_SERVER_SEND_BUF
+#undef NETSNMP_DEFAULT_SERVER_RECV_BUF
+#undef NETSNMP_DEFAULT_CLIENT_SEND_BUF
+#undef NETSNMP_DEFAULT_CLIENT_RECV_BUF
+
+/* net-snmp's major path names */
+#undef SNMPLIBPATH
+#undef SNMPSHAREPATH
+#undef SNMPCONFPATH
+#undef SNMPDLMODPATH
+
+/* NETSNMP_LOGFILE:  If defined it closes stdout/err/in and opens this in 
+   out/err's place.  (stdin is closed so that sh scripts won't wait for it) */
+#undef NETSNMP_LOGFILE
+
+/* default system contact */
+#undef NETSNMP_SYS_CONTACT
+
+/* system location */
+#undef NETSNMP_SYS_LOC
+
+/* Use libwrap to handle allow/deny hosts? */
+#undef NETSNMP_USE_LIBWRAP
+
+/* Mib-2 tree Info */
+/* These are the system information variables. */
+
+#define NETSNMP_VERS_DESC   "unknown"             /* overridden at run time */
+#define NETSNMP_SYS_NAME    "unknown"             /* overridden at run time */
+
+/* comment out the second define to turn off functionality for any of
+   these: (See README for details) */
+
+/*   proc PROCESSNAME [MAX] [MIN] */
+#define NETSNMP_PROCMIBNUM 2
+
+/*   exec/shell NAME COMMAND      */
+#define NETSNMP_SHELLMIBNUM 8
+
+/*   swap MIN                     */
+#define NETSNMP_MEMMIBNUM 4
+
+/*   disk DISK MINSIZE            */
+#define NETSNMP_DISKMIBNUM 9
+
+/*   load 1 5 15                  */
+#define NETSNMP_LOADAVEMIBNUM 10
+
+/* which version are you using? This mibloc will tell you */
+#define NETSNMP_VERSIONMIBNUM 100
+
+/* Reports errors the agent runs into */
+/* (typically its "can't fork, no mem" problems) */
+#define NETSNMP_ERRORMIBNUM 101
+
+/* The sub id of EXTENSIBLEMIB returned to queries of
+   .iso.org.dod.internet.mgmt.mib-2.system.sysObjectID.0 */
+#define NETSNMP_AGENTID 250
+
+/* This ID is returned after the AGENTID above.  IE, the resulting
+   value returned by a query to sysObjectID is
+   EXTENSIBLEMIB.AGENTID.???, where ??? is defined below by OSTYPE */
+
+#define NETSNMP_HPUX9ID 1
+#define NETSNMP_SUNOS4ID 2 
+#define NETSNMP_SOLARISID 3
+#define NETSNMP_OSFID 4
+#define NETSNMP_ULTRIXID 5
+#define NETSNMP_HPUX10ID 6
+#define NETSNMP_NETBSD1ID 7
+#define NETSNMP_FREEBSDID 8
+#define NETSNMP_IRIXID 9
+#define NETSNMP_LINUXID 10
+#define NETSNMP_BSDIID 11
+#define NETSNMP_OPENBSDID 12
+#define NETSNMP_WIN32ID 13
+#define NETSNMP_HPUX11ID 14
+#define NETSNMP_AIXID 15
+#define NETSNMP_MACOSXID 16
+#define NETSNMP_DRAGONFLYID 17
+#define NETSNMP_UNKNOWNID 255
+
+#ifdef hpux9
+#define NETSNMP_OSTYPE NETSNMP_HPUX9ID
+#endif
+#ifdef hpux10
+#define NETSNMP_OSTYPE NETSNMP_HPUX10ID
+#endif
+#ifdef hpux11
+#define NETSNMP_OSTYPE NETSNMP_HPUX11ID
+#endif
+#ifdef sunos4
+#define NETSNMP_OSTYPE NETSNMP_SUNOS4ID
+#endif
+#ifdef solaris2
+#define NETSNMP_OSTYPE NETSNMP_SOLARISID
+#endif
+#if defined(osf3) || defined(osf4) || defined(osf5)
+#define NETSNMP_OSTYPE NETSNMP_OSFID
+#endif
+#ifdef ultrix4
+#define NETSNMP_OSTYPE NETSNMP_ULTRIXID
+#endif
+#if defined(netbsd1) || defined(netbsd2)
+#define NETSNMP_OSTYPE NETSNMP_NETBSD1ID
+#endif
+#if defined(__FreeBSD__)
+#define NETSNMP_OSTYPE NETSNMP_FREEBSDID
+#endif
+#if defined(__DragonFly__)
+#define NETSNMP_OSTYPE NETSNMP_DRAGONFLYID
+#endif
+#if defined(irix6) || defined(irix5)
+#define NETSNMP_OSTYPE NETSNMP_IRIXID
+#endif
+#ifdef linux
+#define NETSNMP_OSTYPE NETSNMP_LINUXID
+#endif
+#if defined(bsdi2) || defined(bsdi3) || defined(bsdi4)
+#define NETSNMP_OSTYPE NETSNMP_BSDIID
+#endif
+#if defined(openbsd)
+#define NETSNMP_OSTYPE NETSNMP_OPENBSDID
+#endif
+#ifdef WIN32
+#define NETSNMP_OSTYPE NETSNMP_WIN32ID
+#endif
+#if defined(aix3) || defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
+#define NETSNMP_OSTYPE NETSNMP_AIXID
+#endif
+#if defined(darwin) && (darwin >= 8)
+#define NETSNMP_OSTYPE NETSNMP_MACOSXID
+#endif
+/* unknown */
+#ifndef NETSNMP_OSTYPE
+#define NETSNMP_OSTYPE NETSNMP_UNKNOWNID
+#endif
+
+/* The enterprise number has been assigned by the IANA group.   */
+/* Optionally, this may point to the location in the tree your  */
+/* company/organization has been allocated.                     */
+/* The assigned enterprise number for the NET_SNMP MIB modules. */
+#define NETSNMP_ENTERPRISE_OID			8072
+#define NETSNMP_ENTERPRISE_MIB			1,3,6,1,4,1,8072
+#define NETSNMP_ENTERPRISE_DOT_MIB		1.3.6.1.4.1.8072
+#define NETSNMP_ENTERPRISE_DOT_MIB_LENGTH	7
+
+/* The assigned enterprise number for sysObjectID. */
+#define NETSNMP_SYSTEM_MIB		1,3,6,1,4,1,8072,3,2,NETSNMP_OSTYPE
+#define NETSNMP_SYSTEM_DOT_MIB		1.3.6.1.4.1.8072.3.2.NETSNMP_OSTYPE
+#define NETSNMP_SYSTEM_DOT_MIB_LENGTH	10
+
+/* The assigned enterprise number for notifications. */
+#define NETSNMP_NOTIFICATION_MIB		1,3,6,1,4,1,8072,4
+#define NETSNMP_NOTIFICATION_DOT_MIB		1.3.6.1.4.1.8072.4
+#define NETSNMP_NOTIFICATION_DOT_MIB_LENGTH	8
+
+/* this is the location of the ucdavis mib tree.  It shouldn't be
+   changed, as the places it is used are expected to be constant
+   values or are directly tied to the UCD-SNMP-MIB. */
+#define NETSNMP_UCDAVIS_OID		2021
+#define NETSNMP_UCDAVIS_MIB		1,3,6,1,4,1,2021
+#define NETSNMP_UCDAVIS_DOT_MIB		1.3.6.1.4.1.2021
+#define NETSNMP_UCDAVIS_DOT_MIB_LENGTH	7
+
+/* how long to wait (seconds) for error querys before reseting the error trap.*/
+#define NETSNMP_ERRORTIMELENGTH 600 
+
+/* Exec command to fix PROC problems */
+/* %s will be replaced by the process name in error */
+
+/* #define NETSNMP_PROCFIXCMD "/usr/bin/perl /local/scripts/fixproc %s" */
+
+/* Exec command to fix EXEC problems */
+/* %s will be replaced by the exec/script name in error */
+
+/* #define NETSNMP_EXECFIXCMD "/usr/bin/perl /local/scripts/fixproc %s" */
+
+/* Should exec output Cashing be used (speeds up things greatly), and
+   if so, After how many seconds should the cache re-newed?  Note:
+   Don't define CASHETIME to disable cashing completely */
+
+#define NETSNMP_EXCACHETIME 30
+#define NETSNMP_CACHEFILE ".snmp-exec-cache"
+#define NETSNMP_MAXCACHESIZE (1500*80)   /* roughly 1500 lines max */
+
+/* misc defaults */
+
+/* default of 100 meg minimum if the minimum size is not specified in
+   the config file */
+#define NETSNMP_DEFDISKMINIMUMSPACE 100000
+
+/* default maximum load average before error */
+#define NETSNMP_DEFMAXLOADAVE 12.0
+
+/* max times to loop reading output from execs. */
+/* Because of sleep(1)s, this will also be time to wait (in seconds) for exec
+   to finish */
+#define NETSNMP_MAXREADCOUNT 100
+
+/* Set if snmpgets should block and never timeout */
+/* The original CMU code had this hardcoded as = 1 */
+#define NETSNMP_SNMPBLOCK 1
+
+/* How long to wait before restarting the agent after a snmpset to
+   EXTENSIBLEMIB.VERSIONMIBNUM.VERRESTARTAGENT.  This is
+   necessary to finish the snmpset reply before restarting. */
+#define NETSNMP_RESTARTSLEEP 5
+
+/* UNdefine to allow specifying zero-length community string */
+/* #define NETSNMP_NO_ZEROLENGTH_COMMUNITY 1 */
+
+/* Number of community strings to store */
+#define NETSNMP_NUM_COMMUNITIES	5
+
+/* internal define */
+#define NETSNMP_LASTFIELD -1
+
+/*  Pluggable transports.  */
+
+/*  This is defined if support for the UDP/IP transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_UDP_DOMAIN
+
+/*  This is defined if support for the "callback" transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
+
+/*  This is defined if support for the TCP/IP transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_TCP_DOMAIN
+
+/*  This is defined if support for the Unix transport domain
+    (a.k.a. "local IPC") is available.  */
+#undef NETSNMP_TRANSPORT_UNIX_DOMAIN
+
+/*  This is defined if support for the AAL5 PVC transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+
+/*  This is defined if support for the IPX transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_IPX_DOMAIN
+
+/*  This is defined if support for the UDP/IPv6 transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
+
+/*  This is defined if support for the TCP/IPv6 transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
+
+/*  This is defined if support for the TLS transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_TLSBASE_DOMAIN
+
+/*  This is defined if support for the Alias transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_ALIAS_DOMAIN
+
+/*  This is defined if support for the SSH transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_SSH_DOMAIN
+
+/*  This is defined if support for the DTLS/UDP transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_DTLSUDP_DOMAIN
+
+/*  This is defined if support for the TLS/TCP transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_TLSTCP_DOMAIN
+
+/*  This is defined if support for stdin/out transport domain is available.   */
+#undef NETSNMP_TRANSPORT_STD_DOMAIN
+
+/*  This is defined if support for the IPv4Base transport domain is available.   */
+#undef NETSNMP_TRANSPORT_IPV4BASE_DOMAIN
+
+/* define this if the USM security module is available */
+#undef NETSNMP_SECMOD_USM
+
+/* define this if the KSM (kerberos based snmp) security module is available */
+#undef NETSNMP_SECMOD_KSM
+
+/* define this if the local security module is available */
+#undef NETSNMP_SECMOD_LOCALSM
+
+/* define if configured as a "mini-agent" */
+#undef NETSNMP_MINI_AGENT
+
+/* this is the location of the net-snmp mib tree.  It shouldn't be
+   changed, as the places it is used are expected to be constant
+   values or are directly tied to the UCD-SNMP-MIB. */
+#define NETSNMP_OID		8072
+#define NETSNMP_MIB		1,3,6,1,4,1,8072
+#define NETSNMP_DOT_MIB		1.3.6.1.4.1.8072
+#define NETSNMP_DOT_MIB_LENGTH	7
+
+/* pattern for temporary file names */
+#define NETSNMP_TEMP_FILE_PATTERN "/tmp/snmpdXXXXXX"
+
+/*
+ * this must be before the system/machine includes, to allow them to
+ * override and turn off inlining. To do so, they should do the
+ * following:
+ *
+ *    #undef NETSNMP_ENABLE_INLINE
+ *    #define NETSNMP_ENABLE_INLINE 0
+ *
+ * A user having problems with their compiler can also turn off
+ * the use of inline by defining NETSNMP_NO_INLINE via their cflags:
+ *
+ *    -DNETSNMP_NO_INLINE
+ *
+ * Header and source files should only test against NETSNMP_USE_INLINE:
+ *
+ *   #ifdef NETSNMP_USE_INLINE
+ *   NETSNMP_INLINE function(int parm) { return parm -1; }
+ *   #endif
+ *
+ * Functions which should be static, regardless of whether or not inline
+ * is available or enabled should use the NETSNMP_STATIC_INLINE macro,
+ * like so:
+ *
+ *    NETSNMP_STATIC_INLINE function(int parm) { return parm -1; }
+ *
+ * NOT like this:
+ *
+ *    static NETSNMP_INLINE function(int parm) { return parm -1; }
+ *
+ */
+#ifdef NETSNMP_BROKEN_INLINE
+#   define NETSNMP_ENABLE_INLINE 0
+#else
+#   define NETSNMP_ENABLE_INLINE 1
+#endif
+
+#include NETSNMP_SYSTEM_INCLUDE_FILE
+#include NETSNMP_MACHINE_INCLUDE_FILE
+
+#if NETSNMP_ENABLE_INLINE && !defined(NETSNMP_NO_INLINE)
+#   define NETSNMP_USE_INLINE 1
+#   ifndef NETSNMP_INLINE
+#      define NETSNMP_INLINE inline
+#   endif
+#   ifndef NETSNMP_STATIC_INLINE
+#      define NETSNMP_STATIC_INLINE static inline
+#   endif
+#else
+#   define NETSNMP_INLINE 
+#   define NETSNMP_STATIC_INLINE static
+#endif
+
+#ifndef NETSNMP_IMPORT
+#  define NETSNMP_IMPORT extern
+#endif
+
+/* comment the next line if you are compiling with libsnmp.h 
+   and are not using the UC-Davis SNMP library. */
+#define UCD_SNMP_LIBRARY 1
+
+/* final conclusion on nlist usage */
+#if defined(HAVE_NLIST) && defined(HAVE_STRUCT_NLIST_N_VALUE) && !defined(NETSNMP_DONT_USE_NLIST) && defined(HAVE_KMEM) && !defined(NETSNMP_NO_KMEM_USAGE)
+#define NETSNMP_CAN_USE_NLIST
+#endif
+
+
+/* ********* NETSNMP_MARK_BEGIN_LEGACY_DEFINITIONS *********/
+/* 
+ * existing definitions prior to Net-SNMP 5.4
+ *
+ * do not add anything new here
+ *
+ */
+
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+
+#ifdef NETSNMP_DEFAULT_SNMP_VERSION
+# define DEFAULT_SNMP_VERSION NETSNMP_DEFAULT_SNMP_VERSION
+#endif
+
+#ifdef NETSNMP_SNMPV1
+# define SNMPV1 NETSNMP_SNMPV1
+#endif
+
+#ifdef NETSNMP_SNMPV2ANY
+# define SNMPV2ANY NETSNMP_SNMPV2ANY
+#endif
+
+#ifdef NETSNMP_SNMPV2AUTH
+# define SNMPV2AUTH NETSNMP_SNMPV2AUTH
+#endif
+
+#ifdef NETSNMP_DEFAULT_MIBS
+# define DEFAULT_MIBS NETSNMP_DEFAULT_MIBS
+#endif
+
+#ifdef NETSNMP_DEFAULT_MIBDIRS
+# define DEFAULT_MIBDIRS NETSNMP_DEFAULT_MIBDIRS
+#endif
+
+#ifdef NETSNMP_DEFAULT_MIBFILES
+# define DEFAULT_MIBFILES NETSNMP_DEFAULT_MIBFILES
+#endif
+
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+# define OPAQUE_SPECIAL_TYPES NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+#endif
+
+#ifdef NETSNMP_ENABLE_SCAPI_AUTHPRIV
+# define SCAPI_AUTHPRIV NETSNMP_ENABLE_SCAPI_AUTHPRIV
+#endif
+
+#ifdef NETSNMP_USE_INTERNAL_MD5
+# define USE_INTERNAL_MD5 NETSNMP_USE_INTERNAL_MD5
+#endif
+
+#ifdef NETSNMP_USE_PKCS11
+# define USE_PKCS NETSNMP_USE_PKCS11
+#endif
+
+#ifdef NETSNMP_USE_OPENSSL
+# define USE_OPENSSL NETSNMP_USE_OPENSSL
+#endif
+
+#ifdef NETSNMP_NO_DEBUGGING
+# define SNMP_NO_DEBUGGING NETSNMP_NO_DEBUGGING
+#endif
+
+#ifdef NETSNMP_ALWAYS_DEBUG
+# define SNMP_ALWAYS_DEBUG NETSNMP_ALWAYS_DEBUG
+#endif
+
+#ifdef NETSNMP_USE_REVERSE_ASNENCODING
+# define USE_REVERSE_ASNENCODING NETSNMP_USE_REVERSE_ASNENCODING
+#endif
+#ifdef NETSNMP_DEFAULT_ASNENCODING_DIRECTION
+# define DEFAULT_ASNENCODING_DIRECTION NETSNMP_DEFAULT_ASNENCODING_DIRECTION
+#endif
+
+#define PERSISTENT_DIRECTORY NETSNMP_PERSISTENT_DIRECTORY
+#define PERSISTENT_MASK NETSNMP_PERSISTENT_MASK
+#define AGENT_DIRECTORY_MODE NETSNMP_AGENT_DIRECTORY_MODE
+#define MAX_PERSISTENT_BACKUPS NETSNMP_MAX_PERSISTENT_BACKUPS
+#define SYSTEM_INCLUDE_FILE NETSNMP_SYSTEM_INCLUDE_FILE
+#define MACHINE_INCLUDE_FILE NETSNMP_MACHINE_INCLUDE_FILE
+
+#ifdef NETSNMP_DEFAULT_SERVER_SEND_BUF
+# define DEFAULT_SERVER_SEND_BUF NETSNMP_DEFAULT_SERVER_SEND_BUF
+#endif
+#ifdef NETSNMP_DEFAULT_SERVER_RECV_BUF
+# define DEFAULT_SERVER_RECV_BUF NETSNMP_DEFAULT_SERVER_RECV_BUF
+#endif
+#ifdef NETSNMP_DEFAULT_CLIENT_SEND_BUF
+# define DEFAULT_CLIENT_SEND_BUF NETSNMP_DEFAULT_CLIENT_SEND_BUF
+#endif
+#ifdef NETSNMP_DEFAULT_CLIENT_RECV_BUF
+# define DEFAULT_CLIENT_RECV_BUF NETSNMP_DEFAULT_CLIENT_RECV_BUF
+#endif
+
+#ifdef NETSNMP_LOGFILE
+# define LOGFILE NETSNMP_LOGFILE
+#endif
+
+#ifdef NETSNMP_SYS_CONTACT
+# define SYS_CONTACT NETSNMP_SYS_CONTACT
+#endif
+
+#ifdef NETSNMP_SYS_LOC
+# define SYS_LOC NETSNMP_SYS_LOC
+#endif
+
+#ifdef NETSNMP_USE_LIBWRAP
+# define USE_LIBWRAP NETSNMP_USE_LIBWRAP
+#endif
+
+#ifdef NETSNMP_ENABLE_TESTING_CODE 
+# define SNMP_TESTING_CODE NETSNMP_ENABLE_TESTING_CODE
+#endif
+
+#ifdef NETSNMP_NO_ROOT_ACCESS
+# define NO_ROOT_ACCESS NETSNMP_NO_ROOT_ACCESS
+#endif
+
+#ifdef NETSNMP_NO_KMEM_USAGE
+# define NO_KMEM_USAGE NETSNMP_NO_KMEM_USAGE
+#endif
+
+#ifdef NETSNMP_NO_DUMMY_VALUES
+# define NO_DUMMY_VALUES NETSNMP_NO_DUMMY_VALUES
+#endif
+
+#define VERS_DESC     NETSNMP_VERS_DESC
+#define SYS_NAME      NETSNMP_SYS_NAME
+
+#define PROCMIBNUM    NETSNMP_PROCMIBNUM
+#define SHELLMIBNUM   NETSNMP_SHELLMIBNUM
+#define MEMMIBNUM     NETSNMP_MEMMIBNUM
+#define DISKMIBNUM    NETSNMP_DISKMIBNUM
+
+#define LOADAVEMIBNUM NETSNMP_LOADAVEMIBNUM
+#define VERSIONMIBNUM NETSNMP_VERSIONMIBNUM
+#define ERRORMIBNUM   NETSNMP_ERRORMIBNUM
+#define AGENTID       NETSNMP_AGENTID
+
+#define HPUX9ID       NETSNMP_HPUX9ID
+#define SUNOS4ID      NETSNMP_SUNOS4ID
+#define SOLARISID     NETSNMP_SOLARISID
+#define OSFID         NETSNMP_OSFID
+#define ULTRIXID      NETSNMP_ULTRIXID
+#define HPUX10ID      NETSNMP_HPUX10ID
+#define NETBSD1ID     NETSNMP_NETBSD1ID
+#define FREEBSDID     NETSNMP_FREEBSDID
+#define IRIXID        NETSNMP_IRIXID
+#define LINUXID       NETSNMP_LINUXID
+#define BSDIID        NETSNMP_BSDIID
+#define OPENBSDID     NETSNMP_OPENBSDID
+#define WIN32ID       NETSNMP_WIN32ID
+#define HPUX11ID      NETSNMP_HPUX11ID
+#define AIXID         NETSNMP_AIXID
+#define MACOSXID      NETSNMP_MACOSXID
+#define UNKNOWNID     NETSNMP_UNKNOWNID
+
+#define ENTERPRISE_OID            NETSNMP_ENTERPRISE_OID
+#define ENTERPRISE_MIB            NETSNMP_ENTERPRISE_MIB
+#define ENTERPRISE_DOT_MIB        NETSNMP_ENTERPRISE_DOT_MIB
+#define ENTERPRISE_DOT_MIB_LENGTH NETSNMP_ENTERPRISE_DOT_MIB_LENGTH
+
+#define SYSTEM_MIB		  NETSNMP_SYSTEM_MIB
+#define SYSTEM_DOT_MIB		  NETSNMP_SYSTEM_DOT_MIB
+#define SYSTEM_DOT_MIB_LENGTH	  NETSNMP_SYSTEM_DOT_MIB_LENGTH
+
+#define NOTIFICATION_MIB	    NETSNMP_NOTIFICATION_MIB	
+#define NOTIFICATION_DOT_MIB	    NETSNMP_NOTIFICATION_DOT_MIB
+#define NOTIFICATION_DOT_MIB_LENGTH NETSNMP_NOTIFICATION_DOT_MIB_LENGTH
+
+#define UCDAVIS_OID		  NETSNMP_UCDAVIS_OID
+#define UCDAVIS_MIB		  NETSNMP_UCDAVIS_MIB
+#define UCDAVIS_DOT_MIB		  NETSNMP_UCDAVIS_DOT_MIB
+#define UCDAVIS_DOT_MIB_LENGTH	  NETSNMP_UCDAVIS_DOT_MIB_LENGTH
+
+#define ERRORTIMELENGTH NETSNMP_ERRORTIMELENGTH
+
+#ifdef NETSNMP_PROCFIXCMD
+# define PROCFIXCMD NETSNMP_PROCFIXCMD
+#endif
+
+#ifdef NETSNMP_EXECFIXCMD
+# define EXECFIXCMD NETSNMP_EXECFIXCMD
+#endif
+
+#define EXCACHETIME  NETSNMP_EXCACHETIME
+#define CACHEFILE    NETSNMP_CACHEFILE
+#define MAXCACHESIZE NETSNMP_MAXCACHESIZE
+
+#define DEFDISKMINIMUMSPACE NETSNMP_DEFDISKMINIMUMSPACE
+#define DEFMAXLOADAVE NETSNMP_DEFMAXLOADAVE
+#define MAXREADCOUNT NETSNMP_MAXREADCOUNT
+
+#define SNMPBLOCK NETSNMP_SNMPBLOCK
+#define RESTARTSLEEP NETSNMP_RESTARTSLEEP
+
+#define NUM_COMMUNITIES	NETSNMP_NUM_COMMUNITIES
+
+#ifdef NETSNMP_NO_ZEROLENGTH_COMMUNITY
+# define NO_ZEROLENGTH_COMMUNITY NETSNMP_NO_ZEROLENGTH_COMMUNITY
+#endif
+
+#define LASTFIELD NETSNMP_LASTFIELD
+
+#define CONFIGURE_OPTIONS NETSNMP_CONFIGURE_OPTIONS
+
+#ifdef NETSNMP_TRANSPORT_UDP_DOMAIN
+# define SNMP_TRANSPORT_UDP_DOMAIN NETSNMP_TRANSPORT_UDP_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
+# define SNMP_TRANSPORT_CALLBACK_DOMAIN NETSNMP_TRANSPORT_CALLBACK_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_TCP_DOMAIN
+# define SNMP_TRANSPORT_TCP_DOMAIN NETSNMP_TRANSPORT_TCP_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_UNIX_DOMAIN
+# define SNMP_TRANSPORT_UNIX_DOMAIN NETSNMP_TRANSPORT_UNIX_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+# define SNMP_TRANSPORT_AAL5PVC_DOMAIN NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_IPX_DOMAIN
+# define SNMP_TRANSPORT_IPX_DOMAIN NETSNMP_TRANSPORT_IPX_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
+# define SNMP_TRANSPORT_UDPIPV6_DOMAIN NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
+# define SNMP_TRANSPORT_TCPIPV6_DOMAIN NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_TLS_DOMAIN
+# define SNMP_TRANSPORT_TLS_DOMAIN NETSNMP_TRANSPORT_TLS_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_STD_DOMAIN
+# define SNMP_TRANSPORT_STD_DOMAIN NETSNMP_TRANSPORT_STD_DOMAIN
+#endif
+
+#ifdef NETSNMP_SECMOD_USM
+# define SNMP_SECMOD_USM NETSNMP_SECMOD_USM
+#endif
+
+#ifdef NETSNMP_SECMOD_KSM
+# define SNMP_SECMOD_KSM NETSNMP_SECMOD_KSM
+#endif
+
+#ifdef NETSNMP_SECMOD_LOCALSM 
+# define SNMP_SECMOD_LOCALSM NETSNMP_SECMOD_LOCALSM
+#endif
+
+#ifdef NETSNMP_REENTRANT
+# define NS_REENTRANT NETSNMP_REENTRANT
+#endif
+
+#ifdef NETSNMP_ENABLE_IPV6
+# define INET6 NETSNMP_ENABLE_IPV6
+#endif
+
+#ifdef NETSNMP_ENABLE_LOCAL_SMUX
+# define LOCAL_SMUX NETSNMP_ENABLE_LOCAL_SMUX
+#endif
+
+#ifdef NETSNMP_AGENTX_DOM_SOCK_ONLY
+# define AGENTX_DOM_SOCK_ONLY NETSNMP_AGENTX_DOM_SOCK_ONLY
+#endif
+
+#ifdef NETSNMP_SNMPTRAPD_DISABLE_AGENTX
+# define SNMPTRAPD_DISABLE_AGENTX
+#endif
+
+#ifdef NETSNMP_USE_KERBEROS_MIT
+# define MIT_NEW_CRYPTO NETSNMP_USE_KERBEROS_MIT
+#endif
+
+#ifdef NETSNMP_USE_KERBEROS_HEIMDAL
+# define HEIMDAL NETSNMP_USE_KERBEROS_HEIMDAL
+#endif
+
+#ifdef NETSNMP_AGENTX_SOCKET
+# define AGENTX_SOCKET NETSNMP_AGENTX_SOCKET
+#endif
+
+#ifdef NETSNMP_DISABLE_MIB_LOADING
+# define DISABLE_MIB_LOADING NETSNMP_DISABLE_MIB_LOADING
+#endif
+
+#ifdef NETSNMP_DISABLE_SNMPV1
+# define DISABLE_SNMPV1 NETSNMP_DISABLE_SNMPV1
+#endif
+
+#ifdef NETSNMP_DISABLE_SNMPV2C
+# define DISABLE_SNMPV2C NETSNMP_DISABLE_SNMPV2C
+#endif
+
+#ifdef NETSNMP_DISABLE_SET_SUPPORT
+# define DISABLE_SET_SUPPORT NETSNMP_DISABLE_SET_SUPPORT
+#endif
+
+#ifdef NETSNMP_DISABLE_DES
+# define DISABLE_DES NETSNMP_DISABLE_DES
+#endif
+
+#ifdef NETSNMP_DISABLE_MD5
+# define DISABLE_MD5 NETSNMP_DISABLE_MD5
+#endif
+
+#ifdef NETSNMP_DONT_USE_NLIST
+# define DONT_USE_NLIST NETSNMP_DONT_USE_NLIST
+#endif
+
+#ifdef NETSNMP_CAN_USE_NLIST
+# define CAN_USE_NLIST NETSNMP_CAN_USE_NLIST
+#endif
+
+#ifdef NETSNMP_CAN_USE_SYSCTL
+# define CAN_USE_SYSCTL NETSNMP_CAN_USE_SYSCTL
+#endif
+
+#endif /* NETSNMP_NO_LEGACY_DEFINITIONS */
+
+
+#endif /* NET_SNMP_CONFIG_H */])
diff --git a/configure.d/config_os_functions b/configure.d/config_os_functions
index 3c5385b..46a1a7f 100644
--- a/configure.d/config_os_functions
+++ b/configure.d/config_os_functions
@@ -4,6 +4,11 @@
 # Checks for library functions.
 ##
 #########################################
+#
+# Portions of this file are copyrighted by:
+# Copyright (c) 2016 VMware, Inc. All rights reserved.
+# Use is subject to license terms specified in the COPYING file
+# distributed with the Net-SNMP package.
 
 ##
 #   Standard checks:
@@ -88,7 +93,7 @@ AC_REPLACE_FUNCS([getopt        inet_ntop     inet_pton        ] dnl
 
 #  Agent:
 AC_CHECK_FUNCS([cgetnext        chown          execv           ] dnl
-               [gai_strerror                   getgrnam        ] dnl
+               [forkall         gai_strerror   getgrnam        ] dnl
                [gethostname     getloadavg                     ] dnl
                [getpid          getpwnam                       ] dnl
                [hasmntopt       initgroups                     ] dnl
@@ -190,7 +195,7 @@ fi
 #       Whether static inline functions are broken      (SCO Unixware)
 #
 AC_CACHE_CHECK([[whether static inline functions are broken (Unixware)]],
-                [netsnmp_cv_c_broken_inline],
+                [netsnmp_cv_broken_inline],
     AC_COMPILE_IFELSE([AC_LANG_SOURCE([
 static inline int nested_inline_function(void) {
   return 0;
@@ -198,11 +203,7 @@ static inline int nested_inline_function(void) {
 inline int main_inline_function( void ) {
   return nested_inline_function();
 }
-    ])],
-    netsnmp_cv_broken_inline=no,
-    netsnmp_cv_broken_inline=yes))
-
-
+    ])], [[
 #       Yes -  static inline functions are broken       (Solaris 2.x)
 #
 case "$target_os" in
@@ -210,8 +211,11 @@ case "$target_os" in
         netsnmp_cv_broken_inline=yes
         ;;
     *)
+        netsnmp_cv_broken_inline=no
         ;;
-esac
+esac]], [
+    netsnmp_cv_broken_inline=yes]
+))
 
 if test "$netsnmp_cv_broken_inline" = yes ; then
   AC_DEFINE(NETSNMP_BROKEN_INLINE, 1,
diff --git a/configure.d/config_os_libs1 b/configure.d/config_os_libs1
index 35f052a..31840a4 100644
--- a/configure.d/config_os_libs1
+++ b/configure.d/config_os_libs1
@@ -79,10 +79,12 @@ NETSNMP_SEARCH_LIBS(kvm_read, kvm,,,, LAGENTLIBS)
 NETSNMP_SEARCH_LIBS(kvm_openfiles, kvm,,,, LAGENTLIBS)
 NETSNMP_SEARCH_LIBS(kvm_getprocs, kvm,,,, LMIBLIBS)
 NETSNMP_SEARCH_LIBS(kvm_getproc2, kvm,,,, LMIBLIBS)
+NETSNMP_SEARCH_LIBS(kvm_getfiles, kvm,,,, LMIBLIBS)
+NETSNMP_SEARCH_LIBS(kvm_getfile2, kvm,,,, LMIBLIBS)
 NETSNMP_SEARCH_LIBS(kvm_getswapinfo, kvm,,,, LMIBLIBS)
 netsnmp_save_LIBS="$LIBS"
 LIBS="$LAGENTLIBS $LMIBLIBS $LIBS"
-AC_CHECK_FUNCS([kvm_openfiles kvm_getprocs kvm_getproc2 kvm_getswapinfo])
+AC_CHECK_FUNCS([kvm_openfiles kvm_getprocs kvm_getproc2 kvm_getswapinfo kvm_getfiles kvm_getfile2])
 LIBS="$netsnmp_save_LIBS"
 
 #
diff --git a/configure.d/config_os_libs2 b/configure.d/config_os_libs2
index 47491e2..6b8a103 100644
--- a/configure.d/config_os_libs2
+++ b/configure.d/config_os_libs2
@@ -225,11 +225,37 @@ fi
 if test "x$with_nl" != "xno"; then
     case $target_os in
     linux*) # Check for libnl (linux)
+        # The test below verifies whether the libnl-3 package been installed.
+        # This test works as follows:
+        # - If pkg-config was not installed at the time autogen.sh was run,
+        #   the definition of the PKG_CHECK_EXISTS() macro will not be found by
+        #   autogen.sh. Augogen.sh will generate a configure script that prints
+        #   a warning about pkg-config and proceeds as if libnl-3 has not been
+        #   installed.
+        # - If pkg-config was installed at the time autogen.sh was run,
+        #   the generated configure script will try to detect the presence of
+        #   the libnl-3 library by looking up compile and linker flags in the
+        #   file called libnl-3.pc.
+        # - pkg-config settings can be overridden via the configure variables
+        #   LIBNL3_CFLAGS and LIBNL3_LIBS (added by the pkg-config m4 macro's to
+        #   the configure script -- see also ./configure --help).
+        # - The LIBNL3_CFLAGS and LIBNL3_LIBS configure variables can be used
+        #   even if the pkg-config executable is not present on the system on
+        #   which the configure script is run.
+        ifdef(
+          [PKG_CHECK_EXISTS],
+          [PKG_CHECK_EXISTS([libnl-3.0],
+            [PKG_CHECK_MODULES([LIBNL3], [libnl-3.0])])
+          ],
+          AC_MSG_WARN([pkg-config has not been installed or is too old.])
+          AC_MSG_WARN([Detection of libnl-3.0 will be skipped.])
+        )
+
         netsnmp_save_CPPFLAGS="$CPPFLAGS"
-        CPPFLAGS="-I/usr/include/libnl3 $CPPFLAGS"
+        CPPFLAGS="${LIBNL3_CFLAGS} $CPPFLAGS"
         NETSNMP_SEARCH_LIBS(nl_connect, nl-3,
             [AC_CHECK_HEADERS(netlink/netlink.h)
-            EXTERNAL_MIBGROUP_INCLUDES="$EXTERNAL_MIBGROUP_INCLUDES -I/usr/include/libnl3"],
+            EXTERNAL_MIBGROUP_INCLUDES="$EXTERNAL_MIBGROUP_INCLUDES ${LIBNL3_CFLAGS}"],
             [CPPFLAGS="$netsnmp_save_CPPFLAGS"], [], [], [LMIBLIBS])
         if test "x$ac_cv_header_netlink_netlink_h" != xyes; then
             NETSNMP_SEARCH_LIBS(nl_connect, nl, [
@@ -485,6 +511,16 @@ if test "x$with_mysql" = "xyes" ; then
       [AC_MSG_RESULT(no)
        AC_DEFINE([HAVE_BROKEN_LIBMYSQLCLIENT], 1,
                  [Define if using MY_INIT() causes a linker error])])
+  AC_MSG_CHECKING([whether my_load_defaults() exists])
+  AC_LINK_IFELSE([
+    AC_LANG_PROGRAM(
+      [[#include <my_global.h>
+        #include <my_sys.h>]],
+      [[my_load_defaults("my_init_test")]])],
+      [AC_MSG_RESULT(yes)
+       AC_DEFINE([HAVE_MY_LOAD_DEFAULTS], 1,
+                 [Define if having my_load_defaults])],
+      [AC_MSG_RESULT(no)])
   CPPFLAGS="${_cppflags}"
   LIBS="${_libs}"
   AC_MSG_CACHE_ADD(MYSQL Trap Logging:         enabled)
diff --git a/configure.d/config_os_progs b/configure.d/config_os_progs
index 160134c..3cf8037 100644
--- a/configure.d/config_os_progs
+++ b/configure.d/config_os_progs
@@ -53,8 +53,8 @@ fi
 AC_CHECK_PROGS(FIND,   find)
 AC_CHECK_PROGS(WHOAMI, whoami logname, whoami)
 
-AC_PATH_PROG(AUTOCONF,    autoconf)
-AC_PATH_PROG(AUTOHEADER,  autoheader)
+AC_PATH_PROG(AUTOCONF,    autoconf,   [:])
+AC_PATH_PROG(AUTOHEADER,  autoheader, [:])
 AC_PATH_PROG([PERLPROG],  perl)
 AC_PATH_PROG([PSPROG],    ps)
 AC_PATH_PROG([PYTHONPROG],python)
@@ -62,15 +62,6 @@ AC_PATH_PROG([PYTHONPROG],python)
 AC_PATH_PROG([UNAMEPROG], uname)
 AC_DEFINE_UNQUOTED(UNAMEPROG,"$UNAMEPROG", [Where is the uname command])
 
-if test "x$ac_cv_prog_AUTOCONF" = "x"; then
-	AUTOCONF=":"
-	AC_SUBST(AUTOCONF)
-fi
-if test "x$ac_cv_prog_AUTOHEADER" = "x"; then
-	AUTOHEADER=":"
-	AC_SUBST(AUTOHEADER)
-fi
-
 MAKE=${MAKE-"make"}
 $MAKE -v -f /dev/null 2>/dev/null | $GREP GNU >/dev/null
 have_gnu_make=$?
@@ -363,6 +354,8 @@ esac
 #   Compiler flags:
 #
 
+CFLAGS="-DNETSNMP_REMOVE_U64 $CFLAGS"
+
 # The Net-SNMP source code is not strict-aliasing safe, so add
 # -fno-strict-aliasing to $CFLAGS if the compiler supports it.
 AC_MSG_CHECKING([whether the compiler supports -fno-strict-aliasing])
@@ -401,7 +394,7 @@ case $target_os in
 	fi
 	;;
 
-    darwin8*|darwin9*|darwin10*|darwin11*|darwin12*|darwin13*)
+    darwin8*|darwin9*|darwin1[[0-4]]*)
         #   Flat Namespace linking                      (Mac OS/X)
         #
         AC_MSG_CHECKING([whether darwin ld might need -flat_namespace])
diff --git a/configure.d/config_os_struct_members b/configure.d/config_os_struct_members
index 7f6b2c0..6a6518c 100644
--- a/configure.d/config_os_struct_members
+++ b/configure.d/config_os_struct_members
@@ -140,6 +140,7 @@ AC_CHECK_MEMBERS([struct mbstat.m_clusters,
 AC_CHECK_MEMBERS([struct uvmexp.pgswapin],,,[
     AC_INCLUDES_DEFAULT()
     [
+#include <sys/sysctl.h>
 #include <uvm/uvm_extern.h>
     ]])
 
diff --git a/configure.d/config_project_perl_python b/configure.d/config_project_perl_python
index 23f8c7e..475c843 100644
--- a/configure.d/config_project_perl_python
+++ b/configure.d/config_project_perl_python
@@ -84,7 +84,7 @@ if test "x$install_perl" != "xno" ; then
 
     #       What compiler was used to build the perl binary?
     #
-    if test "xenable_perl_cc_checks" != "xno" ; then
+    if test "x$enable_perl_cc_checks" != "xno" ; then
         AC_MSG_CHECKING([for Perl cc])
         changequote(, )
         PERLCC=`$myperl -V:cc | $myperl -n -e 'print if (s/^\s*cc=.([-=\w\s\/]+).;\s*/$1/);'`
diff --git a/configure.d/config_project_with_enable b/configure.d/config_project_with_enable
index 61ba026..1fe4d02 100644
--- a/configure.d/config_project_with_enable
+++ b/configure.d/config_project_with_enable
@@ -426,11 +426,13 @@ if test "x$with_opaque_special_types" != "xno"; then
 fi
 
 NETSNMP_ARG_ENABLE(ipv6,
-[  --enable-ipv6                   Generate IPv6 ready version.],
-    [if test "x$enable_ipv6" = "xyes"; then
-      AC_DEFINE(NETSNMP_ENABLE_IPV6, 1,
-        [define if you want to enable IPv6 support])
-    fi])
+[  --disable-ipv6                  Disable IPv6 support.],
+    [],dnl default to "yes"
+    [enable_ipv6="yes"])
+if test "x$enable_ipv6" != "xno"; then
+  AC_DEFINE(NETSNMP_ENABLE_IPV6, 1,
+      [define if you want to enable IPv6 support])
+fi
 
 NETSNMP_ARG_WITH(logfile,
 [  --with-logfile="location"       Default log file location for snmpd.],
diff --git a/dist/makerelease.xml b/dist/makerelease.xml
index 021a2b7..84936bd 100644
--- a/dist/makerelease.xml
+++ b/dist/makerelease.xml
@@ -677,15 +677,6 @@
     </step>
     <step type="section" title="Advertise it!">
       <steps>
-	<step type="system" pause="1" title="Add note to the news system">
-	  <text>Add a note to the source forge news system:
-
-	    http://sourceforge.net/news/submit.php?group_id=12694
-	  </text>
-	  <commands>
-	    <command>echo firefox 'http://sourceforge.net/news/submit.php?group_id=12694'</command>
-	  </commands>
-	</step>
 	<step type="informational" pause="1">
 	  <text>Send an announcement message to one of the following
 	  mailing lists based on its type:
@@ -700,18 +691,9 @@
 	</step>
 	<step type="informational" skipunless="'{RELEASETYPE}' eq 'full'" pause="1">
 	  <text>Update the topic on the #Net-SNMP channel if this is a
-	    trunk based release.
+	    trunk based release (or the latest on the top most patch tree).
 	  </text>
 	</step>
-	<step type="system" skipunless="'{RELEASETYPE}' eq 'full'" pause="1">
-	  <text>Update the freshmeat listing (Wes needs to do this):
-
-	    http://freshmeat.net/projects/net-snmp/
-	  </text>
-	  <commands>
-	    <command>echo firefox http://freshmeat.net/projects/net-snmp/</command>
-	  </commands>
-	</step>
       </steps>
     </step>
     <step type="informational" skipunless="'{RELEASETYPE}' eq 'full'" pause="1">
diff --git a/dist/run-autoconf b/dist/run-autoconf
index c0f1eec..6bf4ead 100755
--- a/dist/run-autoconf
+++ b/dist/run-autoconf
@@ -10,6 +10,10 @@ for path in $searchprefixes ; do
 	prog="$path/autoconf-$version/bin/$prog"
 	break;
     fi
+    if [ -x "$path/bin/autoconf-$version" ]; then
+	prog="$path/bin/$prog-$version"
+	break;
+    fi
 done
 
 echo "trying $prog version"
diff --git a/include/net-snmp/agent/agent_index.h b/include/net-snmp/agent/agent_index.h
index 49ee7fd..9846a61 100644
--- a/include/net-snmp/agent/agent_index.h
+++ b/include/net-snmp/agent/agent_index.h
@@ -40,6 +40,8 @@ int             unregister_index(netsnmp_variable_list *, int,
 unsigned long   count_indexes(oid * name, size_t namelen,
                               int include_unallocated);
 
+void dump_idx_registry(void);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/net-snmp/agent/agent_registry.h b/include/net-snmp/agent/agent_registry.h
index 2949c9d..78d0f86 100644
--- a/include/net-snmp/agent/agent_registry.h
+++ b/include/net-snmp/agent/agent_registry.h
@@ -57,6 +57,7 @@ typedef struct subtree_context_cache_s {
 
 void             setup_tree		  (void);
 void             shutdown_tree    (void);
+void             dump_registry(void);
 
 
 netsnmp_subtree *netsnmp_subtree_find	  (const oid *, size_t,
diff --git a/include/net-snmp/agent/agent_trap.h b/include/net-snmp/agent/agent_trap.h
index 26e2223..61f5991 100644
--- a/include/net-snmp/agent/agent_trap.h
+++ b/include/net-snmp/agent/agent_trap.h
@@ -10,6 +10,14 @@ struct agent_add_trap_args {
     int             confirm;
 };
 
+extern long snmp_enableauthentraps;
+extern int snmp_enableauthentrapsset;
+
+extern const oid       snmptrap_oid[];
+extern const oid       sysuptime_oid[];
+extern const size_t    snmptrap_oid_len;
+extern const size_t    sysuptime_oid_len;
+
 void            init_traps(void);
 void            send_easy_trap(int, int);
 void            send_trap_pdu(netsnmp_pdu *);
diff --git a/include/net-snmp/agent/hardware/cpu.h b/include/net-snmp/agent/hardware/cpu.h
index f6e43e5..0ea4203 100644
--- a/include/net-snmp/agent/hardware/cpu.h
+++ b/include/net-snmp/agent/hardware/cpu.h
@@ -66,3 +66,4 @@ netsnmp_cpu_info *netsnmp_cpu_get_byName( char*, int );
 
 netsnmp_cache *netsnmp_cpu_get_cache( void );
 int netsnmp_cpu_load( void );
+int netsnmp_cpu_arch_load(netsnmp_cache *cache, void *magic);
diff --git a/include/net-snmp/agent/hardware/fsys.h b/include/net-snmp/agent/hardware/fsys.h
index 91e8e17..3f2b284 100644
--- a/include/net-snmp/agent/hardware/fsys.h
+++ b/include/net-snmp/agent/hardware/fsys.h
@@ -33,14 +33,14 @@ typedef struct netsnmp_fsys_info_s netsnmp_fsys_info;
    /*
     * Additional enumerationis - not listed in that MIB
     */
-#define NETSNMP_FS_TYPE_IGNORE	   1 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
+#define NETSNMP_FS_TYPE_IGNORE	   (1 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT)
 
-#define NETSNMP_FS_TYPE_PROC	   2 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
+#define NETSNMP_FS_TYPE_PROC	   (2 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT)
 
-#define NETSNMP_FS_TYPE_DEVPTS	   3 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
-#define NETSNMP_FS_TYPE_SYSFS	   4 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
-#define NETSNMP_FS_TYPE_TMPFS	   5 | _NETSNMP_FS_TYPE_LOCAL
-#define NETSNMP_FS_TYPE_USBFS	   6 | _NETSNMP_FS_TYPE_LOCAL
+#define NETSNMP_FS_TYPE_DEVPTS	   (3 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT)
+#define NETSNMP_FS_TYPE_SYSFS	   (4 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT)
+#define NETSNMP_FS_TYPE_TMPFS	   (5 | _NETSNMP_FS_TYPE_LOCAL)
+#define NETSNMP_FS_TYPE_USBFS	   (6 | _NETSNMP_FS_TYPE_LOCAL)
 
 #define NETSNMP_FS_FLAG_ACTIVE   0x01
 #define NETSNMP_FS_FLAG_REMOTE   0x02
diff --git a/include/net-snmp/agent/hardware/memory.h b/include/net-snmp/agent/hardware/memory.h
index aba0a6c..54265cf 100644
--- a/include/net-snmp/agent/hardware/memory.h
+++ b/include/net-snmp/agent/hardware/memory.h
@@ -37,3 +37,4 @@ netsnmp_memory_info *netsnmp_memory_get_next_byIdx(int,int );
 
 netsnmp_cache *netsnmp_memory_get_cache( void );
 int netsnmp_memory_load( void );
+int netsnmp_mem_arch_load(netsnmp_cache *cache, void *magic);
diff --git a/include/net-snmp/agent/netsnmp_close_fds.h b/include/net-snmp/agent/netsnmp_close_fds.h
new file mode 100644
index 0000000..8c05f55
--- /dev/null
+++ b/include/net-snmp/agent/netsnmp_close_fds.h
@@ -0,0 +1,6 @@
+#ifndef netsnmp_close_fds_h_INCLUDED
+#define netsnmp_close_fds_h_INCLUDED
+
+extern void netsnmp_close_fds(int fd);
+
+#endif /* netsnmp_close_fds_h_INCLUDED */
diff --git a/include/net-snmp/agent/snmp_agent.h b/include/net-snmp/agent/snmp_agent.h
index aad8837..a34445f 100644
--- a/include/net-snmp/agent/snmp_agent.h
+++ b/include/net-snmp/agent/snmp_agent.h
@@ -32,6 +32,8 @@ extern          "C" {
 #define SNMP_MAX_PDU_SIZE 64000 /* local constraint on PDU size sent by agent
                                  * (see also SNMP_MAX_MSG_SIZE in snmp_api.h) */
 
+    extern int      netsnmp_running;
+
     /*
      * If non-zero, causes the addresses of peers to be logged when receptions
      * occur.  
@@ -45,6 +47,9 @@ extern          "C" {
 
     extern int      lastAddrAge;
 
+    extern const oid version_sysoid[];
+    extern const int version_sysoid_len;
+
     /** @typedef struct netsnmp_request_info_s netsnmp_request_info
      * Typedefs the netsnmp_request_info_s struct into
      * netsnmp_request_info*/
@@ -207,6 +212,11 @@ extern          "C" {
         int             vbcount;
     } netsnmp_agent_session;
 
+    extern netsnmp_session *main_session;
+
+    extern netsnmp_agent_session *netsnmp_processing_set;
+    extern netsnmp_agent_session *agent_delegated_list;
+
     /*
      * Address cache handling functions.  
      */
diff --git a/include/net-snmp/agent/snmp_vars.h b/include/net-snmp/agent/snmp_vars.h
index 77dbd70..bd27eeb 100644
--- a/include/net-snmp/agent/snmp_vars.h
+++ b/include/net-snmp/agent/snmp_vars.h
@@ -43,6 +43,8 @@ PERFORMANCE OF THIS SOFTWARE.
  * distributed with the Net-SNMP package.
  */
 
+    extern int callback_master_num;
+
     struct variable;
 
     /**
diff --git a/include/net-snmp/data_access/ipstats.h b/include/net-snmp/data_access/ipstats.h
index f782459..f0df46b 100644
--- a/include/net-snmp/data_access/ipstats.h
+++ b/include/net-snmp/data_access/ipstats.h
@@ -58,45 +58,45 @@ typedef struct netsnmp_ipstats_s {
     * other columns, when underlying OS does not provide them.
     * Always fill at least 32 bits, the table is periodically polled -> 32 bit
     * overflow shall be detected and 64 bit value should be computed automatically. */
-   U64             HCInReceives;
-   U64             HCInOctets;
+   struct counter64 HCInReceives;
+   struct counter64 HCInOctets;
    u_long          InHdrErrors;
-   U64             HCInNoRoutes; 
+   struct counter64 HCInNoRoutes; 
    u_long          InAddrErrors;
    u_long          InUnknownProtos;
    u_long          InTruncatedPkts;
    
    /* optional, can be computed from HCInNoRoutes and HCOutForwDatagrams */
-   U64             HCInForwDatagrams; 
+   struct counter64 HCInForwDatagrams; 
    
    u_long          ReasmReqds;
    u_long          ReasmOKs;
    u_long          ReasmFails;
    u_long          InDiscards;
-   U64             HCInDelivers;
-   U64             HCOutRequests;
-   U64             HCOutNoRoutes;
-   U64             HCOutForwDatagrams;
-   U64             HCOutDiscards;
+   struct counter64 HCInDelivers;
+   struct counter64 HCOutRequests;
+   struct counter64 HCOutNoRoutes;
+   struct counter64 HCOutForwDatagrams;
+   struct counter64 HCOutDiscards;
    
    /* optional, can be computed from HCOutFragOKs + HCOutFragFails*/
-   U64             HCOutFragReqds;
-   U64             HCOutFragOKs;
-   U64             HCOutFragFails;
-   U64             HCOutFragCreates;
+   struct counter64 HCOutFragReqds;
+   struct counter64 HCOutFragOKs;
+   struct counter64 HCOutFragFails;
+   struct counter64 HCOutFragCreates;
    
    /* optional, can be computed from 
     * HCOutRequests +HCOutForwDatagrams + HCOutFragCreates
     * - HCOutFragReqds - HCOutNoRoutes  - HCOutDiscards */
-   U64             HCOutTransmits;
+   struct counter64 HCOutTransmits;
    
-   U64             HCOutOctets;
-   U64             HCInMcastPkts;
-   U64             HCInMcastOctets;
-   U64             HCOutMcastPkts;
-   U64             HCOutMcastOctets;
-   U64             HCInBcastPkts;
-   U64             HCOutBcastPkts;
+   struct counter64 HCOutOctets;
+   struct counter64 HCInMcastPkts;
+   struct counter64 HCInMcastOctets;
+   struct counter64 HCOutMcastPkts;
+   struct counter64 HCOutMcastOctets;
+   struct counter64 HCInBcastPkts;
+   struct counter64 HCOutBcastPkts;
 
    /* Array of available columns.*/
    int             columnAvail[IPSYSTEMSTATSTABLE_LAST+1];
diff --git a/include/net-snmp/data_access/swrun.h b/include/net-snmp/data_access/swrun.h
index 3e15c41..4f768ac 100644
--- a/include/net-snmp/data_access/swrun.h
+++ b/include/net-snmp/data_access/swrun.h
@@ -85,7 +85,7 @@ extern "C" {
 
     void netsnmp_swrun_entry_free(netsnmp_swrun_entry *entry);
 
-    int  swrun_count_processes( void );
+    int  swrun_count_processes( int include_kthreads );
     int  swrun_max_processes(   void );
     int  swrun_count_processes_by_name( char *name );
 
diff --git a/include/net-snmp/library/asn1.h b/include/net-snmp/library/asn1.h
index 52ecc3b..9f7c0c4 100644
--- a/include/net-snmp/library/asn1.h
+++ b/include/net-snmp/library/asn1.h
@@ -177,6 +177,7 @@ SOFTWARE.
 #define IS_DELEGATED(x)   ((x) == ASN_PRIV_DELEGATED)
 
 
+    NETSNMP_IMPORT
     int             asn_check_packet(u_char *, size_t);
     NETSNMP_IMPORT
     u_char         *asn_parse_int(u_char *, size_t *, u_char *, long *,
@@ -198,6 +199,7 @@ SOFTWARE.
                                      const u_char *, size_t);
     NETSNMP_IMPORT
     u_char         *asn_parse_header(u_char *, size_t *, u_char *);
+    NETSNMP_IMPORT
     u_char         *asn_parse_sequence(u_char *, size_t *, u_char *, u_char expected_type,      /* must be this type */
                                        const char *estr);       /* error message prefix */
     NETSNMP_IMPORT
@@ -230,16 +232,22 @@ SOFTWARE.
     NETSNMP_IMPORT
     u_char         *asn_build_unsigned_int64(u_char *, size_t *, u_char,
                                              const struct counter64 *, size_t);
+    NETSNMP_IMPORT
     u_char         *asn_parse_signed_int64(u_char *, size_t *, u_char *,
                                            struct counter64 *, size_t);
+    NETSNMP_IMPORT
     u_char         *asn_build_signed_int64(u_char *, size_t *, u_char,
                                            const struct counter64 *, size_t);
+    NETSNMP_IMPORT
     u_char         *asn_build_float(u_char *, size_t *, u_char, const float *,
                                     size_t);
+    NETSNMP_IMPORT
     u_char         *asn_parse_float(u_char *, size_t *, u_char *, float *,
                                     size_t);
+    NETSNMP_IMPORT
     u_char         *asn_build_double(u_char *, size_t *, u_char, const double *,
                                      size_t);
+    NETSNMP_IMPORT
     u_char         *asn_parse_double(u_char *, size_t *, u_char *,
                                      double *, size_t);
 
@@ -249,6 +257,7 @@ SOFTWARE.
      * Re-allocator function for below.  
      */
 
+    NETSNMP_IMPORT
     int             asn_realloc(u_char **, size_t *);
 
     /*
@@ -356,11 +365,13 @@ SOFTWARE.
      */
 
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_int(u_char ** pkt, size_t * pkt_len,
                                            size_t * offset,
                                            int allow_realloc, u_char type,
                                            const long *data, size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_string(u_char ** pkt,
                                               size_t * pkt_len,
                                               size_t * offset,
@@ -369,6 +380,7 @@ SOFTWARE.
                                               const u_char * data,
                                               size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_unsigned_int(u_char ** pkt,
                                                     size_t * pkt_len,
                                                     size_t * offset,
@@ -377,6 +389,7 @@ SOFTWARE.
                                                     const u_long * data,
                                                     size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_header(u_char ** pkt,
                                               size_t * pkt_len,
                                               size_t * offset,
@@ -384,6 +397,7 @@ SOFTWARE.
                                               u_char type,
                                               size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_sequence(u_char ** pkt,
                                                 size_t * pkt_len,
                                                 size_t * offset,
@@ -391,12 +405,14 @@ SOFTWARE.
                                                 u_char type,
                                                 size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_length(u_char ** pkt,
                                               size_t * pkt_len,
                                               size_t * offset,
                                               int allow_realloc,
                                               size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_objid(u_char ** pkt,
                                              size_t * pkt_len,
                                              size_t * offset,
@@ -404,12 +420,14 @@ SOFTWARE.
                                              u_char type, const oid *,
                                              size_t);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_null(u_char ** pkt,
                                             size_t * pkt_len,
                                             size_t * offset,
                                             int allow_realloc,
                                             u_char type);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_bitstring(u_char ** pkt,
                                                  size_t * pkt_len,
                                                  size_t * offset,
@@ -418,6 +436,7 @@ SOFTWARE.
                                                  const u_char * data,
                                                  size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_unsigned_int64(u_char ** pkt,
                                                       size_t * pkt_len,
                                                       size_t * offset,
@@ -426,6 +445,7 @@ SOFTWARE.
                                                       struct counter64
                                                       const *data, size_t);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_signed_int64(u_char ** pkt,
                                                     size_t * pkt_len,
                                                     size_t * offset,
@@ -434,6 +454,7 @@ SOFTWARE.
                                                     const struct counter64 *data,
                                                     size_t);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_float(u_char ** pkt,
                                              size_t * pkt_len,
                                              size_t * offset,
@@ -441,6 +462,7 @@ SOFTWARE.
                                              u_char type, const float *data,
                                              size_t data_size);
 
+    NETSNMP_IMPORT
     int             asn_realloc_rbuild_double(u_char ** pkt,
                                               size_t * pkt_len,
                                               size_t * offset,
diff --git a/include/net-snmp/library/cert_util.h b/include/net-snmp/library/cert_util.h
index 34a79dc..19118ff 100644
--- a/include/net-snmp/library/cert_util.h
+++ b/include/net-snmp/library/cert_util.h
@@ -154,6 +154,7 @@ netsnmp_container *netsnmp_cert_get_trustlist(void);
     netsnmp_container *netsnmp_cert_map_container_create(int with_fp);
     netsnmp_container *netsnmp_cert_map_container(void);
 
+    netsnmp_cert_map *netsnmp_certToTSN_parse_common(char **line);
     int netsnmp_cert_get_secname_maps(netsnmp_container *cm);
 
     /*************************************************************************
diff --git a/include/net-snmp/library/container.h b/include/net-snmp/library/container.h
index 963289e..d97fc02 100644
--- a/include/net-snmp/library/container.h
+++ b/include/net-snmp/library/container.h
@@ -309,6 +309,7 @@ extern "C" {
     int netsnmp_ncompare_cstring(const void * lhs, const void * rhs);
 
     /** useful for octet strings */
+    NETSNMP_IMPORT
     int netsnmp_compare_mem(const char * lhs, size_t lhs_len,
                             const char * rhs, size_t rhs_len);
 
diff --git a/include/net-snmp/library/data_list.h b/include/net-snmp/library/data_list.h
index 54a3a5d..294a6bb 100644
--- a/include/net-snmp/library/data_list.h
+++ b/include/net-snmp/library/data_list.h
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 /*
  * @file netsnmp_data_list.h
@@ -98,6 +103,9 @@ extern          "C" {
                           Netsnmp_Save_List_Data * data_list_save_ptr);
     SNMPCallback netsnmp_save_all_data_callback;
     void netsnmp_read_data_callback(const char *token, char *line);
+
+    void shutdown_data_list(void);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/net-snmp/library/int64.h b/include/net-snmp/library/int64.h
index 9c7c894..7a0d0d3 100644
--- a/include/net-snmp/library/int64.h
+++ b/include/net-snmp/library/int64.h
@@ -5,31 +5,43 @@
 extern          "C" {
 #endif
 
+#ifndef NETSNMP_REMOVE_U64
+    /*
+     * Note: using the U64 typedef is deprecated because this typedef conflicts
+     * with a typedef with the same name defined in the Perl header files.
+     */
     typedef struct counter64 U64;
+#endif
 
 #define I64CHARSZ 21
 
-    void            divBy10(U64, U64 *, unsigned int *);
-    void            multBy10(U64, U64 *);
-    void            incrByU16(U64 *, unsigned int);
-    void            incrByU32(U64 *, unsigned int);
+    void            divBy10(struct counter64, struct counter64 *,
+                            unsigned int *);
+    void            multBy10(struct counter64, struct counter64 *);
+    void            incrByU16(struct counter64 *, unsigned int);
+    void            incrByU32(struct counter64 *, unsigned int);
     NETSNMP_IMPORT
-    void            zeroU64(U64 *);
-    int             isZeroU64(const U64 *);
+    void            zeroU64(struct counter64 *);
+    int             isZeroU64(const struct counter64 *);
     NETSNMP_IMPORT
-    void            printU64(char *, const U64 *);
+    void            printU64(char *, const struct counter64 *);
     NETSNMP_IMPORT
-    void            printI64(char *, const U64 *);
-    int             read64(U64 *, const char *);
+    void            printI64(char *, const struct counter64 *);
+    int             read64(struct counter64 *, const char *);
     NETSNMP_IMPORT
-    void            u64Subtract(const U64 * pu64one, const U64 * pu64two,
-                                U64 * pu64out);
-    void            u64Incr(U64 * pu64out, const U64 * pu64one);
-    void            u64UpdateCounter(U64 * pu64out, const U64 * pu64one,
-                                     const U64 * pu64two);
-    void            u64Copy(U64 * pu64one, const U64 * pu64two);
+    void            u64Subtract(const struct counter64 *pu64one,
+                                const struct counter64 *pu64two,
+                                struct counter64 *pu64out);
+    void            u64Incr(struct counter64 *pu64out,
+                            const struct counter64 *pu64one);
+    void            u64UpdateCounter(struct counter64 *pu64out,
+                                     const struct counter64 *pu64one,
+                                     const struct counter64 *pu64two);
+    void            u64Copy(struct counter64 *pu64one,
+                            const struct counter64 *pu64two);
 
-    int             netsnmp_c64_check_for_32bit_wrap(U64 *old_val, U64 *new_val,
+    int             netsnmp_c64_check_for_32bit_wrap(struct counter64 *old_val,
+                                                     struct counter64 *new_val,
                                                      int adjust);
     NETSNMP_IMPORT
     int             netsnmp_c64_check32_and_update(struct counter64 *prev_val,
diff --git a/include/net-snmp/library/netsnmp-attribute-format.h b/include/net-snmp/library/netsnmp-attribute-format.h
new file mode 100644
index 0000000..8d357b3
--- /dev/null
+++ b/include/net-snmp/library/netsnmp-attribute-format.h
@@ -0,0 +1,11 @@
+#ifndef _NETSNMP_ATTRIBUTE_FORMAT_H_
+#define _NETSNMP_ATTRIBUTE_FORMAT_H_
+
+#if !defined(__GNUC__) || __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)
+#define NETSNMP_ATTRIBUTE_FORMAT(type, formatArg, firstArg)
+#else
+#define NETSNMP_ATTRIBUTE_FORMAT(type, formatArg, firstArg) \
+  __attribute__((__format__( __ ## type ## __, formatArg, firstArg )))
+#endif
+
+#endif /* _NETSNMP_ATTRIBUTE_FORMAT_H_ */
diff --git a/include/net-snmp/library/read_config.h b/include/net-snmp/library/read_config.h
index 08eca9b..f036c30 100644
--- a/include/net-snmp/library/read_config.h
+++ b/include/net-snmp/library/read_config.h
@@ -15,7 +15,14 @@ extern          "C" {
 #define PREMIB_CONFIG 1
 #define EITHER_CONFIG 2
 
+/*
+ * Value of 'type' parameter of various snmp_config calls,
+ * used by Net-SNMP client utilities.
+ */
+#define NETSNMP_APPLICATION_CONFIG_TYPE "snmpapp"
+
 #include <net-snmp/config_api.h>
+#include <net-snmp/library/netsnmp-attribute-format.h>
 
     /*
      * Defines a set of file types and the parse and free functions
@@ -52,17 +59,12 @@ extern          "C" {
     int             read_config_files(int);
     NETSNMP_IMPORT
     void            free_config(void);
-#if !defined(__GNUC__) || __GNUC__ < 2 || (__GNUC__ == 2&& __GNUC_MINOR__ < 8)
-    NETSNMP_IMPORT
-    void            netsnmp_config_error(const char *, ...);
-    void            netsnmp_config_warn(const char *, ...);
-#else
     NETSNMP_IMPORT
     void            netsnmp_config_error(const char *, ...)
-	__attribute__((__format__(__printf__, 1, 2)));
+	NETSNMP_ATTRIBUTE_FORMAT(printf, 1, 2);
+    NETSNMP_IMPORT
     void            netsnmp_config_warn(const char *, ...)
-	__attribute__((__format__(__printf__, 1, 2)));
-#endif
+	NETSNMP_ATTRIBUTE_FORMAT(printf, 1, 2);
 
     NETSNMP_IMPORT
     char           *skip_white(char *);
diff --git a/include/net-snmp/library/snmp_api.h b/include/net-snmp/library/snmp_api.h
index 6f658d5..b24db9c 100644
--- a/include/net-snmp/library/snmp_api.h
+++ b/include/net-snmp/library/snmp_api.h
@@ -329,7 +329,9 @@ typedef struct request_list {
 #define NETSNMP_CALLBACK_OP_CONNECT		4
 #define NETSNMP_CALLBACK_OP_DISCONNECT		5
 
+    NETSNMP_IMPORT
     long            snmp_get_next_msgid(void);
+    NETSNMP_IMPORT
     long            snmp_get_next_reqid(void);
     NETSNMP_IMPORT
     long            snmp_get_next_sessid(void);
@@ -339,6 +341,7 @@ typedef struct request_list {
     NETSNMP_IMPORT
     int             snmp_oid_compare(const oid *, size_t, const oid *,
                                      size_t);
+    NETSNMP_IMPORT
     int             snmp_oid_ncompare(const oid *, size_t, const oid *,
                                       size_t, size_t);
     NETSNMP_IMPORT
@@ -354,6 +357,7 @@ typedef struct request_list {
     NETSNMP_IMPORT
     int             netsnmp_oid_equals(const oid *, size_t, const oid *,
                                        size_t);
+    NETSNMP_IMPORT
     int             netsnmp_oid_tree_equals(const oid *, size_t, const oid *,
                                             size_t);
     NETSNMP_IMPORT
@@ -364,26 +368,40 @@ typedef struct request_list {
                                             const oid * in_name2, size_t len2);
     NETSNMP_IMPORT
     void            init_snmp(const char *);
+
+    int
+    snmp_build(u_char ** pkt, size_t * pkt_len, size_t * offset,
+               netsnmp_session * pss, netsnmp_pdu *pdu);
+
+    NETSNMP_IMPORT
     u_char         *snmp_pdu_build(netsnmp_pdu *, u_char *, size_t *);
 #ifdef NETSNMP_USE_REVERSE_ASNENCODING
+    NETSNMP_IMPORT
     u_char         *snmp_pdu_rbuild(netsnmp_pdu *, u_char *, size_t *);
 #endif
+    NETSNMP_IMPORT
     int             snmpv3_parse(netsnmp_pdu *, u_char *, size_t *,
                                  u_char **, netsnmp_session *);
+    NETSNMP_IMPORT
     int             snmpv3_packet_build(netsnmp_session *,
                                         netsnmp_pdu *pdu, u_char * packet,
                                         size_t * out_length,
                                         u_char * pdu_data,
                                         size_t pdu_data_len);
+    NETSNMP_IMPORT
     int             snmpv3_packet_rbuild(netsnmp_session *,
                                          netsnmp_pdu *pdu, u_char * packet,
                                          size_t * out_length,
                                          u_char * pdu_data,
                                          size_t pdu_data_len);
+    NETSNMP_IMPORT
     int             snmpv3_make_report(netsnmp_pdu *pdu, int error);
+    NETSNMP_IMPORT
     int             snmpv3_get_report_type(netsnmp_pdu *pdu);
+    NETSNMP_IMPORT
     int             snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data,
                                    size_t * length);
+    NETSNMP_IMPORT
     u_char         *snmpv3_scopedPDU_parse(netsnmp_pdu *pdu, u_char * cp,
                                            size_t * length);
     NETSNMP_IMPORT
@@ -399,14 +417,15 @@ typedef struct request_list {
                                  const char *);
     NETSNMP_IMPORT
     oid            *snmp_duplicate_objid(const oid * objToCopy, size_t);
-    NETSNMP_IMPORT
 
 #ifndef NETSNMP_FEATURE_REMOVE_STATISTICS
+    NETSNMP_IMPORT
     u_int           snmp_increment_statistic(int which);
     NETSNMP_IMPORT
     u_int           snmp_increment_statistic_by(int which, int count);
     NETSNMP_IMPORT
     u_int           snmp_get_statistic(int which);
+    NETSNMP_IMPORT
     void            snmp_init_statistics(void);
 #else /* NETSNMP_FEATURE_REMOVE_STATISTICS */
 
@@ -417,7 +436,9 @@ typedef struct request_list {
 
 #endif
 
+    NETSNMP_IMPORT
     int             create_user_from_session(netsnmp_session * session);
+    NETSNMP_IMPORT
     int snmpv3_probe_contextEngineID_rfc5343(void *slp,
                                              netsnmp_session *session);
 
@@ -426,12 +447,14 @@ typedef struct request_list {
      */
 #ifdef NETSNMP_USE_REVERSE_ASNENCODING
 
+    NETSNMP_IMPORT
     int        snmpv3_packet_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
                                      size_t * offset,
                                      netsnmp_session * session,
                                      netsnmp_pdu *pdu, u_char * pdu_data,
                                      size_t pdu_data_len);
 
+    NETSNMP_IMPORT
     int        snmp_pdu_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
                                 size_t * offset, netsnmp_pdu *pdu);
 #endif
@@ -478,6 +501,8 @@ struct netsnmp_transport_s;
     void            netsnmp_sess_log_error(int priority,
                                            const char *prog_string,
                                            netsnmp_session * ss);
+
+    NETSNMP_IMPORT
     const char *    snmp_pdu_type(int type);
 
     /*
@@ -487,6 +512,7 @@ struct netsnmp_transport_s;
 
     NETSNMP_IMPORT
     struct netsnmp_transport_s *snmp_sess_transport(void *);
+    NETSNMP_IMPORT
     void            snmp_sess_transport_set(void *,
 					    struct netsnmp_transport_s *);
 
@@ -511,6 +537,7 @@ struct netsnmp_transport_s;
      * 
      */
 
+    NETSNMP_IMPORT
     void           *snmp_sess_add_ex(netsnmp_session *,
                                      struct netsnmp_transport_s *,
                                      int (*fpre_parse) (netsnmp_session *,
@@ -537,6 +564,7 @@ struct netsnmp_transport_s;
                                                                   void *,
                                                                   size_t));
 
+    NETSNMP_IMPORT
     void           *snmp_sess_add(netsnmp_session *,
                                   struct netsnmp_transport_s *,
                                   int (*fpre_parse) (netsnmp_session *,
diff --git a/include/net-snmp/library/snmp_debug.h b/include/net-snmp/library/snmp_debug.h
index a3969f6..12401d3 100644
--- a/include/net-snmp/library/snmp_debug.h
+++ b/include/net-snmp/library/snmp_debug.h
@@ -1,6 +1,19 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #ifndef SNMP_DEBUG_H
 #define SNMP_DEBUG_H
 
+#include <net-snmp/library/netsnmp-attribute-format.h>
+
 #ifdef __cplusplus
 extern          "C" {
 #endif
@@ -14,14 +27,6 @@ extern          "C" {
      * compile time.
      */
 
-
-#if !defined(__GNUC__) || __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)
-#define NETSNMP_ATTRIBUTE_FORMAT(type, formatArg, firstArg)
-#else
-#define NETSNMP_ATTRIBUTE_FORMAT(type, formatArg, firstArg) \
-  __attribute__((__format__( __ ## type ## __, formatArg, firstArg )))
-#endif
-
     /*
      * These functions should not be used, if at all possible.  Instead, use
      * the macros below. 
@@ -33,12 +38,10 @@ extern          "C" {
     void            debugmsgtoken(const char *token, const char *format,
                                   ...)
                         NETSNMP_ATTRIBUTE_FORMAT(printf, 2, 3);
+    NETSNMP_IMPORT
     void            debug_combo_nc(const char *token, const char *format,
                                    ...)
                         NETSNMP_ATTRIBUTE_FORMAT(printf, 2, 3);
-
-#undef NETSNMP_ATTRIBUTE_FORMAT
-
     NETSNMP_IMPORT
     void            debugmsg_oid(const char *token, const oid * theoid,
                                  size_t len);
@@ -61,6 +64,8 @@ extern          "C" {
     NETSNMP_IMPORT
     void            debug_indent_add(int amount);
     NETSNMP_IMPORT
+    void            debug_indent_reset(void);
+    NETSNMP_IMPORT
     int             debug_indent_get(void);
     /*
      * What is said above is true for this function as well. Further this
@@ -214,6 +219,7 @@ extern          "C" {
 #endif
 
     void            snmp_debug_init(void);
+    void            snmp_debug_shutdown(void);
 
 #define MAX_DEBUG_TOKENS 256
 #define MAX_DEBUG_TOKEN_LEN 128
diff --git a/include/net-snmp/library/snmp_enum.h b/include/net-snmp/library/snmp_enum.h
index 237891d..f808628 100644
--- a/include/net-snmp/library/snmp_enum.h
+++ b/include/net-snmp/library/snmp_enum.h
@@ -101,7 +101,7 @@ extern          "C" {
     void            se_store_slist(const char *listname, const char *type);
     int             se_store_slist_callback(int majorID, int minorID,
                                            void *serverargs, void *clientargs);
-    void            se_read_conf(const char *word, char *cptr);
+    void            se_read_conf(const char *word, const char *cptr);
     /**
      * Deallocate the memory allocated by init_snmp_enum(): remove all key/value
      * pairs stored by se_add_*() calls.
diff --git a/include/net-snmp/library/snmpv3.h b/include/net-snmp/library/snmpv3.h
index a958809..02e6a58 100644
--- a/include/net-snmp/library/snmpv3.h
+++ b/include/net-snmp/library/snmpv3.h
@@ -20,6 +20,9 @@ extern          "C" {
 
 #define	DEFAULT_NIC "eth0"
 
+    NETSNMP_IMPORT int
+    snmpv3_parse_args(char *optarg, netsnmp_session * session, char **Apsz,
+                      char **Xpsz, int argc, char *const *argv, int flags);
     NETSNMP_IMPORT
     int             setup_engineID(u_char ** eidp, const char *text);
     void            engineID_conf(const char *word, char *cptr);
@@ -54,6 +57,13 @@ extern          "C" {
 				  void *clientarg);
     NETSNMP_IMPORT
     int             parse_secLevel_conf(const char* word, char *cptr);
+    NETSNMP_IMPORT int
+    snmpv3_parse_arg(int arg, char *optarg, netsnmp_session *session,
+                     char **Apsz, char **Xpsz, int argc, char *const *argv,
+                     int flags);
+    NETSNMP_IMPORT int
+    snmpv3_options(char *optarg, netsnmp_session * session, char **Apsz,
+                   char **Xpsz, int argc, char *const *argv);
 
 #ifdef __cplusplus
 }
diff --git a/include/net-snmp/library/tools.h b/include/net-snmp/library/tools.h
index 2634b34..81ec84a 100644
--- a/include/net-snmp/library/tools.h
+++ b/include/net-snmp/library/tools.h
@@ -267,6 +267,7 @@ extern          "C" {
     void            netsnmp_set_monotonic_marker(marker_t *pm);
     NETSNMP_IMPORT
     long            atime_diff(const_marker_t first, const_marker_t second);
+    NETSNMP_IMPORT
     u_long          uatime_diff(const_marker_t first, const_marker_t second);       /* 1/1000th sec */
     NETSNMP_IMPORT
     u_long          uatime_hdiff(const_marker_t first, const_marker_t second);      /* 1/100th sec */
diff --git a/include/net-snmp/library/vacm.h b/include/net-snmp/library/vacm.h
index a5be6ac..58ec1ff 100644
--- a/include/net-snmp/library/vacm.h
+++ b/include/net-snmp/library/vacm.h
@@ -2,6 +2,15 @@
  * vacm.h
  *
  * SNMPv3 View-based Access Control Model
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #ifndef VACM_H
@@ -42,7 +51,7 @@ extern          "C" {
 #define VIEWMASK	4
 #define VIEWTYPE	5
 #define VIEWSTORAGE	6
-#define VIEWSTATUS	7
+#define VACMVIEWSTATUS	7
 
 #define VACM_MAX_STRING 32
 #define VACMSTRINGLEN   34      /* VACM_MAX_STRING + 2 */
@@ -112,7 +121,7 @@ extern          "C" {
 
     struct vacm_viewEntry {
         char            viewName[VACMSTRINGLEN];
-        oid             viewSubtree[MAX_OID_LEN];
+        oid             viewSubtree[MAX_OID_LEN+1]; /* keep len in [0] */
         size_t          viewSubtreeLen;
         u_char          viewMask[VACMSTRINGLEN];
         size_t          viewMaskLen;
diff --git a/include/net-snmp/net-snmp-config.h.in b/include/net-snmp/net-snmp-config.h.in
index 1db0237..15fd7ed 100644
--- a/include/net-snmp/net-snmp-config.h.in
+++ b/include/net-snmp/net-snmp-config.h.in
@@ -1,5 +1,6 @@
 /* include/net-snmp/net-snmp-config.h.in.  Generated from configure.ac by autoheader.  */
-/* 
+
+/*
  * net-snmp configuration header file
  *
  * NOTE: DO NOT EDIT include/net-snmp/net-snmp-config.h.in as your changes
@@ -30,6 +31,10 @@
 
 /* definitions added by configure on-the-fly */
 
+#define config_error(x)
+
+#define config_warning(x)
+
 #define config_belongs_in(x)
 
 #define config_exclude(x)
@@ -44,10 +49,6 @@
 
 #define config_parse_dot_conf(w,x,y,z)
 
-#define config_error(x)
-
-#define config_warning(x)
-
 /* Define if building universal (internal helper macro) */
 #undef AC_APPLE_UNIVERSAL_BUILD
 
@@ -176,6 +177,9 @@
 /* Define to 1 if you have the `fork' function. */
 #undef HAVE_FORK
 
+/* Define to 1 if you have the `forkall' function. */
+#undef HAVE_FORKALL
+
 /* Define to 1 if you have the <fstab.h> header file. */
 #undef HAVE_FSTAB_H
 
@@ -320,6 +324,12 @@
 /* Define to 1 if you have the <kstat.h> header file. */
 #undef HAVE_KSTAT_H
 
+/* Define to 1 if you have the `kvm_getfile2' function. */
+#undef HAVE_KVM_GETFILE2
+
+/* Define to 1 if you have the `kvm_getfiles' function. */
+#undef HAVE_KVM_GETFILES
+
 /* Define to 1 if you have the `kvm_getproc2' function. */
 #undef HAVE_KVM_GETPROC2
 
@@ -455,6 +465,9 @@
 /* Define to 1 if you have the <mtab.h> header file. */
 #undef HAVE_MTAB_H
 
+/* Define if having my_load_defaults */
+#undef HAVE_MY_LOAD_DEFAULTS
+
 /* Define to 1 if you have the <nbutil.h> header file. */
 #undef HAVE_NBUTIL_H
 
diff --git a/include/net-snmp/output_api.h b/include/net-snmp/output_api.h
index 3bf3172..0adc891 100644
--- a/include/net-snmp/output_api.h
+++ b/include/net-snmp/output_api.h
@@ -6,8 +6,9 @@
      *    (including error handling and debugging).
      */
 
-#include <net-snmp/types.h>
 #include <stdarg.h>	/* for va_list */
+#include <net-snmp/types.h>
+#include <net-snmp/library/netsnmp-attribute-format.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -38,14 +39,9 @@ extern "C" {
 
     /* Logging messages */
 
-#if !defined(__GNUC__) || __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)
-#define _LOG_ATTR
-#else
-#define _LOG_ATTR   __attribute__ ((__format__ (__printf__, 2, 3)))
-#endif
-
     NETSNMP_IMPORT
-    int  snmp_log( int priority, const char *format, ...) _LOG_ATTR;
+    int  snmp_log( int priority, const char *format, ...)
+        NETSNMP_ATTRIBUTE_FORMAT(printf, 2, 3);
     NETSNMP_IMPORT
     int  snmp_vlog(int priority, const char *format, va_list ap);
     NETSNMP_IMPORT
diff --git a/include/net-snmp/session_api.h b/include/net-snmp/session_api.h
index 88dbc41..f7948dc 100644
--- a/include/net-snmp/session_api.h
+++ b/include/net-snmp/session_api.h
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #ifndef NET_SNMP_SESSION_API_H
 #define NET_SNMP_SESSION_API_H
 
@@ -54,6 +65,7 @@ extern          "C" {
      * session defaults.  Add a request corresponding to this pdu to the list
      * of outstanding requests on this session, then send the pdu.
      * Returns the request id of the generated packet if applicable, otherwise 1.
+     * (There is a special case: if the request id is 0, 1 will be returned).
      * On any error, 0 is returned.
      * The pdu is freed by snmp_send() unless a failure occured.
      */
diff --git a/include/net-snmp/system/darwin14.h b/include/net-snmp/system/darwin14.h
new file mode 100644
index 0000000..88ca8b5
--- /dev/null
+++ b/include/net-snmp/system/darwin14.h
@@ -0,0 +1,143 @@
+/*
+ * While Darwin 10 (aka, Mac OS X 10.6 Snow Leopard) is "BSD-like", it differs
+ * substantially enough to not warrant pretending it is a BSD flavor.
+ * This first section are the vestigal BSD remnants.
+ */
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+/*
+ * BSD systems use a different method of looking up sockaddr_in values 
+ */
+/* #define NEED_KLGETSA 1 */
+
+/*
+ * ARP_Scan_Next needs a 4th ifIndex argument 
+ */
+#define ARP_SCAN_FOUR_ARGUMENTS 1
+
+#define CHECK_RT_FLAGS 1
+
+/*
+ * this is not good enough before freebsd3! 
+ */
+/* #undef HAVE_NET_IF_MIB_H */
+
+/*
+ * This section adds the relevant definitions from generic.h
+ * (a file we don't include here)
+ */
+
+/*
+ * udp_inpcb list symbol, e.g. for mibII/udpTable.c
+ */
+#define INP_NEXT_SYMBOL inp_next
+
+/*
+ * This section defines Mac OS X 10.5 (and later) specific additions.
+ */
+#define darwin 14
+#ifndef darwin14
+#   define darwin14 darwin
+#endif
+
+/*
+ * Mac OS X should only use the modern API and definitions.
+ */
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+#define NETSNMP_NO_LEGACY_DEFINITIONS 1
+#endif
+
+/*
+ * looks like the IFTable stuff works better than the mibII versions
+ */
+ 
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
+
+/*
+ * use new host resources files as well
+ */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
+#define NETSNMP_INCLUDE_HRSWINST_REWRITES
+#define NETSNMP_INCLUDE_HRSWRUN_REWRITES
+#undef NETSNMP_INCLUDE_HRSWRUN_WRITE_SUPPORT
+#define NETSNMP_CAN_GET_DISK_LABEL 1
+
+/*
+ * Enabling this restricts the compiler to mostly public APIs.
+ */
+#ifndef __APPLE_API_STRICT_CONFORMANCE
+#define __APPLE_API_STRICT_CONFORMANCE 1
+#endif
+#ifndef __APPLE_API_UNSTABLE
+#define __APPLE_API_UNSTABLE 1
+#endif
+
+/*
+ * Darwin's tools are capable of building multiple architectures in one pass.
+ * As a result, platform definitions should be deferred until compile time.
+ */
+#ifdef BYTE_ORDER
+# undef WORDS_BIGENDIAN
+# if BYTE_ORDER == BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/*
+ * Although Darwin does have an fstab.h file, getfsfile etc. always return null.
+ * At least, as of 5.3.
+ */
+#undef HAVE_FSTAB_H
+
+#define SWAPFILE_DIR "/private/var/vm"
+#define SWAPFILE_PREFIX "swapfile"
+
+/*
+ * These apparently used to be in netinet/tcp_timers.h, but went away in
+ * 10.4.2. Define them here til we find out a way to get the real values.
+ */
+#define TCPTV_MIN       (  1*PR_SLOWHZ)         /* minimum allowable value */
+#define TCPTV_REXMTMAX  ( 64*PR_SLOWHZ)         /* max allowable REXMT value */
+
+/*
+ * Because Mac OS X is built on Mach, it does not provide a BSD-compatible
+ * VM statistics API.
+ */
+#define USE_MACH_HOST_STATISTICS 1
+
+/*
+ * This tells code that manipulates IPv6 that the structures are unified,
+ * i.e., IPv4 and IPv6 use the same structs.
+ * This should eventually be replaced with a configure directive.
+ */
+/* #define USE_UNIFIED_IPV6_STRUCTS 1 */
+#undef STRUCT_in6pcb_HAS_inp_vflag
+
+/*
+ * utility macro used in several darwin specific files
+ */
+#define SNMP_CFRelease(x) do { if (x) { CFRelease(x); x = NULL; } } while(0)
+
+/*
+ * Mac OS X runs on both PPC and Intel hardware,
+ *   which handle udpTable index values differently
+ */
+#include <TargetConditionals.h>
+#ifdef TARGET_RT_LITTLE_ENDIAN
+#define UDP_ADDRESSES_IN_HOST_ORDER 1
+#endif
+
+/*
+ * as of 7/2010, openssl on darwin does not have sha256
+ */
+#define OPENSSL_NO_SHA256 1
+#define OPENSSL_NO_SHA512 1
diff --git a/include/net-snmp/system/freebsd8.h b/include/net-snmp/system/freebsd8.h
index 0c814bd..5f02984 100644
--- a/include/net-snmp/system/freebsd8.h
+++ b/include/net-snmp/system/freebsd8.h
@@ -1,3 +1,11 @@
 /* freebsd8 is a superset of freebsd7 */
 #include "freebsd7.h"
 #define freebsd7 freebsd7
+
+/*
+ * Not completely sure when these fields got
+ * added to FreeBSD, but FreeBSD 8 is about the oldest
+ * one we care about, so add them here.
+ */
+#undef UTMP_HAS_NO_TYPE
+#undef UTMP_HAS_NO_PID
diff --git a/include/net-snmp/system/netbsd.h b/include/net-snmp/system/netbsd.h
index 1f22a44..93b75aa 100644
--- a/include/net-snmp/system/netbsd.h
+++ b/include/net-snmp/system/netbsd.h
@@ -18,11 +18,19 @@
 /*
  * inp_next symbol 
  */
+#define HAVE_INPCBTABLE 1
 #undef INP_NEXT_SYMBOL
-#define INP_NEXT_SYMBOL inp_queue.cqe_next
 #undef INP_PREV_SYMBOL
+
+#if __NetBSD_Version__ >= 700000001
+#define INP_FIRST_SYMBOL inpt_queue.tqh_first
+#define INP_NEXT_SYMBOL inp_queue.tqe_next
+#define INP_PREV_SYMBOL inp_queue.tqe_prev
+#else
+#define INP_FIRST_SYMBOL inpt_queue.cqh_first
+#define INP_NEXT_SYMBOL inp_queue.cqe_next
 #define INP_PREV_SYMBOL inp_queue.cqe_prev
-#define HAVE_INPCBTABLE 1
+#endif
 
 #if __NetBSD_Version__ >= 106300000       /* NetBSD 1.6ZD */            
 #undef IFADDR_SYMBOL
@@ -34,6 +42,10 @@
 
 #define UDP_ADDRESSES_IN_HOST_ORDER 1
 
+#ifdef netbsdelf7
+#define netbsd7
+#define netbsdelf6
+#endif
 #ifdef netbsdelf6
 #define netbsd6
 #define netbsdelf5
@@ -50,6 +62,9 @@
 #define netbsd3
 #endif
 
+#if defined(netbsd7) && !defined(netbsd6)
+#define netbsd6 netbsd6
+#endif
 #if defined(netbsd6) && !defined(netbsd5)
 #define netbsd5 netbsd5
 #endif
diff --git a/include/net-snmp/system/openbsd5.h b/include/net-snmp/system/openbsd5.h
index 26b2415..a3bedb0 100644
--- a/include/net-snmp/system/openbsd5.h
+++ b/include/net-snmp/system/openbsd5.h
@@ -1,3 +1,15 @@
 /* openbsd5 is a superset of all since openbsd3 */
 #include "openbsd4.h"
 #define openbsd4 openbsd4
+
+#undef HAVE_NET_IF_VAR_H
+
+#if OpenBSD >= 201605
+#undef INP_FIRST_SYMBOL
+#define INP_FIRST_SYMBOL inpt_queue.tqh_first
+#undef INP_NEXT_SYMBOL
+#define INP_NEXT_SYMBOL inp_queue.tqe_next
+#undef INP_PREV_SYMBOL
+#define INP_PREV_SYMBOL inp_queue.tqe_prev
+#endif
+
diff --git a/include/net-snmp/system/openbsd6.h b/include/net-snmp/system/openbsd6.h
new file mode 100644
index 0000000..3889f16
--- /dev/null
+++ b/include/net-snmp/system/openbsd6.h
@@ -0,0 +1,3 @@
+/* openbsd6 is a superset of all since openbsd3 */
+#include "openbsd5.h"
+#define openbsd5 openbsd5
diff --git a/include/net-snmp/types.h b/include/net-snmp/types.h
index 5e80a45..ba12e5e 100644
--- a/include/net-snmp/types.h
+++ b/include/net-snmp/types.h
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #ifndef NET_SNMP_TYPES_H
 #define NET_SNMP_TYPES_H
 
@@ -177,7 +188,7 @@ typedef struct snmp_pdu {
     long            version;
     /** Type of this PDU */	
     int             command;
-    /** Request id - note: not incremented on retries */
+    /** Request id - note: incremented for each retry */
     long            reqid;  
     /** Message id for V3 messages note: incremented for each retry */
     long            msgid;
diff --git a/local/gittools/shell-functions b/local/gittools/shell-functions
index aef3a98..571e8aa 100644
--- a/local/gittools/shell-functions
+++ b/local/gittools/shell-functions
@@ -131,6 +131,11 @@ nspatchtry() {
 	nspatchfile=`echo $nspatchargs | sed 's/.* \([^ ]+\)$/\1/'`
 	# attempt to count the slashes before any agent/snmplib/apps/etc
 	patchcount=$((`grep diff $nspatchfile | head -1 | awk '{print $NF}' | sed 's/\(agent\|snmplib\|apps\|local\|perl\|python\).*//;s#[^/]##g' | wc -c` - 1))
+	# if we failed to guess, bail out.
+	if [ "X$patchcount" = "X-1" ]; then
+	    echo "Please specify -p argument; I failed to guess the right one."
+	    return
+	fi
 	nspatchargs="-p $patchcount $nspatchargs"
     fi
 
@@ -446,10 +451,10 @@ nsautoconf() {
     if [ "$VER" != "$COR" ] ; then
 	echo "failed to find the correct version of autoconf"
 	echo "please install autoconf version $COR in /usr/local/autoconf-$COR"
-	echo "  (configure autoconf-$COR using -prefix=/usr/local/autoconf-$COR"
+	echo "  (configure autoconf-$COR using --prefix=/usr/local/autoconf-$COR"
 	return
     fi
 
     echo "RUNNING AUTOCONF $COR"
-    PATH=/usr/local/autoconf-${autover}/bin:$PATH $tool
+    PATH=/usr/local/autoconf-${COR}/bin:$PATH $tool
 }
diff --git a/local/mib2c b/local/mib2c
index 2016f06..22721d0 100755
--- a/local/mib2c
+++ b/local/mib2c
@@ -326,6 +326,9 @@ sub process_vars {
 
     # mib substitutions ($var.type -> $mibnode->{'type'})
    if ( $it =~ /\$(\w+)\.(\w+)/ ) {
+    if (!defined($vars{$1})) {
+      warn "Undefined variable \$$1 at $currentfile:$currentline\n";
+    }
     if ($SNMP::MIB{$vars{$1}} && defined($tables{$SNMP::MIB{$vars{$1}}{'label'}})) {
       $it =~ s/\$(\w+)\.(settable)/(table_is_writable($SNMP::MIB{$vars{$1}}{label}))/eg;
       $it =~ s/\$(\w+)\.(creatable)/(table_has_create($SNMP::MIB{$vars{$1}}{label}))/eg;
diff --git a/local/mib2c-conf.d/details-enums.m2i b/local/mib2c-conf.d/details-enums.m2i
index 3b0f152..598e188 100644
--- a/local/mib2c-conf.d/details-enums.m2i
+++ b/local/mib2c-conf.d/details-enums.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for enums. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by details-enums.m2i */
 @end@
 ########################################################################
 @ifconf $node.syntax.m2i@
@@ -76,5 +75,5 @@ $m2c_const_dcl INTERNAL_$context.uc_$m2c_iname $m2c_const_del (0x01 << $v) $m2c_
 @end@ # ! syntax include
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by details-enums.m2i */
 @end@
diff --git a/local/mib2c-conf.d/details-node.m2i b/local/mib2c-conf.d/details-node.m2i
index 0f3e2a2..2659663 100644
--- a/local/mib2c-conf.d/details-node.m2i
+++ b/local/mib2c-conf.d/details-node.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## Generic include for columns. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by details-node.m2i */
 @end@
 ########################################################################
 /*---------------------------------------------------------------------
@@ -98,5 +97,5 @@ $node.description
  */
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by details-node.m2i */
 @end@
diff --git a/local/mib2c-conf.d/details-table.m2i b/local/mib2c-conf.d/details-table.m2i
index 06df7ef..06bd801 100644
--- a/local/mib2c-conf.d/details-table.m2i
+++ b/local/mib2c-conf.d/details-table.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for tables. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by details-table.m2i */
 @end@
 ########################################################################
 /**********************************************************************
@@ -21,5 +20,5 @@
 */
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by details-table.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-ctx-copy.m2i b/local/mib2c-conf.d/generic-ctx-copy.m2i
index c959637..3021135 100644
--- a/local/mib2c-conf.d/generic-ctx-copy.m2i
+++ b/local/mib2c-conf.d/generic-ctx-copy.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-ctx-copy.m2i */
 @end@
 ########################################################################
 ##
@@ -29,5 +28,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-ctx-copy.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-ctx-get.m2i b/local/mib2c-conf.d/generic-ctx-get.m2i
index ef795c3..be3d8dc 100644
--- a/local/mib2c-conf.d/generic-ctx-get.m2i
+++ b/local/mib2c-conf.d/generic-ctx-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-ctx-get.m2i */
 @end@
 ########################################################################
 ##/*
@@ -102,5 +101,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-ctx-get.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-ctx-set.m2i b/local/mib2c-conf.d/generic-ctx-set.m2i
index 86c99a0..e0cb85b 100644
--- a/local/mib2c-conf.d/generic-ctx-set.m2i
+++ b/local/mib2c-conf.d/generic-ctx-set.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-ctx-set.m2i */
 @end@
 ########################################################################
 ##
@@ -25,5 +24,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-ctx-set.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-data-allocate.m2i b/local/mib2c-conf.d/generic-data-allocate.m2i
index 556defe..cdc4846 100644
--- a/local/mib2c-conf.d/generic-data-allocate.m2i
+++ b/local/mib2c-conf.d/generic-data-allocate.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-data-allocate.m2i */
 @end@
 ########################################################################
 ##
@@ -58,5 +57,5 @@ ${context}_release_data(${context}_data *data)
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-data-allocate.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-data-context.m2i b/local/mib2c-conf.d/generic-data-context.m2i
index 4152e91..e9599a6 100644
--- a/local/mib2c-conf.d/generic-data-context.m2i
+++ b/local/mib2c-conf.d/generic-data-context.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-data-context.m2i */
 @end@
 ########################################################################
 ##
@@ -47,5 +46,5 @@ typedef $m2c_data_context ${context}_data;
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-data-context.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-get-U64.m2i b/local/mib2c-conf.d/generic-get-U64.m2i
index 791c79e..7420422 100644
--- a/local/mib2c-conf.d/generic-get-U64.m2i
+++ b/local/mib2c-conf.d/generic-get-U64.m2i
@@ -1,14 +1,13 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-get-U64.m2i */
 @end@
 ########################################################################
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-get-U64.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-get-char.m2i b/local/mib2c-conf.d/generic-get-char.m2i
index e63e686..fd6726b 100644
--- a/local/mib2c-conf.d/generic-get-char.m2i
+++ b/local/mib2c-conf.d/generic-get-char.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-get-char.m2i */
 @end@
 ########################################################################
 ##
@@ -34,16 +33,17 @@ $example_start
     if ($m2c_ctx_rh & INTERNAL_$context.uc_$m2c_iname) {
         $m2c_node_lh |= $m2c_ename;
     }
+    $m2c_node_lh = htonl( $m2c_node_lh );
 @    end@ # for each
 $example_end
 @  else@
      * assuming generated code keeps $node BITS in SNMP order.
      */
-    $m2c_node_lh = @m2c_ctx_rh;
+    $m2c_node_lh = htonl( @m2c_ctx_rh@ );
 @  end@
 @end@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-get-char.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-get-decl-bot.m2i b/local/mib2c-conf.d/generic-get-decl-bot.m2i
index 32b4e68..e327e1c 100644
--- a/local/mib2c-conf.d/generic-get-decl-bot.m2i
+++ b/local/mib2c-conf.d/generic-get-decl-bot.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-get-decl-bot.m2i */
 @end@
 ########################################################################
 ##
@@ -18,5 +17,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-get-decl-bot.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-get-decl.m2i b/local/mib2c-conf.d/generic-get-decl.m2i
index 0568e1c..ede0c2d 100644
--- a/local/mib2c-conf.d/generic-get-decl.m2i
+++ b/local/mib2c-conf.d/generic-get-decl.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-get-decl.m2i */
 @end@
 ########################################################################
 ##
@@ -39,5 +38,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-get-decl.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-get-long.m2i b/local/mib2c-conf.d/generic-get-long.m2i
index 791c79e..5360286 100644
--- a/local/mib2c-conf.d/generic-get-long.m2i
+++ b/local/mib2c-conf.d/generic-get-long.m2i
@@ -1,14 +1,13 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-get-long.m2i */
 @end@
 ########################################################################
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-get-long.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-get-oid.m2i b/local/mib2c-conf.d/generic-get-oid.m2i
index 56dd485..3454aba 100644
--- a/local/mib2c-conf.d/generic-get-oid.m2i
+++ b/local/mib2c-conf.d/generic-get-oid.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-get-oid.m2i */
 @end@
 ########################################################################
 ##
@@ -14,5 +13,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-get-oid.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-header-bottom.m2i b/local/mib2c-conf.d/generic-header-bottom.m2i
index e00e174..be69f56 100644
--- a/local/mib2c-conf.d/generic-header-bottom.m2i
+++ b/local/mib2c-conf.d/generic-header-bottom.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-header-bottom.m2i */
 @end@
 ########################################################################
 ##
@@ -17,5 +16,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-header-bottom.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-header-top.m2i b/local/mib2c-conf.d/generic-header-top.m2i
index a4d3bd8..062883b 100644
--- a/local/mib2c-conf.d/generic-header-top.m2i
+++ b/local/mib2c-conf.d/generic-header-top.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-header-top.m2i */
 @end@
 ########################################################################
 ##
@@ -18,5 +17,5 @@ extern "C" {
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-header-top.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-source-includes.m2i b/local/mib2c-conf.d/generic-source-includes.m2i
index 9341cf9..0782769 100644
--- a/local/mib2c-conf.d/generic-source-includes.m2i
+++ b/local/mib2c-conf.d/generic-source-includes.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-source-includes.m2i */
 @end@
 ########################################################################
 ##
@@ -20,5 +19,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-source-includes.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-table-constants.m2c b/local/mib2c-conf.d/generic-table-constants.m2c
index 36e23d3..d75373a 100644
--- a/local/mib2c-conf.d/generic-table-constants.m2c
+++ b/local/mib2c-conf.d/generic-table-constants.m2c
@@ -1,7 +1,6 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_create_fewer_files != 1@
 @   foreach $table table@
@@ -11,19 +10,16 @@
 @   end@ # table
 ########################################################################
 @else@
-@   eval $hack = "Id"@
 @   eval $m2c_save = "$name"@
 @   eval $name = "${m2c_save}_constants"@
 @   open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using generic-table-constants.m2c
  */
 ########################################################################
 @   if $m2c_mark_boundary == 1@
-/** START header generated by $RCSfile$ $Revision$ */
+/** START header generated by generic-table-constants.m2c */
 @   end@
 ########################################################################
 @   include generic-header-top.m2i@
@@ -39,6 +35,6 @@
 @   eval $name = "$m2c_save"@
 ########################################################################
 @   if $m2c_mark_boundary == 1@
-/** END header generated by $RCSfile$ $Revision$ */
+/** END header generated by generic-table-constants.m2c */
 @   end@
 @end@ // m2c_create_fewer_files
diff --git a/local/mib2c-conf.d/generic-table-enums.m2c b/local/mib2c-conf.d/generic-table-enums.m2c
index 92b2132..2df9fd8 100644
--- a/local/mib2c-conf.d/generic-table-enums.m2c
+++ b/local/mib2c-conf.d/generic-table-enums.m2c
@@ -1,25 +1,21 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_create_fewer_files != 1@
-@eval $hack = "Id"@
 @eval $m2c_save = "$name"@
 @eval $name = "${name}_enums"@
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using generic-table-enums.m2c
  */
 @include generic-header-top.m2i@
 @eval $name = "$m2c_save"@
 @end@ // m2c_create_fewer_files
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START header generated by $RCSfile$ $Revision$ */
+/** START header generated by generic-table-enums.m2c */
 @end@
 ##
  /*
@@ -59,5 +55,5 @@
 @end@
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END header generated by $RCSfile$ $Revision$ */
+/** END header generated by generic-table-enums.m2c */
 @end@
diff --git a/local/mib2c-conf.d/generic-table-indexes-from-oid.m2i b/local/mib2c-conf.d/generic-table-indexes-from-oid.m2i
index 758bda2..ae24760 100644
--- a/local/mib2c-conf.d/generic-table-indexes-from-oid.m2i
+++ b/local/mib2c-conf.d/generic-table-indexes-from-oid.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-table-indexes-from-oid.m2i */
 @end@
 ########################################################################
 ##
@@ -66,5 +65,5 @@ ${context}_index_from_oid(netsnmp_index *oid_idx,
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-table-indexes-from-oid.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-table-indexes-set.m2i b/local/mib2c-conf.d/generic-table-indexes-set.m2i
index 34f9c7d..cac415c 100644
--- a/local/mib2c-conf.d/generic-table-indexes-set.m2i
+++ b/local/mib2c-conf.d/generic-table-indexes-set.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-table-indexes-set.m2i */
 @end@
 ########################################################################
 ##
@@ -119,5 +118,5 @@ ${context}_indexes_set(${context}_rowreq_ctx *rowreq_ctx$gtis_tmp)
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-table-indexes-set.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-table-indexes-to-oid.m2i b/local/mib2c-conf.d/generic-table-indexes-to-oid.m2i
index c17de4c..9918b00 100644
--- a/local/mib2c-conf.d/generic-table-indexes-to-oid.m2i
+++ b/local/mib2c-conf.d/generic-table-indexes-to-oid.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-table-indexes-to-oid.m2i */
 @end@
 ########################################################################
 ##
@@ -48,5 +47,5 @@ ${context}_index_to_oid(netsnmp_index *oid_idx,
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-table-indexes-to-oid.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-table-indexes-varbind-setup.m2i b/local/mib2c-conf.d/generic-table-indexes-varbind-setup.m2i
index 8c0d48d..414f296 100644
--- a/local/mib2c-conf.d/generic-table-indexes-varbind-setup.m2i
+++ b/local/mib2c-conf.d/generic-table-indexes-varbind-setup.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-table-indexes-varbind-setup.m2i */
 @end@
 ########################################################################
 ##
@@ -47,5 +46,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-table-indexes-varbind-setup.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-table-indexes.m2i b/local/mib2c-conf.d/generic-table-indexes.m2i
index c226611..b41a0ad 100644
--- a/local/mib2c-conf.d/generic-table-indexes.m2i
+++ b/local/mib2c-conf.d/generic-table-indexes.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-table-indexes.m2i */
 @end@
 ########################################################################
 ##
@@ -63,5 +62,5 @@ typedef struct ${context}_mib_index_s {
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-table-indexes.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-table-oids.m2c b/local/mib2c-conf.d/generic-table-oids.m2c
index 6f8ab2a..20e5ce8 100644
--- a/local/mib2c-conf.d/generic-table-oids.m2c
+++ b/local/mib2c-conf.d/generic-table-oids.m2c
@@ -1,25 +1,21 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_create_fewer_files != 1@
-@eval $hack = "Id"@
 @eval $m2c_save = "$name"@
 @eval $name = "${m2c_save}_oids"@
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using generic-table-oids.m2c
  */
 @include generic-header-top.m2i@
 @eval $name = "$m2c_save"@
 @end@ // m2c_create_fewer_files
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START header generated by $RCSfile$ $Revision$ */
+/** START header generated by generic-table-oids.m2c */
 @end@
 ##
 
@@ -109,5 +105,5 @@
 @end@
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END header generated by $RCSfile$ $Revision$ */
+/** END header generated by generic-table-oids.m2c */
 @end@
diff --git a/local/mib2c-conf.d/generic-value-map-func.m2i b/local/mib2c-conf.d/generic-value-map-func.m2i
index b0df63b..88fd565 100644
--- a/local/mib2c-conf.d/generic-value-map-func.m2i
+++ b/local/mib2c-conf.d/generic-value-map-func.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-value-map-func.m2i */
 @end@
 ########################################################################
 ## }
@@ -100,5 +99,5 @@ ${node}_map($m2c_node_map_param)
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-value-map-func.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-value-map-reverse.m2i b/local/mib2c-conf.d/generic-value-map-reverse.m2i
index 4b6eb38..304358d 100644
--- a/local/mib2c-conf.d/generic-value-map-reverse.m2i
+++ b/local/mib2c-conf.d/generic-value-map-reverse.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-value-map-reverse.m2i */
 @end@
 ########################################################################
 ##
@@ -45,5 +44,5 @@ $example_end
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-value-map-reverse.m2i */
 @end@
diff --git a/local/mib2c-conf.d/generic-value-map.m2i b/local/mib2c-conf.d/generic-value-map.m2i
index 0f7bd2e..809e8e9 100644
--- a/local/mib2c-conf.d/generic-value-map.m2i
+++ b/local/mib2c-conf.d/generic-value-map.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by generic-value-map.m2i */
 @end@
 ########################################################################
 ## }
@@ -42,5 +41,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by generic-value-map.m2i */
 @end@
diff --git a/local/mib2c-conf.d/m2c_setup_enum.m2i b/local/mib2c-conf.d/m2c_setup_enum.m2i
index b5bb7ae..76597f4 100644
--- a/local/mib2c-conf.d/m2c_setup_enum.m2i
+++ b/local/mib2c-conf.d/m2c_setup_enum.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by m2c_setup_enum.m2i */
 @end@
 ########################################################################
 ##
@@ -20,5 +19,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by m2c_setup_enum.m2i */
 @end@
diff --git a/local/mib2c-conf.d/m2c_setup_node.m2i b/local/mib2c-conf.d/m2c_setup_node.m2i
index 67fb89d..f8b80c5 100644
--- a/local/mib2c-conf.d/m2c_setup_node.m2i
+++ b/local/mib2c-conf.d/m2c_setup_node.m2i
@@ -1,6 +1,5 @@
 #############################################################  -*- c -*-
 ## Defaults
-## $Id$
 ########################################################################
 @if "$m2c_node_name" ne "$node"@
 ## if $node.accessible != 1, might be inaccessible index node
diff --git a/local/mib2c-conf.d/m2c_setup_table.m2i b/local/mib2c-conf.d/m2c_setup_table.m2i
index 4481e39..4acd016 100644
--- a/local/mib2c-conf.d/m2c_setup_table.m2i
+++ b/local/mib2c-conf.d/m2c_setup_table.m2i
@@ -1,10 +1,9 @@
 ########################################################################
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by m2c_setup_table.m2i */
 @end@
 ########################################################################
 ##
@@ -44,5 +43,5 @@
 ########################################################################
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by m2c_setup_table.m2i */
 @end@
diff --git a/local/mib2c-conf.d/m2c_table_save_defaults.m2i b/local/mib2c-conf.d/m2c_table_save_defaults.m2i
index e36c32e..7c4cfeb 100644
--- a/local/mib2c-conf.d/m2c_table_save_defaults.m2i
+++ b/local/mib2c-conf.d/m2c_table_save_defaults.m2i
@@ -1,7 +1,6 @@
 #######################################################################
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 ##
 ##
diff --git a/local/mib2c-conf.d/mfd-access-container-cached-defines.m2i b/local/mib2c-conf.d/mfd-access-container-cached-defines.m2i
index 5f65b63..690973e 100644
--- a/local/mib2c-conf.d/mfd-access-container-cached-defines.m2i
+++ b/local/mib2c-conf.d/mfd-access-container-cached-defines.m2i
@@ -1,10 +1,9 @@
 #######################################################################
 ###generic include for XXX. Do not use directly.
 ###
-### $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-access-container-cached-defines.m2i */
 @end@
 ##//####################################################################
 ##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ -191,6 +190,14 @@ ${context}_container_load(netsnmp_container *container)
     size_t                 count = 0;
 
     /*
+     * storage for each column
+     */
+@  foreach $node index@
+@    include m2c_setup_node.m2i@
+@    include node-storage.m2i@
+@  end@ // foreach
+
+    /*
      * temporary storage for index values
      */
 @  foreach $node index@
@@ -514,8 +521,16 @@ _${context}_container_init(${context}_interface_ctx *if_ctx)
      */    
     ${context}_container_init(&if_ctx->container);
 @   end@ data cache
-    if(NULL == if_ctx->container)
+    if(NULL == if_ctx->container) {
         if_ctx->container = netsnmp_container_find("${context}:table_container");
+        if(NULL != if_ctx->container) {
+            /*
+             * When reporting container management errors, we log the container's
+             * name, so set it here.
+             */
+            if_ctx->container->container_name = strdup("${context}");
+        }
+    }
     if(NULL == if_ctx->container) {
         snmp_log(LOG_ERR,"error creating container in "
                  "${context}_container_init\n");
@@ -572,5 +587,5 @@ _${context}_container_shutdown(${context}_interface_ctx *if_ctx)
 ########################################################################
 ##//####################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-access-container-cached-defines.m2i */
 @end@
diff --git a/local/mib2c-conf.d/mfd-access-unsorted-external-defines.m2i b/local/mib2c-conf.d/mfd-access-unsorted-external-defines.m2i
index f4f3514..65ccb9b 100644
--- a/local/mib2c-conf.d/mfd-access-unsorted-external-defines.m2i
+++ b/local/mib2c-conf.d/mfd-access-unsorted-external-defines.m2i
@@ -1,7 +1,6 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 ##
 @eval $mfd_aue_wrap_param = "wrap_ctx"@
@@ -14,7 +13,7 @@
 @eval $mfd_aue_param_cmt = "$mfd_aue_param Pointer to a $mfd_aue_param_type"
 ##
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-access-unsorted-external-defines.m2i */
 @end@
 ##//####################################################################
 ##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ -1194,5 +1193,5 @@ $example_end
 @end@ // m2c_processing_type eq 'r
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-access-unsorted-external-defines.m2i */
 @end@
diff --git a/local/mib2c-conf.d/mfd-data-access.m2c b/local/mib2c-conf.d/mfd-data-access.m2c
index bcff9bb..dc97b89 100644
--- a/local/mib2c-conf.d/mfd-data-access.m2c
+++ b/local/mib2c-conf.d/mfd-data-access.m2c
@@ -1,7 +1,6 @@
 ##//#########################################################  -*- c -*-
 ##//generic include for XXX. Do not use directly.
 ##
-##//$Id$
 ##//####################################################################
 ##//####################################################################
 ##
@@ -10,15 +9,12 @@
 @eval $mfd_data_access_processing_type = "$m2c_processing_type"@
 @eval $m2c_processing_type = 'h'@
 @open ${name}_data_access.h@
-@eval $hack = "Id"@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-data-access.m2c
  */
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-data-access.m2c */
 @end@
 @eval $m2c_save = "$name"@
 @eval $name = "${name}_DATA_ACCESS"@
@@ -71,10 +67,8 @@ int ${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx ); /* internal */
 @eval $m2c_processing_type = 'c'@
 @open ${name}_data_access.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$ 
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-data-access.m2c
  */
 @include generic-source-includes.m2i@
 
@@ -326,6 +320,6 @@ ${context}_validate_index( ${context}_registration * ${context}_reg,
 /** @} */
 ##//####################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-data-access.m2c */
 @end@
 @eval $m2c_processing_type = "$mfd_data_access_processing_type"@
diff --git a/local/mib2c-conf.d/mfd-data-get.m2c b/local/mib2c-conf.d/mfd-data-get.m2c
index cf1c848..448b9c6 100644
--- a/local/mib2c-conf.d/mfd-data-get.m2c
+++ b/local/mib2c-conf.d/mfd-data-get.m2c
@@ -1,7 +1,6 @@
 ############################################################# -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 ########################################################################
 ## lower conf files get confused with multiple processing types, so
@@ -11,12 +10,9 @@
 @eval $m2c_processing_type = 'h'@
 @if $m2c_create_fewer_files != 1@
 @   open ${name}_data_get.h@
-@   eval $hack = "Id"@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-data-get.m2c
  *
  * @file ${name}_data_get.h
  *
@@ -32,7 +28,7 @@
 @   eval $name = "$m2c_tmp"@
 @end@ // m2c_create_fewer_files
 @if $m2c_mark_boundary == 1@
-/** START header generated by $RCSfile$ $Revision$ */
+/** START header generated by mfd-data-get.m2c */
 @end@
 ########################################################################
 ##
@@ -69,7 +65,7 @@
 @end@ // table
 
 @if $m2c_mark_boundary == 1@
-/** END header generated by $RCSfile$ $Revision$ */
+/** END header generated by mfd-data-get.m2c */
 @end@
 @if $m2c_create_fewer_files != 1@
 @   eval $m2c_tmp = "$name"@
@@ -88,10 +84,8 @@
 @if $m2c_create_fewer_files != 1@
 @open ${name}_data_get.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$ 
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-data-get.m2c
  */
 @include generic-source-includes.m2i@
 
@@ -108,7 +102,7 @@
  */
 @end@ // m2c_create_fewer_files
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-data-get.m2c */
 @end@
 @foreach $table table@
 @    include m2c_setup_table.m2i@
@@ -160,7 +154,7 @@
 /** @} */
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-data-get.m2c */
 @end@
 ########################################################################
 @end@ // $mfd_processing_types =~ /c/
diff --git a/local/mib2c-conf.d/mfd-data-set.m2c b/local/mib2c-conf.d/mfd-data-set.m2c
index 1150551..3933e9a 100644
--- a/local/mib2c-conf.d/mfd-data-set.m2c
+++ b/local/mib2c-conf.d/mfd-data-set.m2c
@@ -1,7 +1,6 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 ## lower conf files get confused with multiple processing types, so
 ## set single options
@@ -9,13 +8,10 @@
 @if "$mfd_processing_types" =~ /h/@
 @eval $m2c_processing_type = 'h'@
 @if $m2c_create_fewer_files != 1@
-@   eval $hack = "Id"@
 @open ${name}_data_set.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$ 
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-data-set.m2c
  */
 @eval $m2c_save = "$name"@
 @eval $name = "${name}_DATA_SET"@
@@ -24,7 +20,7 @@
 @end@ // m2c_create_fewer_files
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START header generated by $RCSfile$ $Revision$ */
+/** START header generated by mfd-data-set.m2c */
 @end@
 ##
 /* *********************************************************************
@@ -56,7 +52,7 @@ int ${context}_check_dependencies(${context}_rowreq_ctx *ctx);
 @end@ # foreach table
 
 @if $m2c_mark_boundary == 1@
-/** END header generated by $RCSfile$ $Revision$ */
+/** END header generated by mfd-data-set.m2c */
 @end@
 @if $m2c_create_fewer_files != 1@
 @eval $m2c_save = "$name"@
@@ -77,10 +73,8 @@ int ${context}_check_dependencies(${context}_rowreq_ctx *ctx);
 @if $m2c_create_fewer_files != 1@
 @open ${name}_data_set.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-data-set.m2c
  *
  */
 @include generic-source-includes.m2i@
@@ -94,7 +88,7 @@ int ${context}_check_dependencies(${context}_rowreq_ctx *ctx);
  */
 @end@ // m2c_create_fewer_files
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-data-set.m2c */
 @end@
 ########################################################################
 @foreach $table table@
@@ -134,7 +128,7 @@ int ${context}_check_dependencies(${context}_rowreq_ctx *ctx);
 ########################################################################
 /** @} */
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-data-set.m2c */
 @end@
 ########################################################################
 @end@ // mfd_processing_type =~ /c/
diff --git a/local/mib2c-conf.d/mfd-interactive-setup.m2c b/local/mib2c-conf.d/mfd-interactive-setup.m2c
index e3d3d55..772f168 100644
--- a/local/mib2c-conf.d/mfd-interactive-setup.m2c
+++ b/local/mib2c-conf.d/mfd-interactive-setup.m2c
@@ -1,10 +1,9 @@
 #######################################################################
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-interactive-setup.m2c */
 @end@
 ########################################################################
 @eval $m2c_temp_writable = table_is_writable($context)@
@@ -331,5 +330,5 @@ snmpd. (You can still link it in later.)
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-interactive-setup.m2c */
 @end@
diff --git a/local/mib2c-conf.d/mfd-interface.m2c b/local/mib2c-conf.d/mfd-interface.m2c
index d666c9a..258a62e 100644
--- a/local/mib2c-conf.d/mfd-interface.m2c
+++ b/local/mib2c-conf.d/mfd-interface.m2c
@@ -1,22 +1,18 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-interface.m2c */
 @end@
 ########################################################################
 ##
 ########################################################################
 @eval $m2c_processing_type = 'h'@
 @open ${name}_interface.h@
-@eval $hack = "Id"@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-interface.m2c
  */
 /** @ingroup interface: Routines to interface to Net-SNMP
  *
@@ -104,10 +100,8 @@ void ${context}_valid_columns_set(netsnmp_column_info *vc);
 ##
 @open ${name}_interface.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$ 
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-interface.m2c
  */
 @include m2c-internal-warning.m2i@
 
@@ -332,7 +326,7 @@ _${context}_initialize_interface(${context}_registration * reg_ptr,  u_long flag
                                                   ${context}_oid,
                                                   ${context}_oid_size,
                                                   HANDLER_CAN_BABY_STEP |
-#if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
+#if (defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
                                                   HANDLER_CAN_RONLY
 #else
 @if $m2c_table_settable == 1@
@@ -915,7 +909,7 @@ rc = ${node}_get(rowreq_ctx, $m2c_node_var_ref );
         var->val_len = 0;
         while( 0 != mask ) {
             ++idx;
-            if ( *(($m2c_decl *) var->val.string) & mask )
+            if ( ntohl( *(($m2c_decl *) var->val.string) ) & mask )
                 var->val_len = idx;
             mask = mask >> 8;
         }
@@ -961,7 +955,7 @@ _mfd_${context}_get_values(netsnmp_mib_handler *handler,
     
 @if $m2c_table_sparse == 1@
     DEBUGMSGTL(("9:${context}:_mfd_${context}_get_values",
-                "exists %p\n", (void*)rowreq_ctx->column_exists_flags));
+                "exists %x\n", rowreq_ctx->column_exists_flags));
 
 @end@
     for(;requests; requests = requests->next) {
@@ -1618,7 +1612,7 @@ _mfd_${context}_irreversible_commit(netsnmp_mib_handler *handler,
         if (rowreq_ctx->column_set_flags) {
 @if $m2c_table_sparse == 1@
            DEBUGMSGTL(("internal:${context}:_mfd_irreversible_commit",
-                       "updating exists (%p) w/set (%p) = %p\n",
+                       "updating exists (%x) w/set (%x) = %x\n",
                        rowreq_ctx->column_exists_flags,
                        rowreq_ctx->column_set_flags,
                        (rowreq_ctx->column_exists_flags |
@@ -1714,5 +1708,5 @@ ${context}_row_ref_decrement(${context}_rowreq_ctx *rowreq_ctx)
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-interface.m2c */
 @end@
diff --git a/local/mib2c-conf.d/mfd-makefile.m2m b/local/mib2c-conf.d/mfd-makefile.m2m
index c41d5bb..be00fbb 100644
--- a/local/mib2c-conf.d/mfd-makefile.m2m
+++ b/local/mib2c-conf.d/mfd-makefile.m2m
@@ -1,5 +1,4 @@
 ####################################################### -*- Makefile -*-
-## $Id$
 ##
 ########################################################################
 ##
@@ -16,7 +15,7 @@
 @   else@
 ########################################################################
 @      if $m2c_mark_boundary == 1@
-# START code generated by $RCSfile$ $Revision$
+# START code generated by mfd-makefile.m2m
 @      end@
 ########################################################################
 
@@ -132,7 +131,7 @@ include $(TABLE_PREFIX)_data_set.deps
 @end@
 ########################################################################
 @      if $m2c_mark_boundary == 1@
-# END code generated by $RCSfile$ $Revision$
+# END code generated by mfd-makefile.m2m
 @      end@
 @   end@ # not including ${name}_Makefile.m2m
 @   close ${name}_Makefile@
diff --git a/local/mib2c-conf.d/mfd-persistence.m2i b/local/mib2c-conf.d/mfd-persistence.m2i
index 7796cf2..caeb2c7 100644
--- a/local/mib2c-conf.d/mfd-persistence.m2i
+++ b/local/mib2c-conf.d/mfd-persistence.m2i
@@ -1,9 +1,8 @@
 ########################################################################
 ## generic include for XXX. Do not use directly.
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-persistence.m2i */
 @end@
 ########################################################################
 @if $m2c_processing_type eq 'h'@
@@ -474,5 +473,5 @@ _${context}_container_col_restore(
 @end@ // $m2c_processing_type eq 'i'
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-persistence.m2i */
 @end@
diff --git a/local/mib2c-conf.d/mfd-readme.m2c b/local/mib2c-conf.d/mfd-readme.m2c
index 5ed9d59..cb83cf6 100644
--- a/local/mib2c-conf.d/mfd-readme.m2c
+++ b/local/mib2c-conf.d/mfd-readme.m2c
@@ -1,10 +1,9 @@
 ########################################################################
 ## generic include for XXX. Don't use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-readme.m2c */
 @end@
 ########################################################################
 ##
@@ -842,5 +841,5 @@ Table / column details
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-readme.m2c */
 @end@
diff --git a/local/mib2c-conf.d/mfd-top.m2c b/local/mib2c-conf.d/mfd-top.m2c
index db0f398..af45116 100644
--- a/local/mib2c-conf.d/mfd-top.m2c
+++ b/local/mib2c-conf.d/mfd-top.m2c
@@ -1,6 +1,5 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
-## $Id$
 ########################################################################
 ########################################################################
 ##
@@ -74,12 +73,9 @@
 ########################################################################
 @eval $m2c_processing_type = 'h'@
 @open ${name}.h@
-@eval $hack = "Id"@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-top.m2c
  */
 @include generic-header-top.m2i@
 
@@ -88,7 +84,7 @@
  * @{
  */
 @if $m2c_mark_boundary == 1@
-/** START header generated by $RCSfile$ $Revision$ */
+/** START header generated by mfd-top.m2c */
 @end@
 #include <net-snmp/library/asn1.h>
 
@@ -278,7 +274,7 @@ extern const int ${context}_oid_size;
  * TODO:499:x: *************************************************************
  */
 @if $m2c_mark_boundary == 1@
-/** END header generated by $RCSfile$ $Revision$ */
+/** END header generated by mfd-top.m2c */
 @end@
 @include generic-header-bottom.m2i@
 /** @} */
@@ -288,10 +284,8 @@ extern const int ${context}_oid_size;
 @eval $m2c_processing_type = 'c'@
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$ 
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mfd-top.m2c
  */
 /** \page MFD helper for ${name}
  *
@@ -303,7 +297,7 @@ extern const int ${context}_oid_size;
 #include <net-snmp/agent/mib_modules.h>
 
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mfd-top.m2c */
 @end@
 #include "${name}_interface.h"
 
@@ -577,7 +571,7 @@ ${context}_post_request(${context}_registration * user_context, int rc)
 ########################################################################
 /** @{ */
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mfd-top.m2c */
 @end@
 ##
 ########################################################################
diff --git a/local/mib2c-conf.d/node-get.m2i b/local/mib2c-conf.d/node-get.m2i
index 1d7255c..035fecf 100644
--- a/local/mib2c-conf.d/node-get.m2i
+++ b/local/mib2c-conf.d/node-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by node-get.m2i */
 @end@
 ########################################################################
 ##
@@ -103,5 +102,5 @@ ${node}_get( ${context}_rowreq_ctx *rowreq_ctx, $m2c_node_param_ref )
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by node-get.m2i */
 @end@
diff --git a/local/mib2c-conf.d/node-set.m2i b/local/mib2c-conf.d/node-set.m2i
index 2041b59..78c252d 100644
--- a/local/mib2c-conf.d/node-set.m2i
+++ b/local/mib2c-conf.d/node-set.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by node-set.m2i */
 @end@
 ########################################################################
 ##
@@ -232,5 +231,5 @@ ${node}_undo( ${context}_rowreq_ctx *rowreq_ctx)
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by node-set.m2i */
 @end@
diff --git a/local/mib2c-conf.d/node-storage.m2i b/local/mib2c-conf.d/node-storage.m2i
index 7a941f0..bf5b97d 100644
--- a/local/mib2c-conf.d/node-storage.m2i
+++ b/local/mib2c-conf.d/node-storage.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by node-storage.m2i */
 @end@
 ########################################################################
 ##
@@ -17,5 +16,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by node-storage.m2i */
 @end@
diff --git a/local/mib2c-conf.d/node-validate.m2i b/local/mib2c-conf.d/node-validate.m2i
index a63f1d7..a03d700 100644
--- a/local/mib2c-conf.d/node-validate.m2i
+++ b/local/mib2c-conf.d/node-validate.m2i
@@ -1,13 +1,12 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ##
 ## assumes an integer rc is available and will be tested by caller
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by node-validate.m2i */
 @end@
 ########################################################################
 ##----------------------------------------------------------------------
@@ -29,15 +28,20 @@
 @   else@ # BITS
 ## {
     if($m2c_nv_len > 4) {
-        snmp_log(LOG_ERR,"I can not handle BITS > 4 bytes\n");
+        DEBUGMSGTL(("${context}:${node}",
+            "I can not handle BITS > 4 bytes\n"));
         rc = SNMP_ERR_GENERR;
     }
     else if (SNMPERR_SUCCESS == rc){
         u_long bits = 0;
         /* check that value is within enum mask */
         memcpy( &bits, $m2c_nv_str, $m2c_nv_len);
-        if( (bits | $m2c_enum_mask) != $m2c_enum_mask)
-        rc = SNMP_ERR_WRONGVALUE;
+        bits = ntohl( bits );
+        if( (bits | $m2c_enum_mask) != $m2c_enum_mask) {
+            DEBUGMSGTL(("${context}:${node}",
+                "bad bits set: bits = %x valid = %x", bits, $m2c_enum_mask));
+            rc = SNMP_ERR_WRONGVALUE;
+        }
     }
 @   end@
 ##----------------------------------------------------------------------
@@ -67,5 +71,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by node-validate.m2i */
 @end@
diff --git a/local/mib2c-conf.d/node-varbind-validate.m2i b/local/mib2c-conf.d/node-varbind-validate.m2i
index 1b3fb37..013ecb4 100644
--- a/local/mib2c-conf.d/node-varbind-validate.m2i
+++ b/local/mib2c-conf.d/node-varbind-validate.m2i
@@ -1,7 +1,6 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ##
 ## Tests a netsnmp_variable_list pointer (var) against known
 ## contstraints. If none are found, calls the user supplied funtion
@@ -14,7 +13,7 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by node-varbind-validate.m2i */
 @end@
 ########################################################################
 ##----------------------------------------------------------------------
@@ -50,5 +49,5 @@ netsnmp_assert(rc == SNMP_ERR_NOERROR); /* paranoia */
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by node-varbind-validate.m2i */
 @end@
diff --git a/local/mib2c-conf.d/parent-dependencies.m2i b/local/mib2c-conf.d/parent-dependencies.m2i
index 104f150..3a867c9 100644
--- a/local/mib2c-conf.d/parent-dependencies.m2i
+++ b/local/mib2c-conf.d/parent-dependencies.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by parent-dependencies.m2i */
 @end@ # ;
 ########################################################################
 ##
@@ -59,5 +58,5 @@ ${context}_check_dependencies(${context}_rowreq_ctx *rowreq_ctx)
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by parent-dependencies.m2i */
 @end@
diff --git a/local/mib2c-conf.d/parent-set.m2i b/local/mib2c-conf.d/parent-set.m2i
index 02afe3d..fcf775d 100644
--- a/local/mib2c-conf.d/parent-set.m2i
+++ b/local/mib2c-conf.d/parent-set.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by parent-set.m2i */
 @end@
 ########################################################################
 ##//####################################################################
@@ -358,10 +357,16 @@ ${context}_undo_commit( ${context}_rowreq_ctx *rowreq_ctx)
 
     /*
      * TODO:485:M: |-> Undo $context commit.
-     * check the column's flag in rowreq_ctx->column_set_flags to see
+     * check each column's flag in rowreq_ctx->column_set_flags to see
      * if it was set during commit, then undo it.
      *
+@   foreach $node nonindex@
+@      include m2c_setup_node.m2i@
+@      if $node.settable == 0@
+@          next@
+@      end@
      * eg: if (rowreq_ctx->column_set_flags & COLUMN_$node.uc_FLAG) {}
+@   end@ # foreach $node
      */
 
     
@@ -413,5 +418,5 @@ ${context}_irreversible_commit( ${context}_rowreq_ctx *rowreq_ctx)
 @end@ // m2c_processing_type eq 'c'
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by parent-set.m2i */
 @end@
diff --git a/local/mib2c-conf.d/subagent.m2c b/local/mib2c-conf.d/subagent.m2c
index 61fc26d..4c887bd 100644
--- a/local/mib2c-conf.d/subagent.m2c
+++ b/local/mib2c-conf.d/subagent.m2c
@@ -1,17 +1,16 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by subagent.m2c */
 @end@
 ########################################################################
 ##
 @if 0@
 @open ${name}_subagent.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$ 
+ * Note: this file originally auto-generated by mib2c
+ * using subagent.m2c
  */
 @include generic-header-top.m2i@
 @include generic-header-bottom.m2i@
@@ -21,8 +20,8 @@
 ######################################################################
 @open ${name}_subagent.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       version $Revision$ of $RCSfile$ 
+ * Note: this file originally auto-generated by mib2c
+ * using subagent.m2c
  */
 @include generic-source-includes.m2i@
 #include <signal.h>
@@ -191,5 +190,5 @@ main (int argc, char **argv) {
 
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by subagent.m2c */
 @end@
diff --git a/local/mib2c-conf.d/syntax-COUNTER64-get.m2i b/local/mib2c-conf.d/syntax-COUNTER64-get.m2i
index 7f36830..ed43419 100644
--- a/local/mib2c-conf.d/syntax-COUNTER64-get.m2i
+++ b/local/mib2c-conf.d/syntax-COUNTER64-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-COUNTER64-get.m2i */
     ## }
 @end@
 ########################################################################
@@ -31,5 +30,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-COUNTER64-get.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-DateAndTime-get.m2i b/local/mib2c-conf.d/syntax-DateAndTime-get.m2i
index 984d1e2..07dd15c 100644
--- a/local/mib2c-conf.d/syntax-DateAndTime-get.m2i
+++ b/local/mib2c-conf.d/syntax-DateAndTime-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-DateAndTime-get.m2i */
 @end@
 ########################################################################
 ##
@@ -50,5 +49,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-DateAndTime-get.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-InetAddress-get.m2i b/local/mib2c-conf.d/syntax-InetAddress-get.m2i
index 253980c..cf3fe15 100644
--- a/local/mib2c-conf.d/syntax-InetAddress-get.m2i
+++ b/local/mib2c-conf.d/syntax-InetAddress-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-InetAddress-get.m2i */
 @end@
 ########################################################################
 ##
@@ -96,5 +95,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-InetAddress-get.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-InetAddress-set.m2i b/local/mib2c-conf.d/syntax-InetAddress-set.m2i
index be3cf10..90da1c8 100644
--- a/local/mib2c-conf.d/syntax-InetAddress-set.m2i
+++ b/local/mib2c-conf.d/syntax-InetAddress-set.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-InetAddress-set.m2i */
 @end@
 ########################################################################
 ##
@@ -18,5 +17,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-InetAddress-set.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-InetAddressType-get.m2i b/local/mib2c-conf.d/syntax-InetAddressType-get.m2i
index 0b89a5a..9fc45eb 100644
--- a/local/mib2c-conf.d/syntax-InetAddressType-get.m2i
+++ b/local/mib2c-conf.d/syntax-InetAddressType-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-InetAddressType-get.m2i */
 @end@
 ########################################################################
 ##
@@ -21,5 +20,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-InetAddressType-get.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-InetAddressType-set.m2i b/local/mib2c-conf.d/syntax-InetAddressType-set.m2i
index fb81efe..173519d 100644
--- a/local/mib2c-conf.d/syntax-InetAddressType-set.m2i
+++ b/local/mib2c-conf.d/syntax-InetAddressType-set.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-InetAddressType-set.m2i */
 @end@
 ########################################################################
 ##
@@ -21,5 +20,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-InetAddressType-set.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-RowStatus-dependencies.m2i b/local/mib2c-conf.d/syntax-RowStatus-dependencies.m2i
index 9f14baf..6784a9b 100644
--- a/local/mib2c-conf.d/syntax-RowStatus-dependencies.m2i
+++ b/local/mib2c-conf.d/syntax-RowStatus-dependencies.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-RowStatus-dependencies.m2i */
 @end@
 ########################################################################
 ## {
@@ -40,6 +39,14 @@
                 }
                 ${m2c_data_item}$node = ROWSTATUS_ACTIVE;
             }
+            else if (ROWSTATUS_CREATEANDWAIT ==  ${m2c_data_item}$node) {
+                if ((rowreq_ctx->column_set_flags & $context.uc_REQUIRED_COLS)
+                    != $context.uc_REQUIRED_COLS) {
+                    ${m2c_data_item}$node = ROWSTATUS_NOTREADY;
+                } else {
+                    ${m2c_data_item}$node = ROWSTATUS_NOTINSERVICE;
+                }
+            }
         } /* row creation */
         else {
 @end@
@@ -109,5 +116,5 @@
 ## }
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-RowStatus-dependencies.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-RowStatus-get.m2i b/local/mib2c-conf.d/syntax-RowStatus-get.m2i
index f8e0996..a9a6b7d 100644
--- a/local/mib2c-conf.d/syntax-RowStatus-get.m2i
+++ b/local/mib2c-conf.d/syntax-RowStatus-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-RowStatus-get.m2i */
 @end@
 ########################################################################
 ##
@@ -61,5 +60,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-RowStatus-get.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-RowStatus-varbind-validate.m2i b/local/mib2c-conf.d/syntax-RowStatus-varbind-validate.m2i
index dc91ac8..c4feeb9 100644
--- a/local/mib2c-conf.d/syntax-RowStatus-varbind-validate.m2i
+++ b/local/mib2c-conf.d/syntax-RowStatus-varbind-validate.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-RowStatus-varbind-validate.m2i */
 @end@
 ########################################################################
 ##
@@ -12,5 +11,5 @@ rc = netsnmp_check_vb_rowstatus_value(var);
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-RowStatus-varbind-validate.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-StorageType-dependencies.m2i b/local/mib2c-conf.d/syntax-StorageType-dependencies.m2i
index 0419514..9b2a96d 100644
--- a/local/mib2c-conf.d/syntax-StorageType-dependencies.m2i
+++ b/local/mib2c-conf.d/syntax-StorageType-dependencies.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-StorageType-dependencies.m2i */
 @end@
 ########################################################################
 ## {
@@ -15,5 +14,5 @@
 ## }
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-StorageType-dependencies.m2i */
 @end@
diff --git a/local/mib2c-conf.d/syntax-TestAndIncr-get.m2i b/local/mib2c-conf.d/syntax-TestAndIncr-get.m2i
index 7cd2f60..28f7cc6 100644
--- a/local/mib2c-conf.d/syntax-TestAndIncr-get.m2i
+++ b/local/mib2c-conf.d/syntax-TestAndIncr-get.m2i
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## generic include for XXX. Do not use directly.
 ##
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by syntax-TestAndIncr-get.m2i */
 @end@
 ########################################################################
 ##
@@ -18,5 +17,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by syntax-TestAndIncr-get.m2i */
 @end@
diff --git a/local/mib2c.access_functions.conf b/local/mib2c.access_functions.conf
index 9d54f14..20433ad 100644
--- a/local/mib2c.access_functions.conf
+++ b/local/mib2c.access_functions.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}_access.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.access_functions.conf
  */
 #ifndef $name.uc_ACCESS_H
 #define $name.uc_ACCESS_H
@@ -36,8 +36,8 @@ void * ${t}_create_data_context(netsnmp_variable_list *index_data, int column);
 @open ${name}_access.c@
 
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.access_functions.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.array-user.conf b/local/mib2c.array-user.conf
index 31559ac..49cf981 100644
--- a/local/mib2c.array-user.conf
+++ b/local/mib2c.array-user.conf
@@ -9,12 +9,9 @@
 ######################################################################
 @foreach $i table@
 @open ${i}.h@
-@eval $hack = "Id"
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.array-user.conf
  *
  * Yes, there is lots of code here that you might not use. But it is much
  * easier to remove code than to add it!
@@ -217,12 +214,9 @@ ${i}_context * ${i}_get( const char *name, int len );
 ######################################################################
 @foreach $i table@
 @open ${i}.c@
-@eval $hack = "Id"@
 /*
- * Note: this file originally auto-generated by mib2c using
- *       $Id$
- *
- * $$hack:$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.array-user.conf
  *
  *
  * For help understanding NET-SNMP in general, please check the 
diff --git a/local/mib2c.check_values.conf b/local/mib2c.check_values.conf
index 259ac1f..28bff88 100644
--- a/local/mib2c.check_values.conf
+++ b/local/mib2c.check_values.conf
@@ -5,7 +5,8 @@
 ######################################################################
 @open ${name}_checkfns.h@
 /*
- * Note: this file originally auto-generated by mib2c using
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.check_values.conf
  *        : mib2c.iterate.conf,v 5.6 2003/02/20 00:52:07 hardaker Exp $
  */
 
@@ -40,8 +41,8 @@ datatype and value.
 ######################################################################
 @open ${name}_checkfns.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.check_values.conf
  */
 
 /********************************************************************
diff --git a/local/mib2c.check_values_local.conf b/local/mib2c.check_values_local.conf
index 13c1e60..f132589 100644
--- a/local/mib2c.check_values_local.conf
+++ b/local/mib2c.check_values_local.conf
@@ -4,12 +4,12 @@
 ######################################################################
 @open ${name}_checkfns_local.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        : $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.check_values_local.conf
  * 
  */
-#ifndef $name.uc_CHECKFNS_H
-#define $name.uc_CHECKFNS_H
+#ifndef $name.uc_CHECKFNS_LOCAL_H
+#define $name.uc_CHECKFNS_LOCAL_H
 
 @foreach $t table@
 /* these functions are designed to check incoming values for 
@@ -27,15 +27,15 @@ should NOT be modified.
   @end@
 @end@
 
-#endif /* $name.uc_CHECKFNS_H */
+#endif /* $name.uc_CHECKFNS_LOCAL_H */
 
 ######################################################################
 ## Do the .c file
 ######################################################################
 @open ${name}_checkfns_local.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.check_values_local.conf
  */
 
 /* standard headers */
diff --git a/local/mib2c.column_defines.conf b/local/mib2c.column_defines.conf
index 5b8328f..023162a 100644
--- a/local/mib2c.column_defines.conf
+++ b/local/mib2c.column_defines.conf
@@ -1,7 +1,7 @@
 @open ${name}_columns.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.column_defines.conf
  */
 #ifndef $name.uc_COLUMNS_H
 #define $name.uc_COLUMNS_H
diff --git a/local/mib2c.column_enums.conf b/local/mib2c.column_enums.conf
index 4dba4fa..e639ae0 100644
--- a/local/mib2c.column_enums.conf
+++ b/local/mib2c.column_enums.conf
@@ -1,7 +1,7 @@
 @open ${name}_enums.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.column_enums.conf
  */
 #ifndef $name.uc_ENUMS_H
 #define $name.uc_ENUMS_H
diff --git a/local/mib2c.column_storage.conf b/local/mib2c.column_storage.conf
index 9f3ba1f..7167ca9 100644
--- a/local/mib2c.column_storage.conf
+++ b/local/mib2c.column_storage.conf
@@ -1,10 +1,9 @@
 #############################################################  -*- c -*-
 ## top level mfd conf file
-## $Id$
 ########################################################################
 @   open ${name}_storage.h@
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mib2c */
 @end@
 ########################################################################
 ##
@@ -19,5 +18,5 @@
 ##
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mib2c */
 @end@
diff --git a/local/mib2c.container.conf b/local/mib2c.container.conf
index e76621f..ed15461 100644
--- a/local/mib2c.container.conf
+++ b/local/mib2c.container.conf
@@ -7,8 +7,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.container.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -32,8 +32,8 @@ Netsnmp_Node_Handler ${i}_handler;
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.container.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -43,10 +43,12 @@ Netsnmp_Node_Handler ${i}_handler;
 #include <net-snmp/agent/table_container.h>
 #include "${name}.h"
 
-#ifdef ${i.uc}_USE_CACHE
-static void _cache_free(netsnmp_cache * cache, void *magic);
-static int _cache_load(netsnmp_cache * cache, void *vmagic);
+@foreach $i table@
+#ifdef $i.uc_USE_CACHE
+static void ${i}_cache_free(netsnmp_cache * cache, void *magic);
+static int ${i}_cache_load(netsnmp_cache * cache, void *vmagic);
 #endif
+@end@
 
 /** Initializes the $name module */
 void
@@ -81,7 +83,7 @@ initialize_table_$i(void)
     netsnmp_mib_handler             *handler = NULL;
     netsnmp_container               *container = NULL;
     netsnmp_table_registration_info *table_info = NULL;
-#ifdef ${i.uc}_USE_CACHE
+#ifdef $i.uc_USE_CACHE
     netsnmp_cache  *cache = NULL;
 #endif
 
@@ -140,13 +142,13 @@ initialize_table_$i(void)
     }
     handler = NULL; /* reg has it, will reuse below */
 
-#ifdef ${i.uc}_USE_CACHE
+#ifdef $i.uc_USE_CACHE
     /*************************************************
      *
      * inject cache helper
      */
     cache = netsnmp_cache_create(30,    /* timeout in seconds */
-                                 _cache_load, _cache_free,
+                                 ${i}_cache_load, ${i}_cache_free,
                                  ${i}_oid, ${i}_oid_len);
 
     if (NULL == cache) {
@@ -193,7 +195,7 @@ initialize_table_$i(void)
     if (handler)
         netsnmp_handler_free(handler);
 
-#ifdef ${i.uc}_USE_CACHE
+#ifdef $i.uc_USE_CACHE
     if (cache)
         netsnmp_cache_free(cache);
 #endif
@@ -799,12 +801,12 @@ ${i}_handler(
     return SNMP_ERR_NOERROR;
 }
 
-#ifdef ${i.uc}_USE_CACHE
+#ifdef $i.uc_USE_CACHE
 /**
  * @internal
  */
 static int
-_cache_load(netsnmp_cache * cache, void *vmagic)
+${i}_cache_load(netsnmp_cache * cache, void *vmagic)
 {
     netsnmp_container *container;
     
@@ -841,7 +843,7 @@ ${i}_freeEntry_cb(${i}_entry *entry, void *magic) {
  * @internal
  */
 static void
-_cache_free(netsnmp_cache * cache, void *magic)
+${i}_cache_free(netsnmp_cache * cache, void *magic)
 {
     netsnmp_container *container;
 
@@ -860,5 +862,5 @@ _cache_free(netsnmp_cache * cache, void *magic)
                     (netsnmp_container_obj_func*)${i}_freeEntry_cb,
                     NULL);
 }                               /* _cache_free */
-#endif /* ${i.uc}_USE_CACHE */
+#endif /* $i.uc_USE_CACHE */
 @end@
diff --git a/local/mib2c.create-dataset.conf b/local/mib2c.create-dataset.conf
index 9cf75fd..eaa0899 100644
--- a/local/mib2c.create-dataset.conf
+++ b/local/mib2c.create-dataset.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.create-dataset.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -29,8 +29,8 @@ Netsnmp_Node_Handler ${i}_handler;
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.create-dataset.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.emulation.conf b/local/mib2c.emulation.conf
index 20d2e7b..1cfe4b5 100644
--- a/local/mib2c.emulation.conf
+++ b/local/mib2c.emulation.conf
@@ -6,7 +6,6 @@
 ##          provide basic/simplistic emulation for a particular MIB.
 ##
 ## 
-## $Id$
 ######################################################################
 @open ${name}-emulation.conf@
 #
diff --git a/local/mib2c.int_watch.conf b/local/mib2c.int_watch.conf
index ecc5d10..2276c15 100644
--- a/local/mib2c.int_watch.conf
+++ b/local/mib2c.int_watch.conf
@@ -6,8 +6,8 @@
 *** Warning: only generating code for nodes of MIB type INTEGER
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.int_watch.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -21,8 +21,8 @@ void init_$name(void);
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.int_watch.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.iterate.conf b/local/mib2c.iterate.conf
index 3a2b5f7..98ddac7 100644
--- a/local/mib2c.iterate.conf
+++ b/local/mib2c.iterate.conf
@@ -38,8 +38,8 @@ Invalid value for 'cache' ($cache) - generating caching code
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -70,8 +70,8 @@ NetsnmpCacheFree ${i}_free;
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -90,7 +90,7 @@ init_$name(void)
 }
 
 @foreach $i table@
-  # Determine the first/last column names
+  ## Determine the first/last column names
   @eval $first_column = "-"@
   @eval $last_column = "-"@
   @foreach $c column@
diff --git a/local/mib2c.iterate_access.conf b/local/mib2c.iterate_access.conf
index a38ac20..4152d10 100644
--- a/local/mib2c.iterate_access.conf
+++ b/local/mib2c.iterate_access.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate_access.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -38,8 +38,8 @@ Netsnmp_Node_Handler ${i}_handler;
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.iterate_access.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.mfd.conf b/local/mib2c.mfd.conf
index d309ea5..809d36c 100644
--- a/local/mib2c.mfd.conf
+++ b/local/mib2c.mfd.conf
@@ -1,9 +1,8 @@
 #############################################################  -*- c -*-
 ## top level mfd conf file
-## $Id$
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** START code generated by $RCSfile$ $Revision$ */
+/** START code generated by mib2c */
 @end@
 ########################################################################
 ##
@@ -28,5 +27,5 @@
 @run mfd-top.m2c@
 ########################################################################
 @if $m2c_mark_boundary == 1@
-/** END code generated by $RCSfile$ $Revision$ */
+/** END code generated by mib2c */
 @end@
diff --git a/local/mib2c.notify.conf b/local/mib2c.notify.conf
index 77f3330..8c1b56c 100644
--- a/local/mib2c.notify.conf
+++ b/local/mib2c.notify.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.notify.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -21,8 +21,8 @@ int send_${i}_trap(void);
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.notify.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.old-api.conf b/local/mib2c.old-api.conf
index 8fa270b..c44418a 100644
--- a/local/mib2c.old-api.conf
+++ b/local/mib2c.old-api.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.old-api.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -35,8 +35,8 @@ FindVarMethod var_${i};
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.old-api.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.raw-table.conf b/local/mib2c.raw-table.conf
index bd88fdb..e152d2c 100644
--- a/local/mib2c.raw-table.conf
+++ b/local/mib2c.raw-table.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id: mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.raw-table.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -18,8 +18,8 @@ void init_$name(void);
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id: mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.raw-table.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.row.conf b/local/mib2c.row.conf
index f736baa..5453c10 100755
--- a/local/mib2c.row.conf
+++ b/local/mib2c.row.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.row.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -82,8 +82,8 @@ struct ${i}_entry {
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.row.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.scalar.conf b/local/mib2c.scalar.conf
index 3024fa4..41b6c19 100644
--- a/local/mib2c.scalar.conf
+++ b/local/mib2c.scalar.conf
@@ -4,8 +4,8 @@
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.scalar.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -22,8 +22,8 @@ Netsnmp_Node_Handler handle_${i};
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *        $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.scalar.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/mib2c.table_data.conf b/local/mib2c.table_data.conf
index 2cc665c..47639c8 100644
--- a/local/mib2c.table_data.conf
+++ b/local/mib2c.table_data.conf
@@ -32,8 +32,8 @@ Invalid value for 'cache' ($cache) - generating caching code
 ######################################################################
 @open ${name}.h@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.table_data.conf
  */
 #ifndef $name.uc_H
 #define $name.uc_H
@@ -62,8 +62,8 @@ NetsnmpCacheFree ${i}_free;
 ######################################################################
 @open ${name}.c@
 /*
- * Note: this file originally auto-generated by mib2c using
- *  $Id$
+ * Note: this file originally auto-generated by mib2c
+ * using mib2c.table_data.conf
  */
 
 #include <net-snmp/net-snmp-config.h>
diff --git a/local/pass_persisttest b/local/pass_persisttest
index f4045cc..47e58ac 100755
--- a/local/pass_persisttest
+++ b/local/pass_persisttest
@@ -62,6 +62,10 @@ while (<>){
          ($req eq  "$place.5"))       { $ret = "$place.5.0";}       # netSnmpPassCounter.0
   elsif (($req =~ m/$place\.5\..*/)  ||
          ($req eq  "$place.6"))       { $ret = "$place.6.0";}       # netSnmpPassGauge.0
+  elsif (($req =~ m/$place\.6\..*/)  ||
+         ($req eq  "$place.7"))       { $ret = "$place.7.0";}       # netSnmpPassCounter64.0
+  elsif (($req =~ m/$place\.7\..*/)  ||
+         ($req eq  "$place.8"))       { $ret = "$place.8.0";}       # netSnmpPassInteger64.0
   else   {
       print "NONE\n";
       next;
@@ -92,6 +96,10 @@ while (<>){
     print "counter\n$counter\n";
   } elsif ($ret eq "$place.6.0") {
     print "gauge\n42\n";
+  } elsif ($ret eq "$place.7.0") {
+    print "counter64\n9223372036854775806\n";
+  } elsif ($ret eq "$place.8.0") {
+    print "integer64\n9223372036854775807\n";
   } else {
     print  "string\nack... $ret $req\n";
   }
diff --git a/m4/pkg.m4 b/m4/pkg.m4
new file mode 100644
index 0000000..c5b26b5
--- /dev/null
+++ b/m4/pkg.m4
@@ -0,0 +1,214 @@
+# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
+# serial 1 (pkg-config-0.24)
+# 
+# Copyright Â© 2004 Scott James Remnant <scott@netsplit.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# PKG_PROG_PKG_CONFIG([MIN-VERSION])
+# ----------------------------------
+AC_DEFUN([PKG_PROG_PKG_CONFIG],
+[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
+m4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])
+m4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])
+AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])
+AC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])
+AC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=m4_default([$1], [0.9.0])
+	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		PKG_CONFIG=""
+	fi
+fi[]dnl
+])# PKG_PROG_PKG_CONFIG
+
+# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+#
+# Check to see whether a particular set of modules exists.  Similar
+# to PKG_CHECK_MODULES(), but does not set variables or print errors.
+#
+# Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+# only at the first occurence in configure.ac, so if the first place
+# it's called might be skipped (such as if it is within an "if", you
+# have to call PKG_CHECK_EXISTS manually
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_EXISTS],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+if test -n "$PKG_CONFIG" && \
+    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
+  m4_default([$2], [:])
+m4_ifvaln([$3], [else
+  $3])dnl
+fi])
+
+# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
+# ---------------------------------------------
+m4_define([_PKG_CONFIG],
+[if test -n "$$1"; then
+    pkg_cv_[]$1="$$1"
+ elif test -n "$PKG_CONFIG"; then
+    PKG_CHECK_EXISTS([$3],
+                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes ],
+		     [pkg_failed=yes])
+ else
+    pkg_failed=untried
+fi[]dnl
+])# _PKG_CONFIG
+
+# _PKG_SHORT_ERRORS_SUPPORTED
+# -----------------------------
+AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi[]dnl
+])# _PKG_SHORT_ERRORS_SUPPORTED
+
+
+# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+# [ACTION-IF-NOT-FOUND])
+#
+#
+# Note that if there is a possibility the first call to
+# PKG_CHECK_MODULES might not happen, you should be sure to include an
+# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
+#
+#
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_MODULES],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
+AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
+
+pkg_failed=no
+AC_MSG_CHECKING([for $1])
+
+_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
+_PKG_CONFIG([$1][_LIBS], [libs], [$2])
+
+m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
+and $1[]_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.])
+
+if test $pkg_failed = yes; then
+   	AC_MSG_RESULT([no])
+        _PKG_SHORT_ERRORS_SUPPORTED
+        if test $_pkg_short_errors_supported = yes; then
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "$2" 2>&1`
+        else 
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "$2" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
+
+	m4_default([$4], [AC_MSG_ERROR(
+[Package requirements ($2) were not met:
+
+$$1_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+_PKG_TEXT])[]dnl
+        ])
+elif test $pkg_failed = untried; then
+     	AC_MSG_RESULT([no])
+	m4_default([$4], [AC_MSG_FAILURE(
+[The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+_PKG_TEXT
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.])[]dnl
+        ])
+else
+	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
+	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
+        AC_MSG_RESULT([yes])
+	$3
+fi[]dnl
+])# PKG_CHECK_MODULES
+
+
+# PKG_INSTALLDIR(DIRECTORY)
+# -------------------------
+# Substitutes the variable pkgconfigdir as the location where a module
+# should install pkg-config .pc files. By default the directory is
+# $libdir/pkgconfig, but the default can be changed by passing
+# DIRECTORY. The user can override through the --with-pkgconfigdir
+# parameter.
+AC_DEFUN([PKG_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${libdir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([pkgconfigdir],
+    [AS_HELP_STRING([--with-pkgconfigdir], pkg_description)],,
+    [with_pkgconfigdir=]pkg_default)
+AC_SUBST([pkgconfigdir], [$with_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+]) dnl PKG_INSTALLDIR
+
+
+# PKG_NOARCH_INSTALLDIR(DIRECTORY)
+# -------------------------
+# Substitutes the variable noarch_pkgconfigdir as the location where a
+# module should install arch-independent pkg-config .pc files. By
+# default the directory is $datadir/pkgconfig, but the default can be
+# changed by passing DIRECTORY. The user can override through the
+# --with-noarch-pkgconfigdir parameter.
+AC_DEFUN([PKG_NOARCH_INSTALLDIR],
+[m4_pushdef([pkg_default], [m4_default([$1], ['${datadir}/pkgconfig'])])
+m4_pushdef([pkg_description],
+    [pkg-config arch-independent installation directory @<:@]pkg_default[@:>@])
+AC_ARG_WITH([noarch-pkgconfigdir],
+    [AS_HELP_STRING([--with-noarch-pkgconfigdir], pkg_description)],,
+    [with_noarch_pkgconfigdir=]pkg_default)
+AC_SUBST([noarch_pkgconfigdir], [$with_noarch_pkgconfigdir])
+m4_popdef([pkg_default])
+m4_popdef([pkg_description])
+]) dnl PKG_NOARCH_INSTALLDIR
+
+
+# PKG_CHECK_VAR(VARIABLE, MODULE, CONFIG-VARIABLE,
+# [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+# -------------------------------------------
+# Retrieves the value of the pkg-config variable for the given module.
+AC_DEFUN([PKG_CHECK_VAR],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1], [value of $3 for $2, overriding pkg-config])dnl
+
+_PKG_CONFIG([$1], [variable="][$3]["], [$2])
+AS_VAR_COPY([$1], [pkg_cv_][$1])
+
+AS_VAR_IF([$1], [""], [$5], [$4])dnl
+])# PKG_CHECK_VAR
diff --git a/man/mib2c.conf.5.in b/man/mib2c.conf.5.in
index 3692a65..8c6e065 100644
--- a/man/mib2c.conf.5.in
+++ b/man/mib2c.conf.5.in
@@ -1,6 +1,6 @@
 .TH MIB2C.CONF 5 "28 Apr 2004" VVERSIONINFO "Net-SNMP"
 .SH NAME
-mib2c.conf \[em] How to write mib2c.conf files to do ANYTHING based on MIB input.
+mib2c.conf \- How to write mib2c.conf files to do ANYTHING based on MIB input.
 .SH SYNOPSIS
 % cat > mib2c.test.conf  << EOF
 @foreach $t table@
diff --git a/man/netsnmp_config_api.3.def b/man/netsnmp_config_api.3.def
index d009fc5..90b20d9 100644
--- a/man/netsnmp_config_api.3.def
+++ b/man/netsnmp_config_api.3.def
@@ -365,7 +365,9 @@ function that it should abort the operation of the application.
 SNMPCONFPATH
 A colon separated list of directories to search for configuration
 files in.
-Default: SYSCONFDIR/snmp:DATADIR/snmp:LIBDIR/snmp:$HOME/.snmp
+Default:
+.br
+SYSCONFDIR/snmp:\:DATADIR/snmp:\:LIBDIR/snmp:\:$HOME/.snmp
 .SH "SEE ALSO"
 netsnmp_mib_api(3), snmp_api(3)
 .\" Local Variables:
diff --git a/man/netsnmp_mib_api.3.def b/man/netsnmp_mib_api.3.def
index 2e1da8f..4c297cd 100644
--- a/man/netsnmp_mib_api.3.def
+++ b/man/netsnmp_mib_api.3.def
@@ -277,7 +277,8 @@ A colon separated list of MIB modules to load.
 .br
 The default list of modules will depend on how the Net-SNMP software
 was originally compiled, but is typically:
-IP\-MIB:IF\-MIB:TCP\-MIB:UDP\-MIB:SNMPv2\-MIB:RFC1213\-MIB: UCD\-SNMP\-MIB:HOST\-RESOURCES\-MIB
+.br
+IP\-MIB:\:IF\-MIB:\:TCP\-MIB:\:UDP\-MIB:\:SNMPv2\-MIB:\:RFC1213\-MIB:\:UCD\-SNMP\-MIB:\:HOST\-RESOURCES\-MIB
 .IP
 If the value of the
 .B MIBS
diff --git a/man/snmpcmd.1.def b/man/snmpcmd.1.def
index e4df8b2..900fd72 100644
--- a/man/snmpcmd.1.def
+++ b/man/snmpcmd.1.def
@@ -50,7 +50,7 @@ In addition to the options described in this manual page, all of the
 tokens described in the \fIsnmp.conf\fR and other .conf manual pages
 can be used on the command line of Net-SNMP applications as well by
 prefixing them with "\-\-".  EG, specifying
-\fI\-\-dontLoadHostConfig=true\fR on the command line will turn of
+\fI\-\-dontLoadHostConfig=true\fR on the command line will turn off
 loading of the host specific configuration files.
 .PP
 The snmp.conf file settings and the double-dash arguments over-ride
@@ -705,6 +705,9 @@ messages can be controlled by passing various parameters to the
 .B \-L
 flag.
 .TP
+.B \-Ln
+Disable all logging.
+.TP
 .B \-Le
 Log messages to the standard error stream.
 .TP
@@ -726,9 +729,10 @@ priorities of message.  Using standard error logging as an example:
 .TP
 .B \-LE pri
 will log messages of priority 'pri' and above to standard error.
+See below for possible 'pri' values-
 .TP
-.B \-LE p1\-p2
-will log messages with priority between 'p1' and 'p2' (inclusive) to
+.B \-LE pri1\-pri2
+will log messages with priority between 'pri1' and 'pri2' (inclusive) to
 standard error.
 .PP
 For
@@ -736,6 +740,7 @@ For
 and
 .B \-LS
 the priority specification comes before the file or facility token.
+.PP
 The priorities recognised are:
 .IP
 .B 0
@@ -888,7 +893,9 @@ The standard prefix for object identifiers (when using UCD-style output).
 Defaults to .iso.org.dod.internet.mgmt.mib\-2
 .IP MIBS
 The list of MIBs to load. Defaults to
-SNMPv2\-TC:SNMPv2\-MIB:IF\-MIB:IP\-MIB:TCP\-MIB:UDP\-MIB:SNMP\-VACM\-MIB.
+.br
+SNMPv2\-TC:\:SNMPv2\-MIB:\:IF\-MIB:\:IP\-MIB:\:TCP\-MIB:\:UDP\-MIB:\:SNMP\-VACM\-MIB.
+.br
 Overridden by the
 .B \-m
 option.
diff --git a/man/snmpd.8.def b/man/snmpd.8.def
index f173396..2abaa3c 100644
--- a/man/snmpd.8.def
+++ b/man/snmpd.8.def
@@ -78,9 +78,9 @@ To get a list of compiled modules, run the agent with the arguments
 .I "\-Dmib_init \-H"
 (assuming debugging support has been compiled in).
 .TP
-.B \-L[efos]
+.B \-L[eEfFoOsSnN]
 Specify where logging output should be directed (standard error or output,
-to a file or via syslog).  See LOGGING OPTIONS in snmpcmd(5) for details.
+to a file or via syslog).  See LOGGING OPTIONS in snmpcmd(1) for details.
 .TP
 .BR \-m " \fIMIBLIST"
 Specifies a colon separated list of MIB modules to load for this
diff --git a/man/snmpd.conf.5.def b/man/snmpd.conf.5.def
index 2a8a3d3..d6c1282 100644
--- a/man/snmpd.conf.5.def
+++ b/man/snmpd.conf.5.def
@@ -78,7 +78,7 @@ this to unlimited is not considered safe if your user population can
 not be trusted.  A repeat number greater than this will be truncated
 to this value.
 .IP
-This is set by default to -1.
+This is set by default to \-1.
 .IP "maxGetbulkResponses NUM"
 Sets the maximum number of responses allowed for a getbulk request.
 This is set by default to 100.  Set to 0 to enable the default and set
@@ -87,11 +87,11 @@ time, setting this to unlimited is not considered safe if your user
 population can not be trusted.
 .IP
 In general, the total number of responses will not be allowed to
-exceed the maxGetbulkResponses number and the total number returned
+exceed the maxGetbulkResponses number, and the total number returned
 will be an integer multiple of the number of variables requested times
 the calculated number of repeats allow to fit below this number.
 .IP
-Also not that processing of maxGetbulkRepeats is handled first.
+Also note that processing of maxGetbulkRepeats is handled first.
 .SS SNMPv3 Configuration - Real Security
 SNMPv3 is added flexible security models to the SNMP packet structure
 so that multiple security solutions could be used.  SNMPv3 was
@@ -1284,7 +1284,7 @@ Attempting to define an unaccompanied \fIexecfix\fR directive will fail.
 .PP
 \fIexec\fR and \fIsh\fR extensions can only be configured via the
 snmpd.conf file.  They cannot be set up via SNMP SET requests.
-.IP "extend [MIBOID] NAME PROG ARGS"
+.IP "extend [-cacheTime TIME] [-execType TYPE] [MIBOID] NAME PROG ARGS"
 works in a similar manner to the \fIexec\fR directive, but with a number
 of improvements.  The MIB tables (\fInsExtendConfigTable\fR
 etc) are indexed by the NAME token, so are unaffected by the order in
@@ -1294,6 +1294,14 @@ containing the exit status, the first line and full output (as a single string)
 for each \fIextend\fR entry, and the other (\fInsExtendOutput2Table\fR)
 containing the complete output as a series of separate lines.
 .IP
+If -cacheTime is specified, then its argument is used as the cache timeout
+(in whole seconds) for this \fIextend\fR entry. This mechanism provides a
+non-volatile way to specify the cache timeout.
+.IP
+If -execType is specified and has a value of \fIsh\fR, then this \fIextend\fR
+entry will be run in a shell. Otherwise it will be run in the default \fIexec\fR
+fashion. This mechanism provides a non-volatile way to specify the exec type.
+.IP
 If MIBOID is specified, then the configuration and result tables will be rooted
 at this point in the OID tree, but are otherwise structured in exactly
 the same way. This means that several separate \fIextend\fR
@@ -1338,10 +1346,11 @@ respectively, where OID is the requested OID.
 The PROG command should return the response varbind as three separate
 lines printed to stdout - the first line should be the OID of the returned
 value, the second should be its TYPE (one of the text strings
-.B integer, gauge, counter, timeticks, ipaddress, objectid,
+.B integer, gauge, counter, timeticks, ipaddress, objectid, octet,
 or
 .B string
-), and the third should be the value itself.
+), and the third should be the value itself. (Note: octets are sent as
+ASCII, space-separated hex strings, e.g. "00 3f dd 00 c6 be".)
 .IP
 If the command cannot return an appropriate varbind - e.g the specified
 OID did not correspond to a valid instance for a GET request, or there
diff --git a/man/variables.5.def b/man/variables.5.def
index 14ee5e2..ccf8f77 100644
--- a/man/variables.5.def
+++ b/man/variables.5.def
@@ -84,7 +84,8 @@ A variant of this (typically used when writing OIDs in descriptive
 text, rather than running programs), is to combine the name and
 numeric subidentifier:
 .RS
- .iso(1).org(3).dod(6).internet(1).mgmt(2).mib-2(1).system(1).sysDescr(1)
+ .iso(1).org(3).dod(6).internet(1).mgmt(2).mib-2(1).system(1)
+ .sysDescr(1)
 .RE
 
 .SS Module-qualified OIDs
diff --git a/mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB.txt b/mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB.txt
index 7995fc4..6827af4 100644
--- a/mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB.txt
+++ b/mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB.txt
@@ -1,166 +1,170 @@
-  IANA-ADDRESS-FAMILY-NUMBERS-MIB DEFINITIONS ::= BEGIN
-
-  IMPORTS
-      MODULE-IDENTITY,
-      mib-2                               FROM SNMPv2-SMI
-      TEXTUAL-CONVENTION                  FROM SNMPv2-TC;
-
-  ianaAddressFamilyNumbers MODULE-IDENTITY
-      LAST-UPDATED "201309250000Z"  -- September 25, 2013
-      ORGANIZATION "IANA"
-      CONTACT-INFO
-          "Postal:    Internet Assigned Numbers Authority
-                      Internet Corporation for Assigned Names
-		      and Numbers
-                      12025 Waterfront Drive, Suite 300
-                      Los Angeles, CA 90094-2536
-                      USA
-
-          Tel:    +1  310-301-5800
-          E-Mail: iana&iana.org"
-      DESCRIPTION
-          "The MIB module defines the AddressFamilyNumbers
-          textual convention."
-
-      -- revision history
-
-      REVISION     "201309250000Z"  -- September 25, 2013
-      DESCRIPTION  "Fixed labels for 16389-16390."
-
-      REVISION     "201307160000Z"  -- July 16, 2013
-      DESCRIPTION  "Fixed labels for 16389-16390."
-
-      REVISION     "201306260000Z"  -- June 26, 2013
-      DESCRIPTION  "Added assignments 26-28."
-
-      REVISION     "201306180000Z"  -- June 18, 2013
-      DESCRIPTION  "Added assignments 16384-16390. Assignment 
-                    25 added in 2007 revision."
-
-      REVISION     "200203140000Z"  -- March 14, 2002
-      DESCRIPTION  "AddressFamilyNumbers assignment 22 to 
-                   fibreChannelWWPN. AddressFamilyNumbers 
-                   assignment 23 to fibreChannelWWNN.
-                   AddressFamilyNumers assignment 24 to gwid."
-
-      REVISION     "200009080000Z"  -- September 8, 2000
-      DESCRIPTION  "AddressFamilyNumbers assignment 19 to xtpOverIpv4.  
-                   AddressFamilyNumbers assignment 20 to xtpOverIpv6.  
-                   AddressFamilyNumbers assignment 21 to xtpNativeModeXTP."
-
-      REVISION     "200003010000Z"  -- March 1, 2000
-      DESCRIPTION  "AddressFamilyNumbers assignment 17 to distinguishedName. 
-                   AddressFamilyNumbers assignment 18 to asNumber."
-
-      REVISION     "200002040000Z"  -- February 4, 2000
-      DESCRIPTION  "AddressFamilyNumbers assignment 16 to dns."
-
-      REVISION     "9908260000Z"  -- August 26, 1999
-      DESCRIPTION  "Initial version, published as RFC 2677."
-      ::= { mib-2 72 }
-
-  AddressFamilyNumbers ::= TEXTUAL-CONVENTION
-      STATUS       current
-      DESCRIPTION
-          "The definition of this textual convention with the
-          addition of newly assigned values is published
-          periodically by the IANA, in either the Assigned
-          Numbers RFC, or some derivative of it specific to
-          Internet Network Management number assignments.
-          (The latest arrangements can be obtained by
-          contacting the IANA.)
-
-          The enumerations are described as:
-
-          other(0),    -- none of the following
-          ipV4(1),     -- IP Version 4
-          ipV6(2),     -- IP Version 6
-          nsap(3),     -- NSAP
-          hdlc(4),     -- (8-bit multidrop)
-          bbn1822(5),
-          all802(6),   -- (includes all 802 media
-                       --   plus Ethernet 'canonical format')
-          e163(7),
-          e164(8),     -- (SMDS, Frame Relay, ATM)
-          f69(9),      -- (Telex)
-          x121(10),    -- (X.25, Frame Relay)
-          ipx(11),     -- IPX (Internet Protocol Exchange)
-          appleTalk(12),  -- Apple Talk
-          decnetIV(13),   -- DEC Net Phase IV
-          banyanVines(14),  -- Banyan Vines
-          e164withNsap(15),
-                       -- (E.164 with NSAP format subaddress)
-          dns(16),     -- (Domain Name System)
-          distinguishedName(17), -- (Distinguished Name, per X.500)
-          asNumber(18), -- (16-bit quantity, per the AS number space)
-          xtpOverIpv4(19),  -- XTP over IP version 4
-          xtpOverIpv6(20),  -- XTP over IP version 6
-          xtpNativeModeXTP(21),  -- XTP native mode XTP
-          fibreChannelWWPN(22),  -- Fibre Channel World-Wide Port Name 
-          fibreChannelWWNN(23),  -- Fibre Channel World-Wide Node Name
-          gwid(24),    -- Gateway Identifier 
-          afi(25),  -- AFI for L2VPN information
-          mplsTpSectionEndpointIdentifier(26),  -- MPLS-TP Section Endpoint Identifier
-          mplsTpLspEndpointIdentifier(27),  -- MPLS-TP LSP Endpoint Identifier
-          mplsTpPseudowireEndpointIdentifier(28),  -- MPLS-TP Pseudowire Endpoint Identifier
-          eigrpCommonServiceFamily(16384),  -- EIGRP Common Service Family
-          eigrpIpv4ServiceFamily(16385),  -- EIGRP IPv4 Service Family
-          eigrpIpv6ServiceFamily(16386),  -- EIGRP IPv6 Service Family
-          lispCanonicalAddressFormat(16387),  -- LISP Canonical Address Format (LCAF)
-          bgpLs(16388),  -- BGP-LS
-          fortyeightBitMacBitMac(16389),  -- 48-bit MAC
-          sixtyfourBitMac(16390),  -- 64-bit MAC
-          oui(16391),  -- OUI
-          mac24(16392),  -- MAC/24
-          mac40(16393),  -- MAC/40
-          ipv664(16394),  -- IPv6/64
-          rBridgePortID(16395),  -- RBridge Port ID
-          reserved(65535)
-
-          Requests for new values should be made to IANA via
-          email (iana&iana.org)."
-      SYNTAX  INTEGER {
-                  other(0),
-                  ipV4(1),
-                  ipV6(2),
-                  nsap(3),
-                  hdlc(4),
-                  bbn1822(5),
-                  all802(6),
-                  e163(7),
-                  e164(8),
-                  f69(9),
-                  x121(10),
-                  ipx(11),
-                  appleTalk(12),
-                  decnetIV(13),
-                  banyanVines(14),
-                  e164withNsap(15),
-                  dns(16),
-                  distinguishedName(17), -- (Distinguished Name, per X.500)
-                  asNumber(18), -- (16-bit quantity, per the AS number space)
-                  xtpOverIpv4(19),
-                  xtpOverIpv6(20),
-                  xtpNativeModeXTP(21),
-                  fibreChannelWWPN(22),
-                  fibreChannelWWNN(23),
-                  gwid(24),
-                  afi(25),
-                  mplsTpSectionEndpointIdentifier(26),
-                  mplsTpLspEndpointIdentifier(27),
-                  mplsTpPseudowireEndpointIdentifier(28),
-                  eigrpCommonServiceFamily(16384),
-                  eigrpIpv4ServiceFamily(16385),
-                  eigrpIpv6ServiceFamily(16386),
-                  lispCanonicalAddressFormat(16387),
-                  bgpLs(16388),
-                  fortyeightBitMac(16389),
-                  sixtyfourBitMac(16390),
-                  oui(16391),
-                  mac24(16392),
-                  mac40(16393),
-                  ipv664(16394),
-                  rBridgePortID(16395),
-                  reserved(65535)
-              }
-      END
+IANA-ADDRESS-FAMILY-NUMBERS-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    MODULE-IDENTITY,
+    mib-2                               FROM SNMPv2-SMI
+    TEXTUAL-CONVENTION                  FROM SNMPv2-TC;
+
+ianaAddressFamilyNumbers MODULE-IDENTITY
+    LAST-UPDATED "201409020000Z"  -- September 2, 2014
+    ORGANIZATION "IANA"
+    CONTACT-INFO
+        "Postal:    Internet Assigned Numbers Authority
+                    Internet Corporation for Assigned Names and Numbers
+                    12025 Waterfront Drive, Suite 300
+                    Los Angeles, CA 90094-2536
+                    USA
+
+        Tel:    +1  310-301-5800
+        E-Mail: iana&iana.org"
+    DESCRIPTION
+        "The MIB module defines the AddressFamilyNumbers
+        textual convention."
+
+    -- revision history
+
+    REVISION     "201409020000Z"  -- September 2, 2014
+    DESCRIPTION  "Assigned value 16396."
+
+    REVISION     "201309250000Z"  -- September 25, 2013
+    DESCRIPTION  "Assigned values 16391-16395."
+
+    REVISION     "201307160000Z"  -- July 16, 2013
+    DESCRIPTION  "Fixed labels for 16389-16390."
+
+    REVISION     "201306260000Z"  -- June 26, 2013
+    DESCRIPTION  "Added assignments 26-28."
+
+    REVISION     "201306180000Z"  -- June 18, 2013
+    DESCRIPTION  "Added assignments 16384-16390. Assignment
+                  25 added in 2007 revision."
+
+    REVISION     "200203140000Z"  -- March 14, 2002
+    DESCRIPTION  "AddressFamilyNumbers assignment 22 to
+                 fibreChannelWWPN. AddressFamilyNumbers
+                 assignment 23 to fibreChannelWWNN.
+                 AddressFamilyNumers assignment 24 to gwid."
+
+    REVISION     "200009080000Z"  -- September 8, 2000
+    DESCRIPTION  "AddressFamilyNumbers assignment 19 to xtpOverIpv4.
+                 AddressFamilyNumbers assignment 20 to xtpOverIpv6.
+                 AddressFamilyNumbers assignment 21 to xtpNativeModeXTP."
+
+    REVISION     "200003010000Z"  -- March 1, 2000
+    DESCRIPTION  "AddressFamilyNumbers assignment 17 to distinguishedName.
+                 AddressFamilyNumbers assignment 18 to asNumber."
+
+    REVISION     "200002040000Z"  -- February 4, 2000
+    DESCRIPTION  "AddressFamilyNumbers assignment 16 to dns."
+
+    REVISION     "9908260000Z"  -- August 26, 1999
+    DESCRIPTION  "Initial version, published as RFC 2677."
+    ::= { mib-2 72 }
+
+AddressFamilyNumbers ::= TEXTUAL-CONVENTION
+    STATUS       current
+    DESCRIPTION
+        "The definition of this textual convention with the
+        addition of newly assigned values is published
+        periodically by the IANA, in either the Assigned
+        Numbers RFC, or some derivative of it specific to
+        Internet Network Management number assignments.
+        (The latest arrangements can be obtained by
+        contacting the IANA.)
+
+        The enumerations are described as:
+
+        other(0),    -- none of the following
+        ipV4(1),     -- IP Version 4
+        ipV6(2),     -- IP Version 6
+        nsap(3),     -- NSAP
+        hdlc(4),     -- (8-bit multidrop)
+        bbn1822(5),
+        all802(6),   -- (includes all 802 media
+                     --   plus Ethernet 'canonical format')
+        e163(7),
+        e164(8),     -- (SMDS, Frame Relay, ATM)
+        f69(9),      -- (Telex)
+        x121(10),    -- (X.25, Frame Relay)
+        ipx(11),     -- IPX (Internet Protocol Exchange)
+        appleTalk(12),  -- Apple Talk
+        decnetIV(13),   -- DEC Net Phase IV
+        banyanVines(14),  -- Banyan Vines
+        e164withNsap(15),
+                     -- (E.164 with NSAP format subaddress)
+        dns(16),     -- (Domain Name System)
+        distinguishedName(17), -- (Distinguished Name, per X.500)
+        asNumber(18), -- (16-bit quantity, per the AS number space)
+        xtpOverIpv4(19),  -- XTP over IP version 4
+        xtpOverIpv6(20),  -- XTP over IP version 6
+        xtpNativeModeXTP(21),  -- XTP native mode XTP
+        fibreChannelWWPN(22),  -- Fibre Channel World-Wide Port Name
+        fibreChannelWWNN(23),  -- Fibre Channel World-Wide Node Name
+        gwid(24),    -- Gateway Identifier
+        afi(25),  -- AFI for L2VPN information
+        mplsTpSectionEndpointIdentifier(26),  -- MPLS-TP Section Endpoint Identifier
+        mplsTpLspEndpointIdentifier(27),  -- MPLS-TP LSP Endpoint Identifier
+        mplsTpPseudowireEndpointIdentifier(28),  -- MPLS-TP Pseudowire Endpoint Identifier
+        eigrpCommonServiceFamily(16384),  -- EIGRP Common Service Family
+        eigrpIpv4ServiceFamily(16385),  -- EIGRP IPv4 Service Family
+        eigrpIpv6ServiceFamily(16386),  -- EIGRP IPv6 Service Family
+        lispCanonicalAddressFormat(16387),  -- LISP Canonical Address Format (LCAF)
+        bgpLs(16388),  -- BGP-LS
+        fortyeightBitMacBitMac(16389),  -- 48-bit MAC
+        sixtyfourBitMac(16390),  -- 64-bit MAC
+        oui(16391),  -- OUI
+        mac24(16392),  -- MAC/24
+        mac40(16393),  -- MAC/40
+        ipv664(16394),  -- IPv6/64
+        rBridgePortID(16395),  -- RBridge Port ID
+        trillNickname(16396),  -- TRILL Nickname
+        reserved(65535)
+
+        Requests for new values should be made to IANA via
+        email (iana&iana.org)."
+    SYNTAX  INTEGER {
+                other(0),
+                ipV4(1),
+                ipV6(2),
+                nsap(3),
+                hdlc(4),
+                bbn1822(5),
+                all802(6),
+                e163(7),
+                e164(8),
+                f69(9),
+                x121(10),
+                ipx(11),
+                appleTalk(12),
+                decnetIV(13),
+                banyanVines(14),
+                e164withNsap(15),
+                dns(16),
+                distinguishedName(17), -- (Distinguished Name, per X.500)
+                asNumber(18), -- (16-bit quantity, per the AS number space)
+                xtpOverIpv4(19),
+                xtpOverIpv6(20),
+                xtpNativeModeXTP(21),
+                fibreChannelWWPN(22),
+                fibreChannelWWNN(23),
+                gwid(24),
+                afi(25),
+                mplsTpSectionEndpointIdentifier(26),
+                mplsTpLspEndpointIdentifier(27),
+                mplsTpPseudowireEndpointIdentifier(28),
+                eigrpCommonServiceFamily(16384),
+                eigrpIpv4ServiceFamily(16385),
+                eigrpIpv6ServiceFamily(16386),
+                lispCanonicalAddressFormat(16387),
+                bgpLs(16388),
+                fortyeightBitMac(16389),
+                sixtyfourBitMac(16390),
+                oui(16391),
+                mac24(16392),
+                mac40(16393),
+                ipv664(16394),
+                rBridgePortID(16395),
+                trillNickname(16396),
+                reserved(65535)
+            }
+    END
diff --git a/mibs/IANA-LANGUAGE-MIB.txt b/mibs/IANA-LANGUAGE-MIB.txt
index 4b97bdd..28006b0 100644
--- a/mibs/IANA-LANGUAGE-MIB.txt
+++ b/mibs/IANA-LANGUAGE-MIB.txt
@@ -30,10 +30,10 @@ ianaLanguages MODULE-IDENTITY
 
          Note, this module does not have to register all possible
          languages since languages are identified by object
-         identifier values. It is therefore possible to registered 
+         identifier values. It is therefore possible to registered
          languages in private OID trees. The references given below are not
          normative with regard to the language version. Other
-         references might be better suited to describe some newer 
+         references might be better suited to describe some newer
          versions of this language. The references are only
          provided as `a pointer into the right direction'."
 
diff --git a/mibs/IANA-RTPROTO-MIB.txt b/mibs/IANA-RTPROTO-MIB.txt
index f7bc1eb..571ed2f 100644
--- a/mibs/IANA-RTPROTO-MIB.txt
+++ b/mibs/IANA-RTPROTO-MIB.txt
@@ -5,7 +5,7 @@ IMPORTS
     TEXTUAL-CONVENTION               FROM SNMPv2-TC;
 
 ianaRtProtoMIB  MODULE-IDENTITY
-    LAST-UPDATED "201208300000Z" -- August 30, 2012
+    LAST-UPDATED "201604250000Z" -- April 25, 2016
     ORGANIZATION "IANA"
     CONTACT-INFO
             " Internet Assigned Numbers Authority
@@ -24,17 +24,23 @@ ianaRtProtoMIB  MODULE-IDENTITY
             Any additions or changes to the contents of this MIB module
             require either publication of an RFC, or Designated Expert
             Review as defined in RFC 2434, Guidelines for Writing an
-            IANA Considerations Section in RFCs.  The Designated Expert 
+            IANA Considerations Section in RFCs.  The Designated Expert
             will be selected by the IESG Area Director(s) of the Routing
             Area."
 
-    REVISION     "201208300000Z"  -- August 30, 2012 
+    REVISION     "201604250000Z"  -- April 25, 2016
+    DESCRIPTION  "Corrected typographical error in revision date."
+
+    REVISION     "201604060000Z"  -- April 6, 2016
+    DESCRIPTION  "Added ttdp(20)."
+
+    REVISION     "201208300000Z"  -- August 30, 2012
     DESCRIPTION  "Added dhcp(19)."
 
-    REVISION     "201107220000Z"  -- July 22, 2011 
+    REVISION     "201107220000Z"  -- July 22, 2011
     DESCRIPTION  "Added rpl(18) ."
 
-    REVISION     "200009260000Z"  -- September 26, 2000 
+    REVISION     "200009260000Z"  -- September 26, 2000
     DESCRIPTION  "Original version, published in coordination
                  with RFC 2932."
     ::= { mib-2 84 }
@@ -68,7 +74,8 @@ IANAipRouteProtocol ::= TEXTUAL-CONVENTION
                 ciscoEigrp (16), -- Cisco EIGRP
                 dvmrp      (17), -- DVMRP
                 rpl        (18), -- RPL [RFC-ietf-roll-rpl-19]
-                dhcp       (19)  -- DHCP [RFC2132]
+                dhcp       (19), -- DHCP [RFC2132]
+                ttdp       (20)  -- Train Topology Discovery Protocol (TTDP) [IEC 61375-2-5]
                }
 
 IANAipMRouteProtocol ::= TEXTUAL-CONVENTION
diff --git a/mibs/IANAifType-MIB.txt b/mibs/IANAifType-MIB.txt
index 027a153..d03d08d 100644
--- a/mibs/IANAifType-MIB.txt
+++ b/mibs/IANAifType-MIB.txt
@@ -5,7 +5,7 @@
        TEXTUAL-CONVENTION          FROM SNMPv2-TC;
 
    ianaifType MODULE-IDENTITY
-       LAST-UPDATED "201407030000Z" -- July 3, 2014
+       LAST-UPDATED "201606160000Z" -- June 16, 2016
        ORGANIZATION "IANA"
        CONTACT-INFO "        Internet Assigned Numbers Authority
 
@@ -19,8 +19,32 @@
                      Convention, and thus the enumerated values of
                      the ifType object defined in MIB-II's ifTable."
 
+       REVISION     "201606160000Z"  -- June 16, 2016
+       DESCRIPTION  "Updated IANAtunnelType DESCRIPTION per RFC 7870"
+
+       REVISION     "201606090000Z"  -- June 9, 2016
+       DESCRIPTION  "Registration of new IANAifType 282."
+
+       REVISION     "201606080000Z"  -- June 8, 2016
+       DESCRIPTION  "Updated description for tunnelType 17."
+
+       REVISION     "201605190000Z"  -- May 19, 2016
+       DESCRIPTION  "Updated description for tunnelType 16."
+
+       REVISION     "201605030000Z"  -- May 3, 2016
+       DESCRIPTION  "Registration of new IANAifType 281."
+
+       REVISION     "201604290000Z"  -- April 29, 2016
+       DESCRIPTION  "Registration of new tunnelTypes 16 and 17."
+
+       REVISION     "201409240000Z"  -- September 24, 2014
+       DESCRIPTION  "Registration of new IANAifType 280."
+
+       REVISION     "201409190000Z"  -- September 19, 2014
+       DESCRIPTION  "Registration of new IANAifType 279."
+
        REVISION     "201407030000Z"  -- July 3, 2014
-	   DESCRIPTION  "Registration of new IANAifTypes 277-278."
+       DESCRIPTION  "Registration of new IANAifTypes 277-278."
 
        REVISION     "201405220000Z" -- May 22, 2014
        DESCRIPTION  "Updated contact info."
@@ -89,23 +113,23 @@
        DESCRIPTION  "Registration of new IANAifType 242."
 
        REVISION     "200701230000Z"  -- January 23, 2007
-       DESCRIPTION  "Registration of new IANAifTypes 239, 240, and 241." 
+       DESCRIPTION  "Registration of new IANAifTypes 239, 240, and 241."
 
        REVISION     "200610170000Z"  -- October 17, 2006
-       DESCRIPTION  "Deprecated/Obsoleted IANAifType 230.  Registration of 
-                     IANAifType 238." 
+       DESCRIPTION  "Deprecated/Obsoleted IANAifType 230.  Registration of
+                     IANAifType 238."
 
        REVISION     "200609250000Z"  -- September 25, 2006
-       DESCRIPTION  "Changed the description for IANA ifType 
-                     184 and added new IANA ifType 237."  
+       DESCRIPTION  "Changed the description for IANA ifType
+                     184 and added new IANA ifType 237."
 
        REVISION     "200608170000Z"  -- August 17, 2006
        DESCRIPTION  "Changed the descriptions for IANAifTypes
-                     20 and 21."   
+                     20 and 21."
 
        REVISION     "200608110000Z"  -- August 11, 2006
        DESCRIPTION  "Changed the descriptions for IANAifTypes
-                     7, 11, 62, 69, and 117."   
+                     7, 11, 62, 69, and 117."
 
        REVISION     "200607250000Z"  -- July 25, 2006
        DESCRIPTION  "Registration of new IANA ifType 236."
@@ -133,7 +157,7 @@
 
        REVISION     "200503030000Z"  -- March 3, 2005
        DESCRIPTION  "Added the IANAtunnelType TC and deprecated
-	                 IANAifType sixToFour (215) per RFC4087."
+                         IANAifType sixToFour (215) per RFC4087."
 
        REVISION     "200411220000Z"  -- November 22, 2004
        DESCRIPTION  "Registration of new IANA ifType 227 per RFC4631."
@@ -142,8 +166,8 @@
        DESCRIPTION  "Registration of new IANA ifType 226."
 
        REVISION     "200405120000Z"  -- May 12, 2004
-       DESCRIPTION  "Added description for IANAifType 6, and 
-	                 changed the descriptions for IANAifTypes
+       DESCRIPTION  "Added description for IANAifType 6, and
+                         changed the descriptions for IANAifTypes
                      180, 181, and 182."
 
        REVISION     "200405070000Z"  -- May 7, 2004
@@ -236,17 +260,17 @@
 
        REVISION     "200010170000Z"  -- Oct 17, 2000
        DESCRIPTION  "Registration of new IANAifTypes
-                     188 and 189."  
+                     188 and 189."
 
        REVISION     "200010020000Z"  -- Oct 02, 2000
-       DESCRIPTION  "Registration of new IANAifType 187." 
+       DESCRIPTION  "Registration of new IANAifType 187."
 
        REVISION     "200009010000Z"  -- Sept 01, 2000
        DESCRIPTION  "Registration of new IANAifTypes
-                     184, 185, and 186."			
+                     184, 185, and 186."
 
        REVISION     "200008240000Z"  -- Aug 24, 2000
-       DESCRIPTION  "Registration of new IANAifType 183." 
+       DESCRIPTION  "Registration of new IANAifType 183."
 
        REVISION     "200008230000Z"  -- Aug 23, 2000
        DESCRIPTION  "Registration of new IANAifTypes
@@ -257,7 +281,7 @@
                      171, 172 and 173."
 
        REVISION     "200004250000Z"  -- Apr 25, 2000
-       DESCRIPTION  "Registration of new IANAifTypes 168 and 169."       
+       DESCRIPTION  "Registration of new IANAifTypes 168 and 169."
 
        REVISION     "200003060000Z"  -- Mar 6, 2000
        DESCRIPTION  "Fixed a missing semi-colon in the IMPORT.
@@ -334,21 +358,21 @@
                    propPointToPointSerial(22), -- proprietary serial
                    ppp(23),
                    softwareLoopback(24),
-                   eon(25),            -- CLNP over IP 
+                   eon(25),            -- CLNP over IP
                    ethernet3Mbit(26),
                    nsip(27),           -- XNS over IP
                    slip(28),           -- generic SLIP
                    ultra(29),          -- ULTRA technologies
                    ds3(30),            -- DS3-MIB
                    sip(31),            -- SMDS, coffee
-                   frameRelay(32),     -- DTE only. 
+                   frameRelay(32),     -- DTE only.
                    rs232(33),
                    para(34),           -- parallel-port
                    arcnet(35),         -- arcnet
                    arcnetPlus(36),     -- arcnet plus
                    atm(37),            -- ATM cells
                    miox25(38),
-                   sonet(39),          -- SONET or SDH 
+                   sonet(39),          -- SONET or SDH
                    x25ple(40),
                    iso88022llc(41),
                    localTalk(42),
@@ -366,25 +390,25 @@
                    propMultiplexor(54),-- proprietary multiplexing
                    ieee80212(55),      -- 100BaseVG
                    fibreChannel(56),   -- Fibre Channel
-                   hippiInterface(57), -- HIPPI interfaces     
+                   hippiInterface(57), -- HIPPI interfaces
                    frameRelayInterconnect(58), -- Obsolete, use either
-                                       -- frameRelay(32) or 
+                                       -- frameRelay(32) or
                                        -- frameRelayService(44).
                    aflane8023(59),     -- ATM Emulated LAN for 802.3
                    aflane8025(60),     -- ATM Emulated LAN for 802.5
-                   cctEmul(61),        -- ATM Emulated circuit          
+                   cctEmul(61),        -- ATM Emulated circuit
                    fastEther(62),      -- Obsoleted via RFC3635
                                        -- ethernetCsmacd (6) should be used instead
-                   isdn(63),           -- ISDN and X.25           
-                   v11(64),            -- CCITT V.11/X.21             
-                   v36(65),            -- CCITT V.36                  
+                   isdn(63),           -- ISDN and X.25
+                   v11(64),            -- CCITT V.11/X.21
+                   v36(65),            -- CCITT V.36
                    g703at64k(66),      -- CCITT G703 at 64Kbps
                    g703at2mb(67),      -- Obsolete see DS1-MIB
-                   qllc(68),           -- SNA QLLC                    
+                   qllc(68),           -- SNA QLLC
                    fastEtherFX(69),    -- Obsoleted via RFC3635
                                        -- ethernetCsmacd (6) should be used instead
-                   channel(70),        -- channel                     
-                   ieee80211(71),      -- radio spread spectrum       
+                   channel(70),        -- channel
+                   ieee80211(71),      -- radio spread spectrum
                    ibm370parChan(72),  -- IBM System 360/370 OEMI Channel
                    escon(73),          -- IBM Enterprise Systems Connection
                    dlsw(74),           -- Data Link Switching
@@ -420,7 +444,7 @@
                    voiceOverIp(104),   -- voice over IP encapsulation
                    atmDxi(105),        -- ATM DXI
                    atmFuni(106),       -- ATM FUNI
-                   atmIma (107),       -- ATM IMA		   
+                   atmIma (107),       -- ATM IMA
                    pppMultilinkBundle(108), -- PPP Multilink Bundle
                    ipOverCdlc (109),   -- IBM ipOverCdlc
                    ipOverClaw (110),   -- IBM Common Link Access to Workstn
@@ -429,18 +453,18 @@
                    mpc (113),          -- IBM multi-protocol channel support
                    ipOverAtm (114),    -- IBM ipOverAtm
                    iso88025Fiber (115), -- ISO 802.5j Fiber Token Ring
-                   tdlc (116),	       -- IBM twinaxial data link control
+                   tdlc (116),         -- IBM twinaxial data link control
                    gigabitEthernet (117), -- Obsoleted via RFC3635
                                           -- ethernetCsmacd (6) should be used instead
                    hdlc (118),         -- HDLC
-                   lapf (119),	       -- LAP F
-                   v37 (120),	       -- V.37
+                   lapf (119),         -- LAP F
+                   v37 (120),          -- V.37
                    x25mlp (121),       -- Multi-Link Protocol
                    x25huntGroup (122), -- X25 Hunt Group
                    transpHdlc (123),   -- Transp HDLC
                    interleave (124),   -- Interleave channel
                    fast (125),         -- Fast channel
-                   ip (126),	       -- IP (for APPN HPR in IP networks)
+                   ip (126),           -- IP (for APPN HPR in IP networks)
                    docsCableMaclayer (127),  -- CATV Mac Layer
                    docsCableDownstream (128), -- CATV Downstream interface
                    docsCableUpstream (129),  -- CATV Upstream interface
@@ -452,42 +476,42 @@
                    l2vlan (135),       -- Layer 2 Virtual LAN using 802.1Q
                    l3ipvlan (136),     -- Layer 3 Virtual LAN using IP
                    l3ipxvlan (137),    -- Layer 3 Virtual LAN using IPX
-                   digitalPowerline (138), -- IP over Power Lines	
+                   digitalPowerline (138), -- IP over Power Lines
                    mediaMailOverIp (139), -- Multimedia Mail over IP
                    dtm (140),        -- Dynamic syncronous Transfer Mode
                    dcn (141),    -- Data Communications Network
                    ipForward (142),    -- IP Forwarding Interface
                    msdsl (143),       -- Multi-rate Symmetric DSL
                    ieee1394 (144), -- IEEE1394 High Performance Serial Bus
-                   if-gsn (145),       --   HIPPI-6400 
+                   if-gsn (145),       --   HIPPI-6400
                    dvbRccMacLayer (146), -- DVB-RCC MAC Layer
                    dvbRccDownstream (147),  -- DVB-RCC Downstream Channel
                    dvbRccUpstream (148),  -- DVB-RCC Upstream Channel
                    atmVirtual (149),   -- ATM Virtual Interface
                    mplsTunnel (150),   -- MPLS Tunnel Virtual Interface
-                   srp (151),	-- Spatial Reuse Protocol	
+                   srp (151),   -- Spatial Reuse Protocol
                    voiceOverAtm (152),  -- Voice Over ATM
-                   voiceOverFrameRelay (153),   -- Voice Over Frame Relay 
-                   idsl (154),		-- Digital Subscriber Loop over ISDN
+                   voiceOverFrameRelay (153),   -- Voice Over Frame Relay
+                   idsl (154),          -- Digital Subscriber Loop over ISDN
                    compositeLink (155),  -- Avici Composite Link Interface
-                   ss7SigLink (156),     -- SS7 Signaling Link 
+                   ss7SigLink (156),     -- SS7 Signaling Link
                    propWirelessP2P (157),  --  Prop. P2P wireless interface
                    frForward (158),    -- Frame Forward Interface
-                   rfc1483 (159),	-- Multiprotocol over ATM AAL5
-                   usb (160),		-- USB Interface
+                   rfc1483 (159),       -- Multiprotocol over ATM AAL5
+                   usb (160),           -- USB Interface
                    ieee8023adLag (161),  -- IEEE 802.3ad Link Aggregate
                    bgppolicyaccounting (162), -- BGP Policy Accounting
-                   frf16MfrBundle (163), -- FRF .16 Multilink Frame Relay 
+                   frf16MfrBundle (163), -- FRF .16 Multilink Frame Relay
                    h323Gatekeeper (164), -- H323 Gatekeeper
                    h323Proxy (165), -- H323 Voice and Video Proxy
-                   mpls (166), -- MPLS                   
+                   mpls (166), -- MPLS
                    mfSigLink (167), -- Multi-frequency signaling link
                    hdsl2 (168), -- High Bit-Rate DSL - 2nd generation
                    shdsl (169), -- Multirate HDSL2
                    ds1FDL (170), -- Facility Data Link 4Kbps on a DS1
                    pos (171), -- Packet over SONET/SDH Interface
                    dvbAsiIn (172), -- DVB-ASI Input
-                   dvbAsiOut (173), -- DVB-ASI Output 
+                   dvbAsiOut (173), -- DVB-ASI Output
                    plc (174), -- Power Line Communtications
                    nfas (175), -- Non Facility Associated Signaling
                    tr008 (176), -- TR008
@@ -506,7 +530,7 @@
                    digitalWrapperOverheadChannel (186), -- Digital Wrapper
                    aal2 (187), -- ATM adaptation layer 2
                    radioMAC (188), -- MAC layer over radio links
-                   atmRadio (189), -- ATM over radio links   
+                   atmRadio (189), -- ATM over radio links
                    imt (190), -- Inter Machine Trunks
                    mvl (191), -- Multiple Virtual Lines DSL
                    reachDSL (192), -- Long Reach DSL
@@ -514,20 +538,20 @@
                    atmVciEndPt (194), -- ATM VCI End Point
                    opticalChannel (195), -- Optical Channel
                    opticalTransport (196), -- Optical Transport
-                   propAtm (197), --  Proprietary ATM       
+                   propAtm (197), --  Proprietary ATM
                    voiceOverCable (198), -- Voice Over Cable Interface
                    infiniband (199), -- Infiniband
                    teLink (200), -- TE Link
                    q2931 (201), -- Q.2931
                    virtualTg (202), -- Virtual Trunk Group
                    sipTg (203), -- SIP Trunk Group
-                   sipSig (204), -- SIP Signaling   
+                   sipSig (204), -- SIP Signaling
                    docsCableUpstreamChannel (205), -- CATV Upstream Channel
                    econet (206), -- Acorn Econet
                    pon155 (207), -- FSAN 155Mb Symetrical PON interface
                    pon622 (208), -- FSAN622Mb Symetrical PON interface
                    bridge (209), -- Transparent bridge interface
-                   linegroup (210), -- Interface common to multiple lines   
+                   linegroup (210), -- Interface common to multiple lines
                    voiceEMFGD (211), -- voice E&M Feature Group D
                    voiceFGDEANA (212), -- voice FGD Exchange Access North American
                    voiceDID (213), -- voice Direct Inward Dialing
@@ -540,16 +564,16 @@
                    homepna (220), -- HomePNA ITU-T G.989
                    gfp (221), -- Generic Framing Procedure (GFP)
                    ciscoISLvlan (222), -- Layer 2 Virtual LAN using Cisco ISL
-                   actelisMetaLOOP (223), -- Acteleis proprietary MetaLOOP High Speed Link 
-                   fcipLink (224), -- FCIP Link 
+                   actelisMetaLOOP (223), -- Acteleis proprietary MetaLOOP High Speed Link
+                   fcipLink (224), -- FCIP Link
                    rpr (225), -- Resilient Packet Ring Interface Type
                    qam (226), -- RF Qam Interface
                    lmp (227), -- Link Management Protocol
                    cblVectaStar (228), -- Cambridge Broadband Networks Limited VectaStar
                    docsCableMCmtsDownstream (229), -- CATV Modular CMTS Downstream Interface
-                   adsl2 (230), -- Asymmetric Digital Subscriber Loop Version 2 
+                   adsl2 (230), -- Asymmetric Digital Subscriber Loop Version 2
                                 -- (DEPRECATED/OBSOLETED - please use adsl2plus 238 instead)
-                   macSecControlledIF (231), -- MACSecControlled 
+                   macSecControlledIF (231), -- MACSecControlled
                    macSecUncontrolledIF (232), -- MACSecUncontrolled
                    aviciOpticalEther (233), -- Avici Optical Ethernet Aggregate
                    atmbond (234), -- atmbond
@@ -557,7 +581,7 @@
                    mocaVersion1 (236), -- MultiMedia over Coax Alliance (MoCA) Interface
                              -- as documented in information provided privately to IANA
                    ieee80216WMAN (237), -- IEEE 802.16 WMAN interface
-                   adsl2plus (238), -- Asymmetric Digital Subscriber Loop Version 2, 
+                   adsl2plus (238), -- Asymmetric Digital Subscriber Loop Version 2,
                                    -- Version 2 Plus and all variants
                    dvbRcsMacLayer (239), -- DVB-RCS MAC Layer
                    dvbTdm (240), -- DVB Satellite TDM
@@ -594,7 +618,11 @@
                    aluGponPhysicalUni (271), -- GPON physical User to Network interface
                    vmwareNicTeam (272), -- VMware NIC Team
                    docsOfdmDownstream (277), -- CATV Downstream OFDM interface
-                   docsOfdmaUpstream (278) -- CATV Upstream OFDMA interface
+                   docsOfdmaUpstream (278), -- CATV Upstream OFDMA interface
+                   gfast (279), -- G.fast port
+                   sdci (280), -- SDCI (IO-Link)
+                   xboxWireless (281), -- Xbox wireless
+                   fastdsl (282) -- FastDSL
                    }
 
 IANAtunnelType ::= TEXTUAL-CONVENTION
@@ -622,25 +650,36 @@ IANAtunnelType ::= TEXTUAL-CONVENTION
             header of the protocol of that name is inserted
             between the outer header and the payload header.
 
+            The IP Tunnel MIB [RFC4087] is designed to manage
+            tunnels of any type over IPv4 and IPv6 networks;
+            therefore, it already supports IP-in-IP tunnels.
+            But in a DS-Lite scenario, the tunnel type is
+            point-to-multipoint IP-in-IP tunnels.  The direct(2)
+            defined in the IP Tunnel MIB only supports point-to-point
+            tunnels.  So, it needs to define a new tunnel type for
+            DS-Lite.
+
             The assignment policy for IANAtunnelType values is
             identical to the policy for assigning IANAifType
             values."
     SYNTAX     INTEGER {
-                   other(1),        -- none of the following
-                   direct(2),       -- no intermediate header
-                   gre(3),          -- GRE encapsulation
-                   minimal(4),      -- Minimal encapsulation
-                   l2tp(5),         -- L2TP encapsulation
-                   pptp(6),         -- PPTP encapsulation
-                   l2f(7),          -- L2F encapsulation
-                   udp(8),          -- UDP encapsulation
-                   atmp(9),         -- ATMP encapsulation
-                   msdp(10),        -- MSDP encapsulation
-                   sixToFour(11),   -- 6to4 encapsulation
-                   sixOverFour(12), -- 6over4 encapsulation
-                   isatap(13),      -- ISATAP encapsulation
-                   teredo(14),      -- Teredo encapsulation
-                   ipHttps(15)      -- IPHTTPS
+                   other(1),         -- none of the following
+                   direct(2),        -- no intermediate header
+                   gre(3),           -- GRE encapsulation
+                   minimal(4),       -- Minimal encapsulation
+                   l2tp(5),          -- L2TP encapsulation
+                   pptp(6),          -- PPTP encapsulation
+                   l2f(7),           -- L2F encapsulation
+                   udp(8),           -- UDP encapsulation
+                   atmp(9),          -- ATMP encapsulation
+                   msdp(10),         -- MSDP encapsulation
+                   sixToFour(11),    -- 6to4 encapsulation
+                   sixOverFour(12),  -- 6over4 encapsulation
+                   isatap(13),       -- ISATAP encapsulation
+                   teredo(14),       -- Teredo encapsulation
+                   ipHttps(15),      -- IPHTTPS
+                   softwireMesh(16), -- softwire mesh tunnel
+                   dsLite(17)        -- DS-Lite tunnel
                }
 
    END
diff --git a/mibs/NET-SNMP-PASS-MIB.txt b/mibs/NET-SNMP-PASS-MIB.txt
index 93c1a10..2f2c516 100644
--- a/mibs/NET-SNMP-PASS-MIB.txt
+++ b/mibs/NET-SNMP-PASS-MIB.txt
@@ -68,6 +68,20 @@ netSnmpPassGauge OBJECT-TYPE
     DEFVAL { 42 }
     ::= { netSnmpPassExamples 6 }
 
+netSnmpPassCounter64 OBJECT-TYPE
+    SYNTAX      Counter64
+    MAX-ACCESS  read-only
+    STATUS      current
+    DESCRIPTION "Example Counter64 object."
+    ::= { netSnmpPassExamples 7 }
+
+netSnmpPassInteger64 OBJECT-TYPE
+    SYNTAX      Opaque
+    MAX-ACCESS  read-only
+    STATUS      current
+    DESCRIPTION "Example Opaque Integer64 object."
+    ::= { netSnmpPassExamples 8 }
+
 
 netSnmpPassOIDValue OBJECT IDENTIFIER
     ::= { netSnmpPassExamples 99 }
diff --git a/mibs/UCD-DISKIO-MIB.txt b/mibs/UCD-DISKIO-MIB.txt
index ba9e4db..ffbf676 100644
--- a/mibs/UCD-DISKIO-MIB.txt
+++ b/mibs/UCD-DISKIO-MIB.txt
@@ -17,7 +17,7 @@ IMPORTS
         FROM UCD-SNMP-MIB;
 
 ucdDiskIOMIB MODULE-IDENTITY
-    LAST-UPDATED "200504200000Z"
+    LAST-UPDATED "201604040000Z"
     ORGANIZATION "University of California, Davis"
     CONTACT-INFO    
 	"This mib is no longer being maintained by the University of
@@ -35,6 +35,10 @@ ucdDiskIOMIB MODULE-IDENTITY
     DESCRIPTION
         "This MIB module defines objects for disk IO statistics."
 
+    REVISION     "201604040000Z"
+    DESCRIPTION
+        "Add 64-bit counter for busy micro-seconds."
+
     REVISION     "200504200000Z"
     DESCRIPTION
         "Add 64 bit counters. Patch from Dan Nelson."
@@ -77,7 +81,8 @@ DiskIOEntry ::= SEQUENCE {
     diskIOLA5           Integer32,
     diskIOLA15          Integer32,
     diskIONReadX        Counter64,
-    diskIONWrittenX     Counter64
+    diskIONWrittenX     Counter64,
+    diskIOBusyTime      Counter64
 }
 
 diskIOIndex OBJECT-TYPE
@@ -168,4 +173,13 @@ diskIONWrittenX OBJECT-TYPE
         "The number of bytes written to this device since boot."
     ::= { diskIOEntry 13 }
 
+
+diskIOBusyTime OBJECT-TYPE
+    SYNTAX      Counter64
+    MAX-ACCESS  read-only
+    STATUS      current
+    DESCRIPTION
+        "The number of usecs the drive has been busy since boot."
+    ::= { diskIOEntry 14 }
+
 END
diff --git a/mibs/UCD-SNMP-MIB.txt b/mibs/UCD-SNMP-MIB.txt
index e8acc8c..cde67fe 100644
--- a/mibs/UCD-SNMP-MIB.txt
+++ b/mibs/UCD-SNMP-MIB.txt
@@ -33,11 +33,14 @@ IMPORTS
     Integer32, Opaque, enterprises, Counter32, Unsigned32
         FROM SNMPv2-SMI
 
+    CounterBasedGauge64
+        FROM HCNUM-TC
+
     TEXTUAL-CONVENTION, DisplayString, TruthValue
 	FROM SNMPv2-TC;
 
 ucdavis MODULE-IDENTITY
-    LAST-UPDATED "201407310000Z"
+    LAST-UPDATED "201606100000Z"
     ORGANIZATION "University of California, Davis"
     CONTACT-INFO    
 	"This mib is no longer being maintained by the University of
@@ -55,6 +58,10 @@ ucdavis MODULE-IDENTITY
     DESCRIPTION
 	"This file defines the private UCD SNMP MIB extensions."
 
+    REVISION     "201606100000Z"
+    DESCRIPTION
+	"New 64-bit memory objects"
+
     REVISION     "201407310000Z"
     DESCRIPTION
 	"New object for number of CPUs as counted by the agent"
@@ -632,6 +639,113 @@ memUsedRealTXT OBJECT-TYPE
          pages from other uses of physical memory."
     ::= { memory 17 }
 
+memTotalSwapX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"The total amount of swap space configured for this host."
+    ::= { memory 18 }
+
+memAvailSwapX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"The amount of swap space currently unused or available."
+    ::= { memory 19 }
+
+memTotalRealX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"The total amount of real/physical memory installed
+         on this host."
+    ::= { memory 20 }
+
+memAvailRealX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"The amount of real/physical memory currently unused
+         or available."
+    ::= { memory 21 }
+
+
+memTotalFreeX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+        "The total amount of memory free or available for use on
+         this host.  This value typically covers both real memory
+         and swap space or virtual memory."
+    ::= { memory 22 }
+
+memMinimumSwapX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"The minimum amount of swap space expected to be kept
+         free or available during normal operation of this host.
+
+         If this value (as reported by 'memAvailSwap(4)') falls
+         below the specified level, then 'memSwapError(100)' will
+         be set to 1 and an error message made available via
+         'memSwapErrorMsg(101)'."
+    ::= { memory 23 }
+
+memSharedX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+        "The total amount of real or virtual memory currently
+         allocated for use as shared memory.
+
+         This object will not be implemented on hosts where the
+         underlying operating system does not explicitly identify
+         memory as specifically reserved for this purpose."
+    ::= { memory 24 }
+
+memBufferX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+        "The total amount of real or virtual memory currently
+         allocated for use as memory buffers.
+
+         This object will not be implemented on hosts where the
+         underlying operating system does not explicitly identify
+         memory as specifically reserved for this purpose."
+    ::= { memory 25 }
+
+memCachedX OBJECT-TYPE
+    SYNTAX	CounterBasedGauge64
+    UNITS       "kB"
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+        "The total amount of real or virtual memory currently
+         allocated for use as cached memory.
+
+         This object will not be implemented on hosts where the
+         underlying operating system does not explicitly identify
+         memory as specifically reserved for this purpose."
+    ::= { memory 26 }
+
 memSwapError OBJECT-TYPE
     SYNTAX	UCDErrorFlag
     MAX-ACCESS	read-only
diff --git a/mibs/ianalist b/mibs/ianalist
index 8b31ad6..9947e7b 100644
--- a/mibs/ianalist
+++ b/mibs/ianalist
@@ -1,7 +1,8 @@
-# updated 2014-08-14
+# updated 2015-10-26
 ianaaddressfamilynumbers-mib	IANA-ADDRESS-FAMILY-NUMBERS-MIB
 ianabfdtcstd-mib		IANA-BFD-TC-STD-MIB
 ianacharset-mib			IANA-CHARSET-MIB
+ianaenergyrelation-mib		IANA-ENERGY-RELATION-MIB
 ianaentity-mib			IANA-ENTITY-MIB
 ianafinisher-mib		IANA-FINISHER-MIB
 ianagmplstc-mib			IANA-GMPLS-TC-MIB
@@ -13,5 +14,8 @@ ianalanguage-mib		IANA-LANGUAGE-MIB
 ianamalloc-mib			IANA-MALLOC-MIB
 ianamau-mib			IANA-MAU-MIB
 ianaolsrv2linkmetrictype-mib	IANA-OLSRv2-LINK-METRIC-TYPE-MIB
+ianapowerstateset-mib		IANAPowerStateSet-MIB
 ianaprinter-mib			IANA-PRINTER-MIB
+ianasmf-mib			IANA-SMF-MIB
 ianatn3270etc-mib		IANATn3270eTC-MIB
+ianastoragemediatype-mib	IANA-STORAGE-MEDIA-TYPE-MIB
diff --git a/mibs/rfclist b/mibs/rfclist
index e0d3eef..f3d55e1 100644
--- a/mibs/rfclist
+++ b/mibs/rfclist
@@ -1,4 +1,4 @@
-# updated 2014-08-15
+# updated 2016-08-01
 1155	RFC1155-SMI
 1213	RFC1213-MIB
 1227	SMUX-MIB
@@ -157,7 +157,6 @@
 3878	ARC-MIB
 3970	TE-MIB
 4001	INET-ADDRESS-MIB
-4008	NAT-MIB
 4011	POLICY-BASED-MANAGEMENT-MIB
 4022	TCP-MIB
 4036	DOCS-IETF-SUBMGT-MIB
@@ -266,7 +265,6 @@
 6766	G9983-MIB
 6767	G9982-MIB
 6768	G9981-MIB
-6779	NHDP-MIB
 6825	TED-MIB
 6850	RBRIDGE-MIB
 6933	ENTITY-MIB:UUID-TC-MIB
@@ -277,3 +275,17 @@
 7257	VPLS-GENERIC-MIB:VPLS-LDP-MIB:VPLS-BGP-MIB
 7330	BFD-TC-STD-MIB
 7331	BFD-STD-MIB
+7367	SMF-MIB
+7388	LOWPAN-MIB
+7420	PCE-PCEP-MIB
+7453	MPLS-TC-EXT-STD-MIB:MPLS-ID-STD-MIB:MPLS-LSR-EXT-STD-MIB:MPLS-TE-EXT-STD-MIB
+7460	ENERGY-OBJECT-MIB:POWER-ATTRIBUTES-MIB
+7461	ENERGY-OBJECT-CONTEXT-MIB
+7577	BATTERY-MIB
+7658	NAT-MIB
+7659	NATV2-MIB
+7666	VM-MIB
+7784	TRILL-OAM-MIB
+7856	SOFTWIRE-MESH-MIB
+7870	DSLite-MIB
+7939	NHDP-MIB
diff --git a/mibs/smistrip b/mibs/smistrip
index b5fc8f2..33d0bc8 100755
--- a/mibs/smistrip
+++ b/mibs/smistrip
@@ -47,7 +47,7 @@ do_usage () {
 
 
 do_strip () {
-    cat $1 | $AWK -v test="$test" -v dir="$dir" -v single="$single" -v suffix="$suffix" -v verbose="$verbose" '
+    expand $1 | sed 's/[ \r]*$//' | $AWK -v test="$test" -v dir="$dir" -v single="$single" -v suffix="$suffix" -v verbose="$verbose" '
 
     BEGIN {
 	if (length(single) != 0) {
diff --git a/net-snmp-create-v3-user.in b/net-snmp-create-v3-user.in
index 5288f3b..2f44efa 100644
--- a/net-snmp-create-v3-user.in
+++ b/net-snmp-create-v3-user.in
@@ -158,6 +158,8 @@ if test ! -d $outfile ; then
     touch $outfile
 fi
 echo $line >> $outfile
+prefix="@prefix@"
+datarootdir="@datarootdir@"
 outfile="@datadir@/snmp/snmpd.conf"
 line="$token $user"
 echo "adding the following line to $outfile:"
diff --git a/perl/ASN/Makefile.PL b/perl/ASN/Makefile.PL
index 4576781..6032aa3 100644
--- a/perl/ASN/Makefile.PL
+++ b/perl/ASN/Makefile.PL
@@ -1,4 +1,6 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
@@ -7,9 +9,7 @@ my $lib_version;
 # See lib/ExtUtils/MakeMaker.pm for details of how to influence
 # the contents of the Makefile that is written.
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 Check_Version();
 
@@ -87,6 +87,7 @@ sub InitMakeParams {
 	$Params{'CCFLAGS'} = "-I../../include " . $Params{'CCFLAGS'};
       }
       $Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+      $Params{'CCFLAGS'} .= ' -Wformat';
       if ($Params{'LIBS'} eq "" || $Params{'CCFLAGS'} eq "") {
 	die "You need to install net-snmp first (I can't find net-snmp-config)";
       }
@@ -100,12 +101,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -126,12 +127,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -140,7 +144,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -159,8 +163,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -208,7 +212,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -222,7 +226,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/Makefile.PL b/perl/Makefile.PL
index 31fdc40..0595613 100644
--- a/perl/Makefile.PL
+++ b/perl/Makefile.PL
@@ -1,11 +1,11 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 use Config;
 use Getopt::Long;
 require 5;
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 sub InitMakeParams {
     $nsconfig="net-snmp-config"; # in path by default
@@ -27,12 +27,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -53,12 +53,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -67,7 +70,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -86,8 +89,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -135,7 +138,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -149,7 +152,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/Makefile.makefiles b/perl/Makefile.makefiles
index 073815b..ec33c94 100644
--- a/perl/Makefile.makefiles
+++ b/perl/Makefile.makefiles
@@ -1,12 +1,4 @@
-GENERATE_LIST=./Makefile.PL \
-	      ./default_store/Makefile.PL \
-	      ./ASN/Makefile.PL \
-	      ./OID/Makefile.PL \
-	      ./agent/Makefile.PL \
-	      ./agent/default_store/Makefile.PL \
-	      ./agent/Support/Makefile.PL \
-	      ./SNMP/Makefile.PL \
-	      ./TrapReceiver/Makefile.PL
+GENERATE_LIST=$(shell find -name 'Makefile.PL' | xargs grep -lw NetSNMPGetOpts)
 
 all:
 	perl make-perl-makefiles $(GENERATE_LIST)
diff --git a/perl/Makefile.subs.pl b/perl/Makefile.subs.pl
index e3c25ef..44369e6 100644
--- a/perl/Makefile.subs.pl
+++ b/perl/Makefile.subs.pl
@@ -3,12 +3,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -29,12 +29,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -43,7 +46,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -62,8 +65,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -111,7 +114,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -125,7 +128,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/OID/Makefile.PL b/perl/OID/Makefile.PL
index 6bb1616..39d037d 100644
--- a/perl/OID/Makefile.PL
+++ b/perl/OID/Makefile.PL
@@ -1,16 +1,15 @@
 # See lib/ExtUtils/MakeMaker.pm for details of how to influence
 # the contents of the Makefile that is written.
 
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
 my $lib_version;
-my %MakeParams = ();
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 Check_Version();
 
@@ -87,6 +86,7 @@ sub InitMakeParams {
 #	    $Params{'PREREQ_PM'} = {'SNMP' => '5.0'};
 	}
 	$Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+        $Params{'CCFLAGS'} .= ' -Wformat';
 	if ($Params{'LIBS'} eq "" || $Params{'CCFLAGS'} eq "") {
 	    die "You need to install net-snmp first (I can't find net-snmp-config)";
 	}
@@ -101,12 +101,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -127,12 +127,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -141,7 +144,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -160,8 +163,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -209,7 +212,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -223,7 +226,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/SNMP/Makefile.PL b/perl/SNMP/Makefile.PL
index e617cb7..05d51ee 100644
--- a/perl/SNMP/Makefile.PL
+++ b/perl/SNMP/Makefile.PL
@@ -1,17 +1,16 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
 my $lib_version;
-my %MakeParams = ();
 my $opts;
 
 # See lib/ExtUtils/MakeMaker.pm for details of how to influence
 # the contents of the Makefile that is written.
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 Check_Version();
 
@@ -99,6 +98,7 @@ sub InitMakeParams {
 #	    $Params{'PREREQ_PM'} = { 'NetSNMP::default_store' => 0.01 };
 	}
 	$Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+        $Params{'CCFLAGS'} .= ' -Wformat';
 	if (!$ENV{'NETSNMP_PREFIX'}) {
 	    $prefix            = `$opts->{'nsconfig'} --prefix`;
 	    chomp($prefix);
@@ -230,12 +230,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -256,12 +256,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -270,7 +273,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -289,8 +292,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -338,7 +341,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -352,7 +355,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/SNMP/SNMP.xs b/perl/SNMP/SNMP.xs
index 2a734e8..6f47d23 100644
--- a/perl/SNMP/SNMP.xs
+++ b/perl/SNMP/SNMP.xs
@@ -1831,7 +1831,7 @@ _bulkwalk_send_pdu(walk_context *context)
       DBPRT(2,(DBOUT "bulkwalk_send_pdu(): snmp_async_send => 0x%08X\n", reqid));
 
       if (reqid == 0) {
-	 snmp_return_err(ss, *err_num_svp, *err_ind_svp, *err_str_svp);
+	 snmp_return_err(ss, *err_str_svp, *err_num_svp, *err_ind_svp);
 	 goto err;
       }
 
@@ -2175,8 +2175,8 @@ _bulkwalk_recv_pdu(walk_context *context, netsnmp_pdu *pdu)
       __get_type_str(type, type_str);
       av_store(varbind, VARBIND_TYPE_F, newSVpv(type_str, strlen(type_str)));
 
-      len=__snprint_value(str_buf, sizeof(str_buf),
-                         vars, tp, type, context->sprintval_f);
+      len = __snprint_value(str_buf, sizeof(str_buf) - 1,
+                            vars, tp, type, context->sprintval_f);
       av_store(varbind, VARBIND_VAL_F, newSVpv(str_buf, len));
 
       str_buf[len] = '\0';
@@ -3173,7 +3173,7 @@ snmp_set(sess_ref, varlist_ref, perl_callback)
                     XPUSHs(sv_2mortal(newSViv(status))); /* push the reqid?? */
                  } else {
                     snmp_free_pdu(pdu);
-					snmp_return_err(ss, *err_str_svp, *err_num_svp, *err_ind_svp);
+                    snmp_return_err(ss, *err_str_svp, *err_num_svp, *err_ind_svp);
                     XPUSHs(&sv_undef);
                  }
 		 goto done;
@@ -3363,7 +3363,7 @@ snmp_get(sess_ref, retry_nosuch, varlist_ref, perl_callback)
                     XPUSHs(sv_2mortal(newSViv(status))); /* push the reqid?? */
                  } else {
                     snmp_free_pdu(pdu);
-	  	    snmp_return_err(ss, *err_num_svp, *err_ind_svp, *err_str_svp);  
+		    snmp_return_err(ss, *err_str_svp, *err_num_svp, *err_ind_svp);
                     XPUSHs(&sv_undef);
                  }
 		 goto done;
@@ -3604,7 +3604,7 @@ snmp_getnext(sess_ref, varlist_ref, perl_callback)
                     XPUSHs(sv_2mortal(newSViv(status))); /* push the reqid?? */
                  } else {
                     snmp_free_pdu(pdu);
-					snmp_return_err(ss, *err_num_svp, *err_ind_svp, *err_str_svp);
+                    snmp_return_err(ss, *err_str_svp, *err_num_svp, *err_ind_svp);
                     XPUSHs(&sv_undef);
                  }
 		 goto done;
@@ -3846,7 +3846,7 @@ snmp_getbulk(sess_ref, nonrepeaters, maxrepetitions, varlist_ref, perl_callback)
                     XPUSHs(sv_2mortal(newSViv(status))); /* push the reqid?? */
                  } else {
                     snmp_free_pdu(pdu);
-					snmp_return_err(ss, *err_num_svp, *err_ind_svp, *err_str_svp);
+                    snmp_return_err(ss, *err_str_svp, *err_num_svp, *err_ind_svp);
                     XPUSHs(&sv_undef);
                  }
 		 goto done;
@@ -4707,7 +4707,7 @@ snmp_inform(sess_ref,uptime,trap_oid,varlist_ref,perl_callback)
                     XPUSHs(sv_2mortal(newSViv(status))); /* push the reqid?? */
                  } else {
                     snmp_free_pdu(pdu);
-					snmp_return_err(ss, *err_num_svp, *err_ind_svp, *err_str_svp);
+                    snmp_return_err(ss, *err_str_svp, *err_num_svp, *err_ind_svp);
                     XPUSHs(&sv_undef);
                  }
 		 goto done;
@@ -4774,7 +4774,7 @@ snmp_map_enum(tag, val, iflag, best_guess)
 	{
 	   struct tree *tp  = NULL;
            struct enum_list *ep;
-           char str_buf[STR_BUF_SIZE];
+           static char str_buf[STR_BUF_SIZE];
            int ival;
 
            RETVAL = NULL;
@@ -4817,7 +4817,7 @@ snmp_translate_obj(var,mode,use_long,auto_init,best_guess,include_module_name)
 	int		include_module_name
 	CODE:
 	{
-           char str_buf[STR_BUF_SIZE];
+           static char str_buf[STR_BUF_SIZE];
            char str_buf_temp[STR_BUF_SIZE];
            oid oid_arr[MAX_OID_LEN];
            size_t oid_arr_len = MAX_OID_LEN;
@@ -4885,9 +4885,9 @@ snmp_translate_obj(var,mode,use_long,auto_init,best_guess,include_module_name)
 	       if (verbose) warn("snmp_translate_obj:unknown translation mode: %d\n", mode);
            }
            if (*str_buf) {
-              RETVAL = (char*)str_buf;
+              RETVAL = str_buf;
            } else {
-              RETVAL = (char*)NULL;
+              RETVAL = NULL;
            }
            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT, old_format);
 	}
diff --git a/perl/SNMP/examples/bulkwalk.pl b/perl/SNMP/examples/bulkwalk.pl
index 3ee2412..bb83199 100644
--- a/perl/SNMP/examples/bulkwalk.pl
+++ b/perl/SNMP/examples/bulkwalk.pl
@@ -29,12 +29,12 @@ die "Cannot create session: ${SNMP::ErrorStr}\n" unless defined $sess;
 #
 #   The 'get' performed for non-repeaters is a "GETNEXT" (the non-repeater
 #   requests are not fulfilled with SNMP GET's).  This means that you must
-#   ask for the lexicographically preceeding variable for non-repeaters.
+#   ask for the lexicographically preceding variable for non-repeaters.
 #
 #   For most branches (i.e. 'sysUpTime'), this "just works" -- be sure you
 #   don't ask for an instance, and the response will be as expected.  However,
 #   if you want a specific variable instance (i.e. 'ifSpeed.5'), you must 
-#   ask for the _preceeding_ variable ('ifSpeed.4' in this example).
+#   ask for the _preceding_ variable ('ifSpeed.4' in this example).
 #
 #   See section 4.2.3 of RFC 1905 for more details on GETBULK PDU handling.
 #
diff --git a/perl/TrapReceiver/Makefile.PL b/perl/TrapReceiver/Makefile.PL
index 874ee21..9df0755 100644
--- a/perl/TrapReceiver/Makefile.PL
+++ b/perl/TrapReceiver/Makefile.PL
@@ -1,13 +1,12 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
 my $lib_version;
-my %MakeParams = ();
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 Check_Version();
 
@@ -125,6 +124,7 @@ sub InitMakeParams {
         }
 
 	$Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+        $Params{'CCFLAGS'} .= ' -Wformat';
 	if ($Params{'CCFLAGS'} eq "") {
 	    die "You need to install net-snmp first (I can't find net-snmp-config)";
 	}
@@ -140,12 +140,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -166,12 +166,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -180,7 +183,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -199,8 +202,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -248,7 +251,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -262,7 +265,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/agent/Makefile.PL b/perl/agent/Makefile.PL
index 4f7bee3..2c21225 100644
--- a/perl/agent/Makefile.PL
+++ b/perl/agent/Makefile.PL
@@ -1,13 +1,12 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
 my $lib_version;
-my %MakeParams = ();
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 Check_Version();
 
@@ -93,6 +92,7 @@ sub InitMakeParams {
 #	    $Params{'PREREQ_PM'} = {'NetSNMP::OID' => '0.1'};
 	}
 	$Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+        $Params{'CCFLAGS'} .= ' -Wformat';
 	if ($Params{'LIBS'} eq "" || $Params{'CCFLAGS'} eq "") {
 	    die "You need to install net-snmp first (I can't find net-snmp-config)";
 	}
@@ -107,12 +107,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -133,12 +133,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -147,7 +150,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -166,8 +169,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -215,7 +218,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -229,7 +232,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/agent/Support/Makefile.PL b/perl/agent/Support/Makefile.PL
index 48815b6..af4912f 100644
--- a/perl/agent/Support/Makefile.PL
+++ b/perl/agent/Support/Makefile.PL
@@ -1,16 +1,15 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
 my $lib_version;
-my %MakeParams = ();
 
 # See lib/ExtUtils/MakeMaker.pm for details of how to influence
 # the contents of the Makefile that is written.
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 Check_Version();
 
@@ -87,6 +86,7 @@ sub InitMakeParams {
 	$Params{'CCFLAGS'} = "-I../../include " . $Params{'CCFLAGS'};
       }
       $Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+      $Params{'CCFLAGS'} .= ' -Wformat';
       if ($Params{'LIBS'} eq "" || $Params{'CCFLAGS'} eq "") {
 	die "You need to install net-snmp first (I can't find net-snmp-config)";
       }
@@ -100,12 +100,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -126,12 +126,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -140,7 +143,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -159,8 +162,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -195,6 +198,10 @@ sub Check_Version {
 	    chomp($srcver);
 	    my $srcfloat = floatize_version($srcver);
 	    $perlver =~ s/pre/0./;
+	    # we allow for perl/CPAN-only revisions beyond the default
+	    # version formatting of net-snmp itself.
+	    $perlver =~ s/(\.\d{5}).*/\1/;
+	    $perlver =~ s/0*$//;
 	    if ($srcfloat ne $perlver) {
 		if (!$foundversion) {
 		    print STDERR "ERROR:
@@ -204,7 +211,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -218,7 +225,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/agent/default_store/Makefile.PL b/perl/agent/default_store/Makefile.PL
index ed6483a..bf3a245 100644
--- a/perl/agent/default_store/Makefile.PL
+++ b/perl/agent/default_store/Makefile.PL
@@ -1,13 +1,12 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
 my $lib_version;
-my %MakeParams = ();
 
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
+WriteMakefile(InitMakeParams());
 
 Check_Version();
 
@@ -80,6 +79,7 @@ sub InitMakeParams {
 	    $Params{'CCFLAGS'} = "-I../../../include " . $Params{'CCFLAGS'};
 	}
 	$Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+        $Params{'CCFLAGS'} .= ' -Wformat';
 	if ($Params{'LIBS'} eq "" || $Params{'CCFLAGS'} eq "") {
 	    die "You need to install net-snmp first (I can't find net-snmp-config)";
 	}
@@ -95,12 +95,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -121,12 +121,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -135,7 +138,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -154,8 +157,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -203,7 +206,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -217,7 +220,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/default_store/Makefile.PL b/perl/default_store/Makefile.PL
index 7c671b8..167beee 100644
--- a/perl/default_store/Makefile.PL
+++ b/perl/default_store/Makefile.PL
@@ -1,14 +1,12 @@
+use Cwd 'abs_path';
 use ExtUtils::MakeMaker;
+use File::Basename;
 require 5;
 use Config;
 use Getopt::Long;
 my $lib_version;
-my %MakeParams = ();
-
-%MakeParams = InitMakeParams();
-
-WriteMakefile(%MakeParams);
 
+WriteMakefile(InitMakeParams());
 
 sub InitMakeParams {
     my $opts;
@@ -80,6 +78,7 @@ sub InitMakeParams {
 	    $Params{'CCFLAGS'} = "-I../../include " . $Params{'CCFLAGS'};
 	}
 	$Params{'CCFLAGS'} =~ s/ -W(all|inline|strict-prototypes|write-strings|cast-qual|no-char-subscripts)//g; # ignore developer warnings
+        $Params{'CCFLAGS'} .= ' -Wformat';
 	if ($Params{'LIBS'} eq "" || $Params{'CCFLAGS'} eq "") {
 	    die "You need to install net-snmp first (I can't find net-snmp-config)";
 	}
@@ -94,12 +93,12 @@ sub NetSNMPGetOpts {
     my $rootpath = shift;
     $rootpath = "../" if (!$rootpath);
     $rootpath .= '/' if ($rootpath !~ /\/$/);
-    
+
     if (($Config{'osname'} eq 'MSWin32' && $ENV{'OSTYPE'} eq '')) {
 
       # Grab command line options first.  Only used if environment variables are not set
       GetOptions("NET-SNMP-IN-SOURCE=s" => \$ret{'insource'},
-        "NET-SNMP-PATH=s"      => \$ret{'prefix'},          
+        "NET-SNMP-PATH=s"      => \$ret{'prefix'},
         "NET-SNMP-DEBUG=s"     => \$ret{'debug'});
 
       if ($ENV{'NET-SNMP-IN-SOURCE'})
@@ -120,12 +119,15 @@ sub NetSNMPGetOpts {
       # Update environment variables in case they are needed
       $ENV{'NET-SNMP-IN-SOURCE'}    = $ret{'insource'};
       $ENV{'NET-SNMP-PATH'}         = $ret{'prefix'};
-      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};        
-     
-      $basedir = `%COMSPEC% /c cd`;
-      chomp $basedir;
-      $basedir =~ /(.*?)\\perl.*/;
-      $basedir = $1;
+      $ENV{'NET-SNMP-DEBUG'}        = $ret{'debug'};
+
+      $basedir = abs_path($0);
+      while (1) {
+          my $basename = basename($basedir);
+          last if (length($basename) <= 2);
+          $basedir = dirname($basedir);
+          last if ($basename eq "perl");
+      }
       print "Net-SNMP base directory: $basedir\n";
       if ($basedir =~ / /) {
         die "\nA space has been detected in the base directory.  This is not " .
@@ -134,7 +136,7 @@ sub NetSNMPGetOpts {
     }
     else
     {
-      if ($ENV{'NET-SNMP-CONFIG'} && 
+      if ($ENV{'NET-SNMP-CONFIG'} &&
         $ENV{'NET-SNMP-IN-SOURCE'}) {
 	# have env vars, pull from there
 	$ret{'nsconfig'} = $ENV{'NET-SNMP-CONFIG'};
@@ -153,8 +155,8 @@ sub NetSNMPGetOpts {
 	$ENV{'NET-SNMP-CONFIG'}    = $ret{'nsconfig'};
 	$ENV{'NET-SNMP-IN-SOURCE'} = $ret{'insource'};
       }
-    }	
-    
+    }
+
     $ret{'nsconfig'} =~ s/ROOTPATH/$rootpath/;
 
     $ret{'rootpath'} = $rootpath;
@@ -202,7 +204,7 @@ Perl Module Version:        $perlver
 These versions must match for perfect support of the module.  It is possible
 that different versions may work together, but it is strongly recommended
 that you make these two versions identical.  You can get the Net-SNMP
-source code and the associated perl modules directly from 
+source code and the associated perl modules directly from
 
    http://www.net-snmp.org/
 
@@ -216,7 +218,7 @@ environmental variable to 1 and re-run the Makefile.PL script.\n";
 	}
     }
     close(I);
-    die "ERROR: Couldn't find version number of this module\n" 
+    die "ERROR: Couldn't find version number of this module\n"
       if (!$foundversion);
   }
 }
diff --git a/perl/make-perl-makefiles b/perl/make-perl-makefiles
old mode 100644
new mode 100755
index 8a96487..fdf6a1f
--- a/perl/make-perl-makefiles
+++ b/perl/make-perl-makefiles
@@ -1,8 +1,15 @@
 #!/usr/bin/perl
 
+use strict;
+use warnings;
+use Cwd 'abs_path';
+use File::Basename;
+use File::Spec;
 
-open(I, "Makefile.subs.pl");
-@stuff = <I>;
+my $perldir = dirname(abs_path($0));
+
+open(my $I, File::Spec->catfile($perldir, "Makefile.subs.pl"));
+my @stuff = <$I>;
 
 foreach my $i (@ARGV) {
     print "updating $i\n";
diff --git a/python/netsnmp/client_intf.c b/python/netsnmp/client_intf.c
index 8b8805d..fd18e88 100644
--- a/python/netsnmp/client_intf.c
+++ b/python/netsnmp/client_intf.c
@@ -833,7 +833,7 @@ OCT:
                 ret = FAILURE;
                 addr = 0;
             }
-            vars->val.integer = netsnmp_memdup(&addr, sizeof(addr));
+            vars->val.integer = netsnmp_memdup((u_char **)&addr, sizeof(addr));
             vars->val_len = sizeof(addr);
         }
         break;
@@ -1585,7 +1585,7 @@ netsnmp_get(PyObject *self, PyObject *args)
 
 	py_netsnmp_attr_set_string(varbind, "type", type_str, strlen(type_str));
 
-	len = __snprint_value((char *) str_buf, sizeof(str_buf),
+	len = __snprint_value((char *) str_buf, sizeof(str_buf) - 1,
                               vars, tp, type, sprintval_flag);
 	str_buf[len] = '\0';
 	py_netsnmp_attr_set_string(varbind, "val", (char *) str_buf, len);
@@ -1804,7 +1804,7 @@ netsnmp_getnext(PyObject *self, PyObject *args)
 	py_netsnmp_attr_set_string(varbind, "type", type_str, 
 				   strlen(type_str));
 
-	len = __snprint_value((char *) str_buf, sizeof(str_buf),
+	len = __snprint_value((char *) str_buf, sizeof(str_buf) - 1,
                               vars, tp, type, sprintval_flag);
 	str_buf[len] = '\0';
 
@@ -2134,7 +2134,7 @@ netsnmp_walk(PyObject *self, PyObject *args)
                   py_netsnmp_attr_set_string(varbind, "type", type_str,
                                              strlen(type_str));
 
-                  len = __snprint_value((char *) str_buf,sizeof(str_buf),
+                  len = __snprint_value((char *) str_buf,sizeof(str_buf) - 1,
                                         vars,tp,type,sprintval_flag);
                   str_buf[len] = '\0';
 
@@ -2389,7 +2389,7 @@ netsnmp_getbulk(PyObject *self, PyObject *args)
 	    py_netsnmp_attr_set_string(varbind, "type", type_str, 
 				       strlen(type_str));
 
-	    len = __snprint_value((char *) str_buf, sizeof(str_buf),
+	    len = __snprint_value((char *) str_buf, sizeof(str_buf) - 1,
 				  vars, tp, type, sprintval_flag);
 	    str_buf[len] = '\0';
 
diff --git a/snmplib/Makefile.in b/snmplib/Makefile.in
index 506b8d4..e48c1d2 100644
--- a/snmplib/Makefile.in
+++ b/snmplib/Makefile.in
@@ -31,71 +31,72 @@ mysubdir=snmplib
 
 # headers
 INSTALLHEADERS=\
-	net-snmp-includes.h \
 	config_api.h  \
+	definitions.h \
 	mib_api.h     \
+	net-snmp-includes.h \
 	output_api.h  \
 	pdu_api.h     \
 	session_api.h \
 	snmpv3_api.h  \
-	varbind_api.h \
 	types.h       \
 	utilities.h   \
-	version.h     \
-	definitions.h
+	varbind_api.h \
+	version.h
 
 INCLUDESUBDIR=library
 INCLUDESUBDIRHEADERS=README \
 	asn1.h \
 	callback.h \
 	cert_util.h \
+	check_varbind.h \
 	container.h \
 	container_binary_array.h \
-	container_list_ssll.h \
 	container_iterator.h \
+	container_list_ssll.h \
 	container_null.h \
-	factory.h \
 	data_list.h \
 	default_store.h \
 	dir_utils.h \
+	factory.h \
 	fd_event_manager.h \
 	file_utils.h \
+	getopt.h \
 	int64.h \
 	keytools.h \
-	mib.h \
+	large_fd_set.h \
+	lcd_time.h \
 	md5.h \
+	mib.h \
+	mt_support.h \
+	netsnmp-attribute-format.h \
+	oid.h \
+	oid_stash.h \
 	parse.h \
 	read_config.h \
 	scapi.h \
+	snmp-tc.h \
 	snmp.h \
 	snmp_alarm.h \
 	snmp_api.h \
-	large_fd_set.h \
 	snmp_assert.h \
 	snmp_client.h \
 	snmp_debug.h \
+	snmp_enum.h \
 	snmp_impl.h \
 	snmp_logging.h \
 	snmp_parse_args.h \
+	snmp_secmod.h \
 	snmp_service.h \
-	snmp-tc.h \
+	snmp_transport.h \
 	snmpv3.h \
 	system.h \
 	text_utils.h \
 	tools.h \
 	transform_oids.h \
 	types.h \
-        getopt.h \
-        lcd_time.h \
-        mt_support.h \
-        oid.h \
-        oid_stash.h \
-        snmp_enum.h \
-        snmp_secmod.h \
-        ucd_compat.h \
-        vacm.h \
-	check_varbind.h \
-	snmp_transport.h \
+	ucd_compat.h \
+	vacm.h \
 	winpipe.h \
 	winservice.h \
 	@transport_hdr_list@ \
@@ -105,28 +106,29 @@ INSTALLBUILTSUBDIRHEADERS=../include/net-snmp/library/snmpv3-security-includes.h
 INSTALLBUILTSUBDIR=library
 
 
-INSTALLUCDHEADERS= asn1.h \
+INSTALLUCDHEADERS=\
+	asn1.h          \
 	callback.h	\
 	default_store.h	\
 	int64.h		\
 	keytools.h	\
+	large_fd_set.h	\
 	mib.h		\
 	parse.h		\
 	read_config.h	\
 	scapi.h		\
+	snmp-tc.h	\
+	snmp.h		\
 	snmp_alarm.h	\
 	snmp_api.h	\
-	large_fd_set.h	\
 	snmp_client.h	\
 	snmp_debug.h	\
-	snmp.h		\
 	snmp_impl.h	\
 	snmp_logging.h	\
 	snmp_parse_args.h \
-	snmp-tc.h	\
+	snmp_vars.h	\
 	snmpusm.h	\
 	snmpv3.h	\
-	snmp_vars.h	\
 	struct.h	\
 	system.h	\
 	tools.h		\
diff --git a/snmplib/asn1.c b/snmplib/asn1.c
index bea8d0b..666985f 100644
--- a/snmplib/asn1.c
+++ b/snmplib/asn1.c
@@ -6,6 +6,14 @@
  *
  * Encodes abstract data types into a machine independent stream of bytes.
  *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 /**********************************************************************
 	Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University
@@ -288,13 +296,88 @@ _asn_length_err(const char *str, size_t wrongsize, size_t rightsize)
 
 /**
  * @internal
+ * output an error for a wrong length
+ *
+ * @param str        error string
+ * @param wrongsize  wrong  length
+ * @param rightsize  expected length
+ */
+static
+    void
+_asn_short_err(const char *str, size_t wrongsize, size_t rightsize)
+{
+    char            ebuf[128];
+
+    snprintf(ebuf, sizeof(ebuf),
+            "%s length %lu too short: need %lu", str,
+	    (unsigned long)wrongsize, (unsigned long)rightsize);
+    ebuf[ sizeof(ebuf)-1 ] = 0;
+    ERROR_MSG(ebuf);
+}
+
+/**
+ * @internal
+ * checks a buffer with a length + data to see if it is big enough for
+ *    the length encoding and the data of the parsed length.
+ *
+ * @param IN  pkt      The buffer
+ * @param IN  pkt_len  The length of the bugger
+ * @param OUT data_len Pointer to size of data
+ *
+ * @return Pointer to start of data or NULL if pkt isn't long enough
+ *
+ * pkt = get_buf(..., &pkt_len);
+ * data = asn_parse_nlength(pkt, pkt_len, &data_len);
+ * if (NULL == data) { handle_error(); }
+ *
+ */
+u_char *
+asn_parse_nlength(u_char *pkt, size_t pkt_len, u_long *data_len)
+{
+    int len_len;
+
+    if (pkt_len < 1)
+        return NULL;               /* always too short */
+
+    if (NULL == pkt || NULL == data_len || NULL == data_len)
+        return NULL;
+
+    *data_len = 0;
+
+    if (*pkt & 0x80) {
+        /*
+         * long length; first byte is length of length (after masking high bit)
+         */
+        len_len = (int) ((*pkt & ~0x80) + 1);
+        if ((int) pkt_len <= len_len )
+            return NULL;           /* still too short for length and data */
+
+        /* now we know we have enough data to parse length */
+        asn_parse_length(pkt, data_len);
+    } else {
+        /*
+         * short length; first byte is the length
+         */
+        len_len = 1;
+        *data_len = *pkt;
+    }
+
+    if ((*data_len + len_len) > pkt_len)
+        return NULL;
+
+    return (pkt + len_len);
+}
+
+#if 0
+/**
+ * @internal
  * call after asn_parse_length to verify result.
  * 
  * @param str  error string
  * @param bufp start of buffer
  * @param data start of data
- * @param plen  ?
- * @param dlen  ?
+ * @param plen  ? parsed length
+ * @param dlen  ? data/buf length
  * 
  * @return 1 on error 0 on success
  */
@@ -325,6 +408,7 @@ _asn_parse_length_check(const char *str,
     }
     return 0;
 }
+#endif
 
 
 /**
@@ -492,20 +576,33 @@ asn_parse_int(u_char * data,
     u_long          asn_length;
     register long   value = 0;
 
+    if (NULL == data || NULL == datalength || NULL == type || NULL == intp) {
+        ERROR_MSG("parse int: NULL pointer");
+        return NULL;
+    }
+
     if (intsize != sizeof(long)) {
         _asn_size_err(errpre, intsize, sizeof(long));
         return NULL;
     }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 2);
+        return NULL;
+    }
+
     *type = *bufp++;
     if (*type != ASN_INTEGER) {
         _asn_type_err(errpre, *type);
         return NULL;
     }
 
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check
-        (errpre, bufp, data, asn_length, *datalength))
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     if ((size_t) asn_length > intsize || (int) asn_length == 0) {
         _asn_length_err(errpre, (size_t) asn_length, intsize);
@@ -564,20 +661,34 @@ asn_parse_unsigned_int(u_char * data,
     u_long          asn_length;
     register u_long value = 0;
 
+    if (NULL == data || NULL == datalength || NULL == type || NULL == intp) {
+        ERROR_MSG("parse uint: NULL pointer");
+        return NULL;
+    }
+
     if (intsize != sizeof(long)) {
         _asn_size_err(errpre, intsize, sizeof(long));
         return NULL;
     }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength <= 2) {
+        _asn_short_err(errpre, *datalength, 2);
+        return NULL;
+    }
+
     *type = *bufp++;
     if (*type != ASN_COUNTER && *type != ASN_GAUGE && *type != ASN_TIMETICKS
             && *type != ASN_UINTEGER) {
         _asn_type_err(errpre, *type);
         return NULL;
     }
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check
-        (errpre, bufp, data, asn_length, *datalength))
+
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     if ((asn_length > (intsize + 1)) || ((int) asn_length == 0) ||
         ((asn_length == intsize + 1) && *bufp != 0x00)) {
@@ -812,6 +923,18 @@ asn_parse_string(u_char * data,
     u_char         *bufp = data;
     u_long          asn_length;
 
+    if (NULL == data || NULL == datalength || NULL == type || NULL == str ||
+        NULL == strlength) {
+        ERROR_MSG("parse string: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 2);
+        return NULL;
+    }
+
     *type = *bufp++;
     if (*type != ASN_OCTET_STR && *type != ASN_IPADDRESS && *type != ASN_OPAQUE
             && *type != ASN_NSAP) {
@@ -819,9 +942,9 @@ asn_parse_string(u_char * data,
         return NULL;
     }
 
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check
-        (errpre, bufp, data, asn_length, *datalength)) {
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
     }
 
@@ -959,12 +1082,20 @@ u_char         *
 asn_parse_header(u_char * data, size_t * datalength, u_char * type)
 {
     register u_char *bufp;
-    u_long          asn_length;
+    u_long          asn_length = 0;
+    const char      *errpre = "parse header";
 
     if (!data || !datalength || !type) {
         ERROR_MSG("parse header: NULL pointer");
         return NULL;
     }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0) */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 2);
+        return NULL;
+    }
+
     bufp = data;
     /*
      * this only works on data types < 30, i.e. no extension octets 
@@ -973,12 +1104,13 @@ asn_parse_header(u_char * data, size_t * datalength, u_char * type)
         ERROR_MSG("can't process ID >= 30");
         return NULL;
     }
-    *type = *bufp;
-    bufp = asn_parse_length(bufp + 1, &asn_length);
+    *type = *bufp++;
 
-    if (_asn_parse_length_check
-        ("parse header", bufp, data, asn_length, *datalength))
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
 #ifdef DUMP_PRINT_HEADERS
     DEBUGDUMPSETUP("recv", data, (bufp - data));
@@ -1017,10 +1149,11 @@ asn_parse_header(u_char * data, size_t * datalength, u_char * type)
         /*
          * value is encoded as special format 
          */
-        bufp = asn_parse_length(bufp + 2, &asn_length);
-        if (_asn_parse_length_check("parse opaque header", bufp, data,
-                                    asn_length, *datalength))
+        bufp = asn_parse_nlength(bufp+2, *datalength - 2, &asn_length);
+        if (NULL == bufp) {
+            _asn_short_err("parse opaque header", *datalength, asn_length);
             return NULL;
+        }
     }
 #endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
 
@@ -1165,6 +1298,9 @@ asn_build_sequence(u_char * data,
  *  @return Returns a pointer to the first byte after this length
  *          field (aka: the start of the data field).
  *          Returns NULL on any error.
+ *
+ * WARNING: this function does not know the length of the data
+*           buffer, so it can go past the end of a short buffer.
  */
 u_char         *
 asn_parse_length(u_char * data, u_long * length)
@@ -1331,15 +1467,28 @@ asn_parse_objid(u_char * data,
     u_long          asn_length;
     size_t          original_length = *objidlength;
 
+    if (NULL == data || NULL == datalength || NULL == type || NULL == objid ||
+        NULL == objidlength) {
+        ERROR_MSG("parse objid: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 3);
+        return NULL;
+    }
+
     *type = *bufp++;
     if (*type != ASN_OBJECT_ID) {
         _asn_type_err(errpre, *type);
         return NULL;
     }
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check("parse objid", bufp, data,
-                                asn_length, *datalength))
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     *datalength -= (int) asn_length + (bufp - data);
 
@@ -1613,11 +1762,23 @@ asn_parse_null(u_char * data, size_t * datalength, u_char * type)
      */
     register u_char *bufp = data;
     u_long          asn_length;
+    static const char *errpre = "parse null";
+
+    if (NULL == data || NULL == datalength || NULL == type) {
+        ERROR_MSG("parse null: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length  (which should be 0) */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 2);
+        return NULL;
+    }
 
     *type = *bufp++;
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (bufp == NULL) {
-        ERROR_MSG("parse null: bad length");
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
     }
     if (asn_length != 0) {
@@ -1704,15 +1865,29 @@ asn_parse_bitstring(u_char * data,
     register u_char *bufp = data;
     u_long          asn_length;
 
+    if (NULL == data || NULL == datalength || NULL == type ||
+        NULL == str || NULL == strlength) {
+        ERROR_MSG("parse bitstring: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 3);
+        return NULL;
+    }
+
     *type = *bufp++;
     if (*type != ASN_BIT_STR) {
         _asn_type_err(errpre, *type);
         return NULL;
     }
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check(errpre, bufp, data,
-                                asn_length, *datalength))
+
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     if ((size_t) asn_length > *strlength) {
         _asn_length_err(errpre, (size_t) asn_length, *strlength);
@@ -1813,7 +1988,7 @@ u_char         *
 asn_parse_unsigned_int64(u_char * data,
                          size_t * datalength,
                          u_char * type,
-                         struct counter64 * cp, size_t countersize)
+                         struct counter64 *cp, size_t countersize)
 {
     /*
      * ASN.1 integer ::= 0x02 asnlength byte {byte}*
@@ -1828,6 +2003,18 @@ asn_parse_unsigned_int64(u_char * data,
         _asn_size_err(errpre, countersize, sizeof(struct counter64));
         return NULL;
     }
+
+    if (NULL == data || NULL == datalength || NULL == type || NULL == cp) {
+        ERROR_MSG("parse uint64: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 3);
+        return NULL;
+    }
+
     *type = *bufp++;
     if (*type != ASN_COUNTER64
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
@@ -1837,10 +2024,11 @@ asn_parse_unsigned_int64(u_char * data,
         _asn_type_err(errpre, *type);
         return NULL;
     }
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check
-        (errpre, bufp, data, asn_length, *datalength))
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     DEBUGDUMPSETUP("recv", data, bufp - data);
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
@@ -1859,10 +2047,11 @@ asn_parse_unsigned_int64(u_char * data,
         /*
          * value is encoded as special format 
          */
-        bufp = asn_parse_length(bufp + 2, &asn_length);
-        if (_asn_parse_length_check("parse opaque uint64", bufp, data,
-                                    asn_length, *datalength))
+        bufp = asn_parse_nlength(bufp+2, *datalength - 2, &asn_length);
+        if (NULL == bufp) {
+            _asn_short_err("parse opaque uint64", *datalength, asn_length);
             return NULL;
+        }
     }
 #endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
     if (((int) asn_length > uint64sizelimit) ||
@@ -1917,7 +2106,7 @@ u_char         *
 asn_build_unsigned_int64(u_char * data,
                          size_t * datalength,
                          u_char type,
-                         const struct counter64 * cp, size_t countersize)
+                         const struct counter64 *cp, size_t countersize)
 {
     /*
      * ASN.1 integer ::= 0x02 asnlength byte {byte}*
@@ -2071,7 +2260,7 @@ u_char         *
 asn_parse_signed_int64(u_char * data,
                        size_t * datalength,
                        u_char * type,
-                       struct counter64 * cp, size_t countersize)
+                       struct counter64 *cp, size_t countersize)
 {
     static const char *errpre = "parse int64";
     const int       int64sizelimit = (4 * 2) + 1;
@@ -2084,11 +2273,24 @@ asn_parse_signed_int64(u_char * data,
         _asn_size_err(errpre, countersize, sizeof(struct counter64));
         return NULL;
     }
+
+    if (NULL == data || NULL == datalength || NULL == type || NULL == cp) {
+        ERROR_MSG("parse int64: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0) */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 3);
+        return NULL;
+    }
+
     *type = *bufp++;
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check
-        (errpre, bufp, data, asn_length, *datalength))
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     DEBUGDUMPSETUP("recv", data, bufp - data);
     if ((*type == ASN_OPAQUE) &&
@@ -2101,10 +2303,11 @@ asn_parse_signed_int64(u_char * data,
         /*
          * value is encoded as special format 
          */
-        bufp = asn_parse_length(bufp + 2, &asn_length);
-        if (_asn_parse_length_check("parse opaque int64", bufp, data,
-                                    asn_length, *datalength))
+        bufp = asn_parse_nlength(bufp+2, *datalength - 2, &asn_length);
+        if (NULL == bufp) {
+            _asn_short_err("parse opaque int64", *datalength, asn_length);
             return NULL;
+        }
     }
     /*
      * this should always have been true until snmp gets int64 PDU types 
@@ -2175,7 +2378,7 @@ u_char         *
 asn_build_signed_int64(u_char * data,
                        size_t * datalength,
                        u_char type,
-                       const struct counter64 * cp, size_t countersize)
+                       const struct counter64 *cp, size_t countersize)
 {
     /*
      * ASN.1 integer ::= 0x02 asnlength byte {byte}*
@@ -2285,11 +2488,24 @@ asn_parse_float(u_char * data,
         _asn_size_err("parse float", floatsize, sizeof(float));
         return NULL;
     }
+
+    if (NULL == data || NULL == datalength || NULL == type || NULL == floatp) {
+        ERROR_MSG("parse float: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 3);
+        return NULL;
+    }
+
     *type = *bufp++;
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check("parse float", bufp, data,
-                                asn_length, *datalength))
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     DEBUGDUMPSETUP("recv", data, bufp - data + asn_length);
     /*
@@ -2302,11 +2518,11 @@ asn_parse_float(u_char * data,
         /*
          * value is encoded as special format 
          */
-        bufp = asn_parse_length(bufp + 2, &asn_length);
-        if (_asn_parse_length_check("parse opaque float", bufp, data,
-                                    asn_length, *datalength))
+        bufp = asn_parse_nlength(bufp+2, *datalength - 2, &asn_length);
+        if (NULL == bufp) {
+            _asn_short_err("parse opaque float", *datalength, asn_length);
             return NULL;
-
+        }
         /*
          * change type to Float 
          */
@@ -2458,11 +2674,24 @@ asn_parse_double(u_char * data,
         _asn_size_err("parse double", doublesize, sizeof(double));
         return NULL;
     }
+
+    if (NULL == data || NULL == datalength || NULL == type || NULL == doublep) {
+        ERROR_MSG("parse double: NULL pointer");
+        return NULL;
+    }
+
+    /** need at least 2 bytes to work with: type, length (which might be 0)  */
+    if (*datalength < 2) {
+        _asn_short_err(errpre, *datalength, 3);
+        return NULL;
+    }
+
     *type = *bufp++;
-    bufp = asn_parse_length(bufp, &asn_length);
-    if (_asn_parse_length_check("parse double", bufp, data,
-                                asn_length, *datalength))
+    bufp = asn_parse_nlength(bufp, *datalength - 1, &asn_length);
+    if (NULL == bufp) {
+        _asn_short_err(errpre, *datalength, asn_length);
         return NULL;
+    }
 
     DEBUGDUMPSETUP("recv", data, bufp - data + asn_length);
     /*
@@ -2475,10 +2704,11 @@ asn_parse_double(u_char * data,
         /*
          * value is encoded as special format 
          */
-        bufp = asn_parse_length(bufp + 2, &asn_length);
-        if (_asn_parse_length_check("parse opaque double", bufp, data,
-                                    asn_length, *datalength))
+        bufp = asn_parse_nlength(bufp+2, *datalength - 2, &asn_length);
+        if (NULL == bufp) {
+            _asn_short_err("parse opaque double", *datalength, asn_length);
             return NULL;
+        }
 
         /*
          * change type to Double 
@@ -3474,9 +3704,6 @@ asn_realloc_rbuild_signed_int64(u_char ** pkt, size_t * pkt_len,
         return 0;
     }
 
-    CHECK_OVERFLOW_S(high,14);
-    CHECK_OVERFLOW_U(low,14);
-
     /*
      * Encode the low 4 bytes first.  
      */
diff --git a/snmplib/cert_util.c b/snmplib/cert_util.c
index 246a6c9..537535a 100644
--- a/snmplib/cert_util.c
+++ b/snmplib/cert_util.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
@@ -193,7 +204,6 @@ _setup_trusted_certs(void)
         return;
     }
     _trusted_certs->container_name = strdup("trusted certificates");
-    _trusted_certs->free_item = (netsnmp_container_obj_func*) free;
     _trusted_certs->compare = (netsnmp_container_compare*) strcmp;
 }
 
@@ -1605,6 +1615,8 @@ _cert_indexes_load(void)
     subdirs[0] = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
                                        NETSNMP_DS_LIB_CERT_EXTRA_SUBDIR);
     confpath_copy = strdup(confpath);
+    if (!confpath_copy)
+        return;
     for ( dir = strtok_r(confpath_copy, ENV_SEPARATOR, &st);
           dir; dir = strtok_r(NULL, ENV_SEPARATOR, &st)) {
 
@@ -3122,7 +3134,7 @@ _find_tlstmParams_fingerprint(const char *name)
     if ((NULL == result) || (NULL == result->fingerprint))
         return NULL;
 
-    return strdup(result->fingerprint);
+    return result->fingerprint;
 }
 /*
  * END snmpTlstmParmsTable data
@@ -3210,6 +3222,13 @@ netsnmp_tlstmAddr_restore_common(char **line, char *name, size_t *name_len,
 {
     size_t fp_len_save = *fp_len;
 
+    /*
+     * Calling this function with name == NULL, fp == NULL or id == NULL would
+     * trigger a memory leak.
+     */
+    if (!name || !fp || !id)
+        return -1;
+
     *line = read_config_read_octet_string(*line, (u_char **)&name, name_len);
     if (NULL == *line) {
         config_perror("incomplete line");
diff --git a/snmplib/container.c b/snmplib/container.c
index b2ac97e..ad8853a 100644
--- a/snmplib/container.c
+++ b/snmplib/container.c
@@ -204,8 +204,10 @@ netsnmp_container_find_factory(const char *type_list)
         return NULL;
 
     list = strdup(type_list);
+    if (!list)
+        return NULL;
     entry = strtok_r(list, ":", &st);
-    while(entry) {
+    while (entry) {
         f = netsnmp_container_get_factory(entry);
         if (NULL != f)
             break;
@@ -242,8 +244,10 @@ netsnmp_container_find_ct(const char *type_list)
         return NULL;
 
     list = strdup(type_list);
+    if (!list)
+        return NULL;
     entry = strtok_r(list, ":", &st);
-    while(entry) {
+    while (entry) {
         ct = netsnmp_container_get_ct(entry);
         if (NULL != ct)
             break;
@@ -397,7 +401,10 @@ netsnmp_container *CONTAINER_DUP(netsnmp_container *x, void *ctx, u_int flags)
 int CONTAINER_FREE(netsnmp_container *x)
 {
     int  rc2, rc = 0;
-        
+
+    if (!x)
+        return rc;
+
     /** start at last container */
     while(x->next)
         x = x->next;
diff --git a/snmplib/container_binary_array.c b/snmplib/container_binary_array.c
index 0f5cf62..ce06ecb 100644
--- a/snmplib/container_binary_array.c
+++ b/snmplib/container_binary_array.c
@@ -1,9 +1,16 @@
 /*
  * container_binary_array.c
- * $Id$
  *
  * see comments in header file.
  *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -149,9 +156,9 @@ binary_search(const void *val, netsnmp_container *c, int exact)
     binary_array_table *t = (binary_array_table*)c->container_data;
     size_t             len = t->count;
     size_t             half;
-    size_t             middle = 0;
+    size_t             middle;
     size_t             first = 0;
-    int                result = 0;
+    int                result;
 
     if (!len)
         return -1;
@@ -170,18 +177,14 @@ binary_search(const void *val, netsnmp_container *c, int exact)
 
     while (len > 0) {
         half = len >> 1;
-        middle = first;
-        middle += half;
-        if ((result =
-             c->compare(t->data[middle], val)) < 0) {
-            first = middle;
-            ++first;
+        middle = first + half;
+        if ((result = c->compare(t->data[middle], val)) < 0) {
+            first = middle + 1;
             len = len - half - 1;
+        } else if (result == 0) {
+            first = middle;
+            break;
         } else {
-            if(result == 0) {
-                first = middle;
-                break;
-            }
             len = half;
         }
     }
@@ -189,25 +192,39 @@ binary_search(const void *val, netsnmp_container *c, int exact)
     if (first >= t->count)
         return -1;
 
-    if(first != middle) {
+    if (first != middle) {
         /* last compare wasn't against first, so get actual result */
         result = c->compare(t->data[first], val);
     }
 
-    if(result == 0) {
-        if (!exact) {
-            if (++first == t->count)
-               first = -1;
-        }
-    }
-    else {
-        if(exact)
+    if (result == 0) {
+        if (!exact && ++first == t->count)
+            first = -1;
+    } else if (exact) {
             first = -1;
     }
 
     return first;
 }
 
+/* Returns the index of the first element which compares greater than *val. */
+static int
+upper_bound(const void *val, netsnmp_container *c)
+{
+    binary_array_table *t = (binary_array_table*)c->container_data;
+    int                 i;
+
+    netsnmp_assert(!(c->flags & CONTAINER_KEY_UNSORTED));
+
+    i = binary_search(val, c, 0);
+    if (i < 0)
+        return t->count;
+    while (i < t->count && c->compare(t->data[i], val) <= 0)
+        i++;
+
+    return i;
+}
+
 NETSNMP_STATIC_INLINE binary_array_table *
 netsnmp_binary_array_initialize(void)
 {
@@ -412,12 +429,21 @@ netsnmp_binary_array_insert(netsnmp_container *c, const void *entry)
 {
     binary_array_table *t = (binary_array_table*)c->container_data;
     int             was_dirty = 0;
+    int             i;
+
+    if (c->flags & CONTAINER_KEY_UNSORTED)
+        i = t->count;
+    else {
+        i = upper_bound(entry, c);
+        netsnmp_assert(0 <= i && i <= t->count);
+    }
+
     /*
      * check for duplicates
      */
     if (! (c->flags & CONTAINER_KEY_ALLOW_DUPLICATES)) {
         was_dirty = t->dirty;
-        if (NULL != netsnmp_binary_array_get(c, entry, 1)) {
+        if (i > 0 && c->compare(t->data[i - 1], entry) == 0) {
             DEBUGMSGTL(("container","not inserting duplicate key\n"));
             return -1;
         }
@@ -438,9 +464,6 @@ netsnmp_binary_array_insert(netsnmp_container *c, const void *entry)
         if (new_data == NULL)
             return -1;
 
-        memset(new_data + t->max_size, 0x0,
-               (new_max - t->max_size) * sizeof(void*));
-
         t->data = new_data;
         t->max_size = new_max;
     }
@@ -448,8 +471,9 @@ netsnmp_binary_array_insert(netsnmp_container *c, const void *entry)
     /*
      * Insert the new entry into the data array
      */
-    t->data[t->count++] = NETSNMP_REMOVE_CONST(void *, entry);
-    t->dirty = 1;
+    memmove(&t->data[i + 1], &t->data[i], (t->count - i) * sizeof(t->data[i]));
+    t->count++;
+    t->data[i] = NETSNMP_REMOVE_CONST(void *, entry);
 
     /*
      * if array was dirty before we called get, sync was incremented when
@@ -513,12 +537,12 @@ netsnmp_binary_array_get_subset(netsnmp_container *c, void *key, int *len)
     /*
      * if there is no data, return NULL;
      */
-    if (!c || !key)
+    if (!c || !key || !len)
         return NULL;
 
     t = (binary_array_table*)c->container_data;
     netsnmp_assert(c->ncompare);
-    if (!t->count | !c->ncompare)
+    if (!t->count || !c->ncompare)
         return NULL;
 
     /*
@@ -541,6 +565,9 @@ netsnmp_binary_array_get_subset(netsnmp_container *c, void *key, int *len)
     }
 
     *len = end - start + 1;
+    if (*len <= 0)
+        return NULL;
+
     subset = (void **)malloc((*len) * sizeof(void*));
     if (subset)
         memcpy(subset, &t->data[start], sizeof(void*) * (*len));
@@ -612,13 +639,12 @@ _ba_get_subset(netsnmp_container *container, void *data)
     int len;
 
     rtn = netsnmp_binary_array_get_subset(container, data, &len);
-    if ((NULL==rtn) || (len <=0))
+    if (NULL==rtn)
         return NULL;
     
     va = SNMP_MALLOC_TYPEDEF(netsnmp_void_array);
-    if (NULL==va)
-    {
-        free (rtn);
+    if (va == NULL) {
+        free(rtn);
         return NULL;
     }
     
diff --git a/snmplib/container_list_ssll.c b/snmplib/container_list_ssll.c
index 7ff01c4..f79cc02 100644
--- a/snmplib/container_list_ssll.c
+++ b/snmplib/container_list_ssll.c
@@ -139,13 +139,15 @@ static int
 _ssll_insert(netsnmp_container *c, const void *data)
 {
     sl_container *sl = (sl_container*)c;
-    sl_node  *new_node, *curr = sl->head;
+    sl_node  *new_node, *curr;
     
-    if(NULL == c)
+    if (c == NULL)
         return -1;
-    
+
+    curr = sl->head;
+
     new_node = SNMP_MALLOC_TYPEDEF(sl_node);
-    if(NULL == new_node)
+    if (new_node == NULL)
         return -1;
     new_node->data = NETSNMP_REMOVE_CONST(void *, data);
     ++sl->count;
@@ -208,11 +210,15 @@ static int
 _ssll_remove(netsnmp_container *c, const void *data)
 {
     sl_container *sl = (sl_container*)c;
-    sl_node  *curr = sl->head;
+    sl_node  *curr;
     
-    if((NULL == c) || (NULL == curr))
+    if (c == NULL)
         return -1;
-    
+
+    curr = sl->head;
+    if (curr == NULL)
+        return -1;
+
     /*
      * special case for NULL data, act like stack
      */
@@ -490,12 +496,9 @@ _ssll_iterator_last(ssll_iterator *it)
     if (NULL == n)
         return NULL;
 
-    while(n->next)
+    while (n->next)
         n = n->next;
 
-    if (NULL == n)
-        return NULL;
-
     it->last = n;
 
     return it->last->data;
diff --git a/snmplib/data_list.c b/snmplib/data_list.c
index 505d4fc..44d014a 100644
--- a/snmplib/data_list.c
+++ b/snmplib/data_list.c
@@ -1,7 +1,14 @@
 /*
  * netsnmp_data_list.c
  *
- * $Id$
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
@@ -87,6 +94,9 @@ netsnmp_data_list_add_node(netsnmp_data_list **head, netsnmp_data_list *node)
 
     netsnmp_assert(NULL != head);
     netsnmp_assert(NULL != node);
+    if (!head || !node)
+        return;
+
     netsnmp_assert(NULL != node->name);
 
     DEBUGMSGTL(("data_list","adding key '%s'\n", node->name));
@@ -379,5 +389,12 @@ netsnmp_read_data_callback(const char *token, char *line) {
 
     return;
 }
+
+void
+shutdown_data_list(void)
+{
+    netsnmp_free_all_list_data(saveHead);
+}
+
 /**  @} */
 
diff --git a/snmplib/default_store.c b/snmplib/default_store.c
index 8dbc9bc..cba0f1f 100644
--- a/snmplib/default_store.c
+++ b/snmplib/default_store.c
@@ -186,11 +186,6 @@ static char *netsnmp_ds_strings[NETSNMP_DS_MAX_IDS][NETSNMP_DS_MAX_SUBIDS];
 static void *netsnmp_ds_voids[NETSNMP_DS_MAX_IDS][NETSNMP_DS_MAX_SUBIDS];
 #endif /* NETSNMP_FEATURE_REMOVE_DEFAULT_STORE_VOID */
 
-/*
- * Prototype definitions 
- */
-void            netsnmp_ds_handle_config(const char *token, char *line);
-
 /**
  * Stores "true" or "false" given an int value for value into
  * netsnmp_ds_booleans[store][which] slot.  
@@ -298,11 +293,13 @@ netsnmp_ds_set_string(int storeid, int which, const char *value)
      */
     if (netsnmp_ds_strings[storeid][which] == value)
         return SNMPERR_SUCCESS;
-    
+
+    snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
     if (netsnmp_ds_strings[storeid][which] != NULL) {
         free(netsnmp_ds_strings[storeid][which]);
 	netsnmp_ds_strings[storeid][which] = NULL;
     }
+    snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
 
     if (value) {
         netsnmp_ds_strings[storeid][which] = strdup(value);
@@ -545,6 +542,7 @@ netsnmp_ds_shutdown(void)
     netsnmp_ds_read_config *drsp;
     int             i, j;
 
+    snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
     for (drsp = netsnmp_ds_configs; drsp; drsp = netsnmp_ds_configs) {
         netsnmp_ds_configs = drsp->next;
 
@@ -568,5 +566,6 @@ netsnmp_ds_shutdown(void)
             }
         }
     }
+    snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
 }
 /**  @} */
diff --git a/snmplib/int64.c b/snmplib/int64.c
index 51f1f32..948efbd 100644
--- a/snmplib/int64.c
+++ b/snmplib/int64.c
@@ -33,7 +33,7 @@
  * @param[out] puR   Remainder.
  */
 void
-divBy10(U64 u64, U64 * pu64Q, unsigned int *puR)
+divBy10(struct counter64 u64, struct counter64 *pu64Q, unsigned int *puR)
 {
     unsigned long   ulT;
     unsigned long   ulQ;
@@ -83,7 +83,7 @@ divBy10(U64 u64, U64 * pu64Q, unsigned int *puR)
  * @param[out] pu64P Product.
  */
 void
-multBy10(U64 u64, U64 * pu64P)
+multBy10(struct counter64 u64, struct counter64 *pu64P)
 {
     unsigned long   ulT;
     unsigned long   ulP;
@@ -130,7 +130,7 @@ multBy10(U64 u64, U64 * pu64P)
  *
  */
 void
-incrByU16(U64 * pu64, unsigned int u16)
+incrByU16(struct counter64 *pu64, unsigned int u16)
 {
     incrByU32(pu64, u16);
 }
@@ -143,7 +143,7 @@ incrByU16(U64 * pu64, unsigned int u16)
  *
  */
 void
-incrByU32(U64 * pu64, unsigned int u32)
+incrByU32(struct counter64 *pu64, unsigned int u32)
 {
     uint32_t tmp;
 
@@ -161,7 +161,8 @@ incrByU32(U64 * pu64, unsigned int u32)
  * @param[out] pu64out pu64one - pu64two.
  */
 void
-u64Subtract(const U64 * pu64one, const U64 * pu64two, U64 * pu64out)
+u64Subtract(const struct counter64 *pu64one, const struct counter64 *pu64two,
+            struct counter64 *pu64out)
 {
     int carry;
 
@@ -177,7 +178,7 @@ u64Subtract(const U64 * pu64one, const U64 * pu64two, U64 * pu64out)
  * @param[in,out] pu64out pu64out += pu64one.
  */
 void
-u64Incr(U64 * pu64out, const U64 * pu64one)
+u64Incr(struct counter64 *pu64out, const struct counter64 *pu64one)
 {
     pu64out->high = (uint32_t)(pu64out->high + pu64one->high);
     incrByU32(pu64out, pu64one->low);
@@ -191,9 +192,10 @@ u64Incr(U64 * pu64out, const U64 * pu64one)
  * @param[out] pu64out pu64out += (pu64one - pu64two)
  */
 void
-u64UpdateCounter(U64 * pu64out, const U64 * pu64one, const U64 * pu64two)
+u64UpdateCounter(struct counter64 *pu64out, const struct counter64 *pu64one,
+                 const struct counter64 *pu64two)
 {
-    U64 tmp;
+    struct counter64 tmp;
 
     u64Subtract(pu64one, pu64two, &tmp);
     u64Incr(pu64out, &tmp);
@@ -208,7 +210,7 @@ netsnmp_feature_child_of(u64copy, netsnmp_unused)
  * @param[out] pu64one Where to store the copy - *pu64one = *pu64two.
  */
 void
-u64Copy(U64 * pu64one, const U64 * pu64two)
+u64Copy(struct counter64 *pu64one, const struct counter64 *pu64two)
 {
     *pu64one = *pu64two;
 }
@@ -220,7 +222,7 @@ u64Copy(U64 * pu64one, const U64 * pu64two)
  * @param[in] pu64 Number to be zeroed.
  */
 void
-zeroU64(U64 * pu64)
+zeroU64(struct counter64 *pu64)
 {
     pu64->low = 0;
     pu64->high = 0;
@@ -232,7 +234,7 @@ zeroU64(U64 * pu64)
  * @param[in] pu64 Number to be checked.
  */
 int
-isZeroU64(const U64 * pu64)
+isZeroU64(const struct counter64 *pu64)
 {
     return pu64->low == 0 && pu64->high == 0;
 }
@@ -333,8 +335,10 @@ netsnmp_c64_check_for_32bit_wrap(struct counter64 *old_val,
  * @retval -2 : look like we have 64 bit values, but sums aren't consistent
  */
 int
-netsnmp_c64_check32_and_update(struct counter64 *prev_val, struct counter64 *new_val,
-                               struct counter64 *old_prev_val, int *need_wrap_check)
+netsnmp_c64_check32_and_update(struct counter64 *prev_val,
+                               struct counter64 *new_val,
+                               struct counter64 *old_prev_val,
+                               int *need_wrap_check)
 {
     int rc;
 
@@ -390,10 +394,10 @@ netsnmp_c64_check32_and_update(struct counter64 *prev_val, struct counter64 *new
 /** Convert an unsigned 64-bit number to ASCII. */
 void
 printU64(char *buf, /* char [I64CHARSZ+1]; */
-         const U64 * pu64)
+         const struct counter64 *pu64)
 {
-    U64             u64a;
-    U64             u64b;
+    struct counter64 u64a;
+    struct counter64 u64b;
 
     char            aRes[I64CHARSZ + 1];
     unsigned int    u;
@@ -414,9 +418,9 @@ printU64(char *buf, /* char [I64CHARSZ+1]; */
 /** Convert a signed 64-bit number to ASCII. */
 void
 printI64(char *buf, /* char [I64CHARSZ+1]; */
-         const U64 * pu64)
+         const struct counter64 *pu64)
 {
-    U64             u64a;
+    struct counter64 u64a;
 
     if (pu64->high & 0x80000000) {
         u64a.high = (uint32_t) ~pu64->high;
@@ -429,11 +433,11 @@ printI64(char *buf, /* char [I64CHARSZ+1]; */
     }
 }
 
-/** Convert a signed 64-bit integer from ASCII to U64. */
+/** Convert a signed 64-bit integer from ASCII to struct counter64. */
 int
-read64(U64 * i64, const char *str)
+read64(struct counter64 *i64, const char *str)
 {
-    U64             i64p;
+    struct counter64 i64p;
     unsigned int    u;
     int             sign = 0;
     int             ok = 0;
diff --git a/snmplib/large_fd_set.c b/snmplib/large_fd_set.c
index 88dd481..eaa462d 100644
--- a/snmplib/large_fd_set.c
+++ b/snmplib/large_fd_set.c
@@ -32,18 +32,18 @@ netsnmp_large_fd_setfd(SOCKET fd, netsnmp_large_fd_set * fdset)
 
     netsnmp_assert(fd != INVALID_SOCKET);
 
-    if (fdset->lfs_set.fd_count == fdset->lfs_setsize)
+    if (fdset->lfs_setptr->fd_count == fdset->lfs_setsize)
         netsnmp_large_fd_set_resize(fdset, 2 * (fdset->lfs_setsize + 1));
 
-    for (i = 0; i < fdset->lfs_set.fd_count; i++) {
-        if (fdset->lfs_set.fd_array[i] == (SOCKET) (fd))
+    for (i = 0; i < fdset->lfs_setptr->fd_count; i++) {
+        if (fdset->lfs_setptr->fd_array[i] == fd)
             break;
     }
 
-    if (i == fdset->lfs_set.fd_count
-        && fdset->lfs_set.fd_count < fdset->lfs_setsize) {
-        fdset->lfs_set.fd_count++;
-        fdset->lfs_set.fd_array[i] = fd;
+    if (i == fdset->lfs_setptr->fd_count &&
+        fdset->lfs_setptr->fd_count < fdset->lfs_setsize) {
+        fdset->lfs_setptr->fd_count++;
+        fdset->lfs_setptr->fd_array[i] = fd;
     }
 }
 
@@ -54,14 +54,14 @@ netsnmp_large_fd_clr(SOCKET fd, netsnmp_large_fd_set * fdset)
 
     netsnmp_assert(fd != INVALID_SOCKET);
 
-    for (i = 0; i < fdset->lfs_set.fd_count; i++) {
-        if (fdset->lfs_set.fd_array[i] == fd) {
-            while (i < fdset->lfs_set.fd_count - 1) {
-                fdset->lfs_set.fd_array[i] =
-                    fdset->lfs_set.fd_array[i + 1];
+    for (i = 0; i < fdset->lfs_setptr->fd_count; i++) {
+        if (fdset->lfs_setptr->fd_array[i] == fd) {
+            while (i < fdset->lfs_setptr->fd_count - 1) {
+                fdset->lfs_setptr->fd_array[i] =
+                    fdset->lfs_setptr->fd_array[i + 1];
                 i++;
             }
-            fdset->lfs_set.fd_count--;
+            fdset->lfs_setptr->fd_count--;
             break;
         }
     }
@@ -74,8 +74,8 @@ netsnmp_large_fd_is_set(SOCKET fd, netsnmp_large_fd_set * fdset)
 
     netsnmp_assert(fd != INVALID_SOCKET);
 
-    for (i = 0; i < fdset->lfs_set.fd_count; i++) {
-        if (fdset->lfs_set.fd_array[i] == fd)
+    for (i = 0; i < fdset->lfs_setptr->fd_count; i++) {
+        if (fdset->lfs_setptr->fd_array[i] == fd)
             return 1;
     }
     return 0;
@@ -85,11 +85,40 @@ netsnmp_large_fd_is_set(SOCKET fd, netsnmp_large_fd_set * fdset)
 
 /*
  * Recent versions of glibc trigger abort() if FD_SET(), FD_CLR() or
- * FD_ISSET() is invoked with n >= FD_SETSIZE. Hence these replacement macros.
+ * FD_ISSET() is invoked with n >= FD_SETSIZE. Hence these replacement
+ * functions. However, since NFDBITS != 8 * sizeof(fd_set.fds_bits[0]) for at
+ * least HP-UX on ia64 and since that combination uses big endian, use the
+ * macros from <sys/select.h> on such systems.
  */
-#define LFD_SET(n, p)    ((p)->fds_bits[(n)/NFDBITS] |=  (1ULL << ((n) % NFDBITS)))
-#define LFD_CLR(n, p)    ((p)->fds_bits[(n)/NFDBITS] &= ~(1ULL << ((n) % NFDBITS)))
-#define LFD_ISSET(n, p)  ((p)->fds_bits[(n)/NFDBITS] &   (1ULL << ((n) % NFDBITS)))
+NETSNMP_STATIC_INLINE void LFD_SET(unsigned n, fd_set *p)
+{
+    enum { nfdbits = 8 * sizeof(p->fds_bits[0]) };
+
+    if (nfdbits == NFDBITS)
+        p->fds_bits[n / nfdbits] |= (1ULL << (n % nfdbits));
+    else
+        FD_SET(n, p);
+}
+
+NETSNMP_STATIC_INLINE void LFD_CLR(unsigned n, fd_set *p)
+{
+    enum { nfdbits = 8 * sizeof(p->fds_bits[0]) };
+
+    if (nfdbits == NFDBITS)
+        p->fds_bits[n / nfdbits] &= ~(1ULL << (n % nfdbits));
+    else
+        FD_CLR(n, p);
+}
+
+NETSNMP_STATIC_INLINE unsigned LFD_ISSET(unsigned n, const fd_set *p)
+{
+    enum { nfdbits = 8 * sizeof(p->fds_bits[0]) };
+
+    if (nfdbits == NFDBITS)
+        return (p->fds_bits[n / nfdbits] & (1ULL << (n % nfdbits))) != 0;
+    else
+        return FD_ISSET(n, p) != 0;
+}
 
 void
 netsnmp_large_fd_setfd(int fd, netsnmp_large_fd_set * fdset)
@@ -204,8 +233,8 @@ netsnmp_large_fd_set_resize(netsnmp_large_fd_set * fdset, int setsize)
 
     fdset->lfs_setsize = setsize;
 #if !defined(cygwin) && defined(HAVE_WINSOCK_H)
-    if (setsize < fdset->lfs_set.fd_count)
-        fdset->lfs_set.fd_count = setsize;
+    if (setsize < fdset->lfs_setptr->fd_count)
+        fdset->lfs_setptr->fd_count = setsize;
 #endif
 success:
     return 1;
@@ -213,7 +242,7 @@ success:
 out_of_mem:
     fdset->lfs_setsize = 0;
 #if !defined(cygwin) && defined(HAVE_WINSOCK_H)
-    fdset->lfs_set.fd_count = 0;
+    fdset->lfs_setptr->fd_count = 0;
 #endif
     return 0;
 }
diff --git a/snmplib/mib.c b/snmplib/mib.c
index e790878..81a4693 100644
--- a/snmplib/mib.c
+++ b/snmplib/mib.c
@@ -36,6 +36,11 @@ SOFTWARE.
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
@@ -126,6 +131,7 @@ netsnmp_feature_child_of(mib_to_asn_type, mib_api)
 
 static char    *uptimeString(u_long, char *, size_t);
 
+#ifndef NETSNMP_DISABLE_MIB_LOADING
 static struct tree *_get_realloc_symbol(const oid * objid, size_t objidlen,
                                         struct tree *subtree,
                                         u_char ** buf, size_t * buf_len,
@@ -141,6 +147,7 @@ static int      print_tree_node(u_char ** buf, size_t * buf_len,
 static void     handle_mibdirs_conf(const char *token, char *line);
 static void     handle_mibs_conf(const char *token, char *line);
 static void     handle_mibfile_conf(const char *token, char *line);
+#endif /*NETSNMP_DISABLE_MIB_LOADING */
 
 static void     _oid_finish_printing(const oid * objid, size_t objidlen,
                                      u_char ** buf, size_t * buf_len,
@@ -150,8 +157,8 @@ static void     _oid_finish_printing(const oid * objid, size_t objidlen,
 /*
  * helper functions for get_module_node 
  */
-static int      node_to_oid(struct tree *, oid *, size_t *);
 #ifndef NETSNMP_DISABLE_MIB_LOADING
+static int      node_to_oid(struct tree *, oid *, size_t *);
 static int      _add_strings_to_oid(struct tree *, char *,
                                     oid *, size_t *, size_t);
 #else
@@ -167,13 +174,14 @@ NETSNMP_IMPORT struct tree *Mib;
 struct tree    *Mib;            /* Backwards compatibility */
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
 
-oid             RFC1213_MIB[] = { 1, 3, 6, 1, 2, 1 };
 static char     Standard_Prefix[] = ".1.3.6.1.2.1";
 
 /*
  * Set default here as some uses of read_objid require valid pointer. 
  */
+#ifndef NETSNMP_DISABLE_MIB_LOADING
 static char    *Prefix = &Standard_Prefix[0];
+#endif /* NETSNMP_DISABLE_MIB_LOADING */
 typedef struct _PrefixList {
     const char     *str;
     int             len;
@@ -354,8 +362,8 @@ sprint_realloc_hexstring(u_char ** buf, size_t * buf_len, size_t * out_len,
 {
     int line_len = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
                                       NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);
-    if (!line_len)
-        line_len=len;
+    if (line_len <= 0)
+        line_len = len;
 
     for (; (int)len > line_len; len -= line_len) {
         if(!_sprint_hexstring_line(buf, buf_len, out_len, allow_realloc, cp, line_len))
@@ -2598,6 +2606,8 @@ netsnmp_init_mib(void)
      */
     netsnmp_fixup_mib_directory();
     env_var = strdup(netsnmp_get_mib_directory());
+    if (!env_var)
+        return;
     netsnmp_mibindex_load();
 
     DEBUGMSGTL(("init_mib",
@@ -2816,15 +2826,18 @@ netsnmp_mibindex_load( void )
         if (!fp)
             continue;
         cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );
+        fclose( fp );
         if ( !cp ) {
             DEBUGMSGTL(("mibindex", "Empty MIB index (%d)\n", i));
-            fclose(fp);
+            continue;
+        }
+        if ( strncmp( tmpbuf2, "DIR ", 4 ) != 0 ) {
+            DEBUGMSGTL(("mibindex", "Malformed MIB index (%d)\n", i));
             continue;
         }
         tmpbuf2[strlen(tmpbuf2)-1] = 0;
         DEBUGMSGTL(("mibindex", "load: (%d) %s\n", i, tmpbuf2));
         (void)_mibindex_add( tmpbuf2+4, i );  /* Skip 'DIR ' */
-        fclose( fp );
     }
     closedir( dir );
 }
@@ -3043,8 +3056,8 @@ read_objid(const char *input, oid * output, size_t * out_len)
 {                               /* number of subid's in "output" */
 #ifndef NETSNMP_DISABLE_MIB_LOADING
     struct tree    *root = tree_top;
-#endif /* NETSNMP_DISABLE_MIB_LOADING */
     char            buf[SPRINT_MAX_LEN];
+#endif /* NETSNMP_DISABLE_MIB_LOADING */
     int             ret, max_out_len;
     char           *name, ch;
     const char     *cp;
@@ -4215,6 +4228,31 @@ _oid_finish_printing(const oid * objid, size_t objidlen,
 }
 
 #ifndef NETSNMP_DISABLE_MIB_LOADING
+static void
+_get_realloc_symbol_octet_string(size_t numids, const oid * objid,
+				 u_char ** buf, size_t * buf_len,
+				 size_t * out_len, int allow_realloc,
+				 int *buf_overflow, struct tree* tp)
+{
+  netsnmp_variable_list	var = { 0 };
+  u_char		buffer[1024];
+  size_t		i;
+
+  for (i = 0; i < numids; i++)
+    buffer[i] = (u_char) objid[i];
+  var.type = ASN_OCTET_STR;
+  var.val.string = buffer;
+  var.val_len = numids;
+  if (!*buf_overflow) {
+    if (!sprint_realloc_octet_string(buf, buf_len, out_len,
+				     allow_realloc, &var,
+				     NULL, tp->hint,
+				     NULL)) {
+      *buf_overflow = 1;
+    }
+  }
+}
+
 static struct tree *
 _get_realloc_symbol(const oid * objid, size_t objidlen,
                     struct tree *subtree,
@@ -4228,6 +4266,7 @@ _get_realloc_symbol(const oid * objid, size_t objidlen,
     int             output_format =
         netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
     char            intbuf[64];
+    struct tree    *orgtree = subtree;
 
     if (!objid || !buf) {
         return NULL;
@@ -4288,7 +4327,6 @@ _get_realloc_symbol(const oid * objid, size_t objidlen,
         }
     }
 
-
     if (end_of_known) {
         *end_of_known = *out_len;
     }
@@ -4297,6 +4335,18 @@ _get_realloc_symbol(const oid * objid, size_t objidlen,
      * Subtree not found.  
      */
 
+    if (orgtree && in_dices && objidlen > 0) {
+	sprintf(intbuf, "%" NETSNMP_PRIo "u.", *objid);
+	if (!*buf_overflow
+	    && !snmp_strcat(buf, buf_len, out_len,
+			    allow_realloc,
+			    (const u_char *) intbuf)) {
+	    *buf_overflow = 1;
+	}
+	objid++;
+	objidlen--;
+    }
+
     while (in_dices && (objidlen > 0) &&
            (NETSNMP_OID_OUTPUT_NUMERIC != output_format) &&
            !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS)) {
@@ -4326,11 +4376,6 @@ _get_realloc_symbol(const oid * objid, size_t objidlen,
         switch (tp->type) {
         case TYPE_OCTETSTR:
             if (extended_index && tp->hint) {
-                netsnmp_variable_list var;
-                u_char          buffer[1024];
-                int             i;
-
-                memset(&var, 0, sizeof var);
                 if (in_dices->isimplied) {
                     numids = objidlen;
                     if (numids > objidlen)
@@ -4349,19 +4394,9 @@ _get_realloc_symbol(const oid * objid, size_t objidlen,
                 }
                 if (numids > objidlen)
                     goto finish_it;
-                for (i = 0; i < (int) numids; i++)
-                    buffer[i] = (u_char) objid[i];
-                var.type = ASN_OCTET_STR;
-                var.val.string = buffer;
-                var.val_len = numids;
-                if (!*buf_overflow) {
-                    if (!sprint_realloc_octet_string(buf, buf_len, out_len,
-                                                     allow_realloc, &var,
-                                                     NULL, tp->hint,
-                                                     NULL)) {
-                        *buf_overflow = 1;
-                    }
-                }
+		_get_realloc_symbol_octet_string(numids, objid, buf, buf_len,
+						 out_len, allow_realloc,
+						 buf_overflow, tp);
             } else if (in_dices->isimplied) {
                 numids = objidlen;
                 if (numids > objidlen)
@@ -5284,7 +5319,6 @@ node_to_oid(struct tree *tp, oid * objid, size_t * objidlen)
 
     return (numids);
 }
-#endif /* NETSNMP_DISABLE_MIB_LOADING */
 
 /*
  * Replace \x with x stop at eos_marker
@@ -5318,6 +5352,7 @@ static char *_apply_escapes(char *src, char eos_marker)
 	return src;
     }
 }
+#endif /* NETSNMP_DISABLE_MIB_LOADING */
 
 static int
 #ifndef NETSNMP_DISABLE_MIB_LOADING
@@ -5329,18 +5364,17 @@ _add_strings_to_oid(void *tp, char *cp,
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
 {
     oid             subid;
-    int             len_index = 1000000;
-#ifndef NETSNMP_DISABLE_MIB_LOADING
-    struct tree    *tp2 = NULL;
-    struct index_list *in_dices = NULL;
-#endif /* NETSNMP_DISABLE_MIB_LOADING */
     char           *fcp, *ecp, *cp2 = NULL;
     char            doingquote;
-    int             len = -1, pos = -1;
+    int             len = -1;
 #ifndef NETSNMP_DISABLE_MIB_LOADING
+    struct tree    *tp2 = NULL;
+    struct index_list *in_dices = NULL;
+    int             pos = -1;
     int             check =
         !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);
     int             do_hint = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);
+    int             len_index = 1000000;
 
     while (cp && tp && tp->child_list) {
         fcp = cp;
@@ -5678,8 +5712,6 @@ _add_strings_to_oid(void *tp, char *cp,
                 (*objidlen)++;
             }
 
-            if (!cp)
-                goto bad_id;
             while (*cp && *cp != doingquote) {
                 if (*objidlen >= maxlen)
                     goto bad_id;
@@ -6077,9 +6109,11 @@ uptime_string_n(u_long timeticks, char *buf, size_t buflen)
 oid            *
 snmp_parse_oid(const char *argv, oid * root, size_t * rootlen)
 {
+#ifndef NETSNMP_DISABLE_MIB_LOADING
     size_t          savlen = *rootlen;
+#endif /* NETSNMP_DISABLE_MIB_LOADING */
     static size_t   tmpbuf_len = 0;
-    static char    *tmpbuf;
+    static char    *tmpbuf = NULL;
     const char     *suffix, *prefix;
 
     suffix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
@@ -6093,7 +6127,7 @@ snmp_parse_oid(const char *argv, oid * root, size_t * rootlen)
             prefix = "";
         if ((strlen(suffix) + strlen(prefix) + strlen(argv) + 2) > tmpbuf_len) {
             tmpbuf_len = strlen(suffix) + strlen(argv) + strlen(prefix) + 2;
-            tmpbuf = (char *)realloc(tmpbuf, tmpbuf_len);
+            tmpbuf = malloc(tmpbuf_len);
         }
         snprintf(tmpbuf, tmpbuf_len, "%s%s%s%s", prefix, argv,
                  ((suffix[0] == '.' || suffix[0] == '\0') ? "" : "."),
@@ -6106,31 +6140,37 @@ snmp_parse_oid(const char *argv, oid * root, size_t * rootlen)
     if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS)
         || strchr(argv, ':')) {
         if (get_node(argv, root, rootlen)) {
+            free(tmpbuf);
             return root;
         }
     } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS)) {
 	clear_tree_flags(tree_head);
         if (get_wild_node(argv, root, rootlen)) {
+            free(tmpbuf);
             return root;
         }
     } else {
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
         if (read_objid(argv, root, rootlen)) {
+            free(tmpbuf);
             return root;
         }
 #ifndef NETSNMP_DISABLE_MIB_LOADING
         *rootlen = savlen;
         if (get_node(argv, root, rootlen)) {
+            free(tmpbuf);
             return root;
         }
         *rootlen = savlen;
         DEBUGMSGTL(("parse_oid", "wildly parsing\n"));
 	clear_tree_flags(tree_head);
         if (get_wild_node(argv, root, rootlen)) {
+            free(tmpbuf);
             return root;
         }
     }
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
+    free(tmpbuf);
     return NULL;
 }
 
diff --git a/snmplib/parse.c b/snmplib/parse.c
index 4d44d88..0072892 100644
--- a/snmplib/parse.c
+++ b/snmplib/parse.c
@@ -797,6 +797,9 @@ static void
 print_error(const char *str, const char *token, int type)
 {
     erroneousMibs++;
+    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
+                                NETSNMP_DS_LIB_MIB_ERRORS))
+	return;
     DEBUGMSGTL(("parse-mibs", "\n"));
     if (type == ENDOFFILE)
         snmp_log(LOG_ERR, "%s (EOF): At line %d in %s\n", str, mibLine,
@@ -1760,6 +1763,7 @@ do_linkup(struct module *mp, struct node *np)
             continue;
         tp = find_tree_node(mip->label, mip->modid);
         if (!tp) {
+	    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_ERRORS))
                 snmp_log(LOG_WARNING,
                          "Did not find '%s' in module %s (%s)\n",
                          mip->label, module_name(mip->modid, modbuf),
@@ -1801,6 +1805,7 @@ do_linkup(struct module *mp, struct node *np)
                             op->next = np->next;
                         else
                             nbuckets[hash] = np->next;
+			DEBUGMSGTL(("parse-mibs", "Moving %s to orphanage", np->label));
                         np->next = orphan_nodes;
                         orphan_nodes = np;
                         op = NULL;
@@ -2010,7 +2015,7 @@ parse_objectid(FILE * fp, char *name)
         if (op->label && (nop->label || (nop->subid != -1))) {
             np = alloc_node(nop->modid);
             if (np == NULL)
-                return (NULL);
+                goto err;
             if (root == NULL)
                 root = np;
 
@@ -2020,19 +2025,13 @@ parse_objectid(FILE * fp, char *name)
                  * The name for this node is the label for this entry 
                  */
                 np->label = strdup(name);
-                if (np->label == NULL) {
-                    SNMP_FREE(np->parent);
-                    SNMP_FREE(np);
-                    return (NULL);
-                }
+                if (np->label == NULL)
+                    goto err;
             } else {
                 if (!nop->label) {
                     nop->label = (char *) malloc(20 + ANON_LEN);
-                    if (nop->label == NULL) {
-                        SNMP_FREE(np->parent);
-                        SNMP_FREE(np);
-                        return (NULL);
-                    }
+                    if (nop->label == NULL)
+                        goto err;
                     sprintf(nop->label, "%s%d", ANON, anonymous++);
                 }
                 np->label = strdup(nop->label);
@@ -2052,6 +2051,7 @@ parse_objectid(FILE * fp, char *name)
         }                       /* end if(op->label... */
     }
 
+out:
     /*
      * free the loid array 
      */
@@ -2061,6 +2061,13 @@ parse_objectid(FILE * fp, char *name)
     }
 
     return root;
+
+err:
+    for (; root; root = np) {
+        np = root->next;
+        free_node(root);
+    }
+    goto out;
 }
 
 static int
@@ -2386,20 +2393,24 @@ parse_asntype(FILE * fp, char *name, int *ntype, char *ntoken)
             while (type != SYNTAX && type != ENDOFFILE) {
                 if (type == DISPLAYHINT) {
                     type = get_token(fp, token, MAXTOKEN);
-                    if (type != QUOTESTRING)
+                    if (type != QUOTESTRING) {
                         print_error("DISPLAY-HINT must be string", token,
                                     type);
-                    else
+                    } else {
+                        free(hint);
                         hint = strdup(token);
+                    }
                 } else if (type == DESCRIPTION &&
                            netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
                                                   NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
                     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
-                    if (type != QUOTESTRING)
+                    if (type != QUOTESTRING) {
                         print_error("DESCRIPTION must be string", token,
                                     type);
-                    else
+                    } else {
+                        free(descr);
                         descr = strdup(quoted_string_buffer);
+                    }
                 } else
                     type =
                         get_token(fp, quoted_string_buffer, MAXQUOTESTR);
@@ -2409,8 +2420,7 @@ parse_asntype(FILE * fp, char *name, int *ntype, char *ntoken)
                 type = get_token(fp, token, MAXTOKEN);
                 if (type != IDENTIFIER) {
                     print_error("Expected IDENTIFIER", token, type);
-                    SNMP_FREE(hint);
-                    return NULL;
+                    goto err;
                 }
                 type = OBJID;
             }
@@ -2418,7 +2428,7 @@ parse_asntype(FILE * fp, char *name, int *ntype, char *ntoken)
             type = get_token(fp, token, MAXTOKEN);
             if (type != IDENTIFIER) {
                 print_error("Expected IDENTIFIER", token, type);
-                return NULL;
+                goto err;
             }
             type = OBJID;
         }
@@ -2437,14 +2447,12 @@ parse_asntype(FILE * fp, char *name, int *ntype, char *ntoken)
 
         if (i == MAXTC) {
             print_error("Too many textual conventions", token, type);
-            SNMP_FREE(hint);
-            return NULL;
+            goto err;
         }
         if (!(type & SYNTAX_MASK)) {
             print_error("Textual convention doesn't map to real type",
                         token, type);
-            SNMP_FREE(hint);
-            return NULL;
+            goto err;
         }
         tcp = &tclist[i];
         tcp->modid = current_module;
@@ -2465,6 +2473,11 @@ parse_asntype(FILE * fp, char *name, int *ntype, char *ntoken)
         }
         return NULL;
     }
+
+err:
+    SNMP_FREE(descr);
+    SNMP_FREE(hint);
+    return NULL;
 }
 
 
@@ -3676,6 +3689,10 @@ parse_imports(FILE * fp)
         type = get_token(fp, token, MAXTOKEN);
     }
 
+    /* Initialize modid in case the module name was missing. */
+    for (; i < import_count; ++i)
+        import_list[i].modid = -1;
+
     /*
      * Save the import information
      *   in the global module table
@@ -4909,7 +4926,7 @@ add_mibdir(const char *dirname)
             DEBUGMSGTL(("parse-mibs", "The index is good\n"));
             if ((ip = fopen(token, "r")) != NULL) {
                 fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */
-                while (fscanf(ip, "%127s%c%299s%c", token, &space, tmpstr,
+                while (fscanf(ip, "%127s%c%299[^\n]%c", token, &space, tmpstr,
 		    &newline) == 4) {
 
 		    /*
diff --git a/snmplib/read_config.c b/snmplib/read_config.c
index 3167674..ab5b6a3 100644
--- a/snmplib/read_config.c
+++ b/snmplib/read_config.c
@@ -1020,6 +1020,8 @@ read_configs_optional(const char *optional_config, int when)
                 "reading optional configuration tokens for %s\n", type));
     
     newp = strdup(optional_config);      /* strtok_r messes it up */
+    if (!newp)
+        return ret;
     cp = strtok_r(newp, ",", &st);
     while (cp) {
         struct stat     statbuf;
@@ -1540,7 +1542,14 @@ read_config_store(const char *type, const char *line)
         DEBUGMSGTL(("read_config:store", "storing: %s\n", line));
         fclose(fout);
     } else {
-        snmp_log(LOG_ERR, "read_config_store open failure on %s\n", filep);
+        if (strcmp(NETSNMP_APPLICATION_CONFIG_TYPE, type) != 0) {
+            /*
+             * Ignore this error in client utilities, they can run with random
+             * UID/GID and typically cannot write to /var. Error message just
+             * confuses people.
+             */
+            snmp_log(LOG_ERR, "read_config_store open failure on %s\n", filep);
+        }
     }
 #ifdef NETSNMP_PERSISTENT_MASK
     umask(oldmask);
@@ -2270,10 +2279,10 @@ read_config_read_memory(int type, char *readfrom,
         return readfrom;
 
     case ASN_COUNTER64:
-        if (*len < sizeof(U64))
+        if (*len < sizeof(struct counter64))
             return NULL;
-        *len = sizeof(U64);
-        read64((U64 *) dataptr, readfrom);
+        *len = sizeof(struct counter64);
+        read64((struct counter64 *) dataptr, readfrom);
         readfrom = skip_token(readfrom);
         return readfrom;
     }
diff --git a/snmplib/scapi.c b/snmplib/scapi.c
index 16ac829..c290377 100644
--- a/snmplib/scapi.c
+++ b/snmplib/scapi.c
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 /*
@@ -697,17 +702,17 @@ sc_encrypt(const oid * privtype, size_t privtypelen,
     u_int           properlength = 0, properlength_iv = 0;
     u_char          pad_block[128];      /* bigger than anything I need */
     u_char          my_iv[128];  /* ditto */
-    int             pad, plast, pad_size = 0;
     int             have_trans;
 #ifndef NETSNMP_DISABLE_DES
+    int             pad, plast, pad_size = 0;
 #ifdef OLD_DES
     DES_key_schedule key_sch;
 #else
     DES_key_schedule key_sched_store;
     DES_key_schedule *key_sch = &key_sched_store;
-#endif
+#endif /* OLD_DES */
     DES_cblock       key_struct;
-#endif
+#endif /* NETSNMP_DISABLE_DES */
 #ifdef HAVE_AES
     AES_KEY aes_key;
     int new_ivlen = 0;
@@ -719,7 +724,7 @@ sc_encrypt(const oid * privtype, size_t privtypelen,
      * Sanity check.
      */
 #if	!defined(NETSNMP_ENABLE_SCAPI_AUTHPRIV)
-    snmp_log(LOG_ERR, "Encryption support not enabled.\n");
+    snmp_log(LOG_ERR, "Encryption support not enabled.(2)\n");
     return SNMPERR_SC_NOT_CONFIGURED;
 #endif
 
@@ -879,7 +884,7 @@ sc_encrypt(const oid * privtype, size_t privtypelen,
      * Sanity check.
      */
 #if	!defined(NETSNMP_ENABLE_SCAPI_AUTHPRIV)
-    snmp_log(LOG_ERR, "Encryption support not enabled.\n");
+    snmp_log(LOG_ERR, "Encryption support not enabled.(1)\n");
     return SNMPERR_SC_NOT_CONFIGURED;
 #endif
 
@@ -920,7 +925,7 @@ sc_encrypt(const oid * privtype, size_t privtypelen,
 {
 #	if NETSNMP_USE_INTERNAL_MD5
     {
-        snmp_log(LOG_ERR, "Encryption support not enabled.\n");
+        snmp_log(LOG_ERR, "Encryption support not enabled.(3)\n");
         DEBUGMSGTL(("scapi", "Encrypt function not defined.\n"));
         return SNMPERR_SC_GENERAL_FAILURE;
     }
@@ -1129,7 +1134,7 @@ sc_decrypt(const oid * privtype, size_t privtypelen,
 #else
 {
 #if	!defined(NETSNMP_ENABLE_SCAPI_AUTHPRIV)
-    snmp_log(LOG_ERR, "Encryption support not enabled.\n");
+    snmp_log(LOG_ERR, "Encryption support not enabled.(4)\n");
     return SNMPERR_SC_NOT_CONFIGURED;
 #else
 #	if NETSNMP_USE_INTERNAL_MD5
diff --git a/snmplib/snmp_api.c b/snmplib/snmp_api.c
index 191debf..544cb12 100644
--- a/snmplib/snmp_api.c
+++ b/snmplib/snmp_api.c
@@ -29,6 +29,11 @@ SOFTWARE.
  * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 /** @defgroup library The Net-SNMP library
@@ -135,17 +140,16 @@ SOFTWARE.
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmp_service.h>
 #include <net-snmp/library/vacm.h>
+#if defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL)
+#include <openssl/ssl.h>
+#include <net-snmp/library/cert_util.h>
+#endif
 
 netsnmp_feature_child_of(statistics, libnetsnmp)
 netsnmp_feature_child_of(snmp_api, libnetsnmp)
 netsnmp_feature_child_of(oid_is_subtree, snmp_api)
 netsnmp_feature_child_of(snmpv3_probe_contextEngineID_rfc5343, snmp_api)
 
-#if defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL)
-extern void netsnmp_certs_init(void);
-extern void netsnmp_certs_shutdown(void);
-#endif
-
 static void     _init_snmp(void);
 
 static int      _snmp_store_needed = 0;
@@ -340,9 +344,6 @@ static int      snmp_detail_f = 0;
 /*
  * Prototypes.
  */
-int             snmp_build(u_char ** pkt, size_t * pkt_len,
-                           size_t * offset, netsnmp_session * pss,
-                           netsnmp_pdu *pdu);
 static int      snmp_parse(void *, netsnmp_session *, netsnmp_pdu *,
                            u_char *, size_t);
 
@@ -357,11 +358,6 @@ static int      snmp_resend_request(struct session_list *slp,
                                     int incr_retries);
 static void     register_default_handlers(void);
 static struct session_list *snmp_sess_copy(netsnmp_session * pss);
-int             snmp_get_errno(void);
-NETSNMP_IMPORT
-void            snmp_synch_reset(netsnmp_session * notused);
-NETSNMP_IMPORT
-void            snmp_synch_setup(netsnmp_session * notused);
 
 #ifndef HAVE_STRERROR
 const char     *
@@ -709,6 +705,8 @@ _init_snmp(void)
                        NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH, 16);
     netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RETRIES,
                        DEFAULT_RETRIES);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
+			   NETSNMP_DS_LIB_MIB_ERRORS, 1);
 
 #ifdef NETSNMP_USE_REVERSE_ASNENCODING
     netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
@@ -925,6 +923,8 @@ snmp_shutdown(const char *type)
     netsnmp_clear_default_target();
     netsnmp_clear_default_domain();
     shutdown_secmod();
+    shutdown_data_list();
+    snmp_debug_shutdown();    /* should be done last */
 
     init_snmp_init_done  = 0;
     _init_snmp_init_done = 0;
@@ -1434,7 +1434,7 @@ netsnmp_sess_config_transport(netsnmp_container *transport_configuration,
         if (transport->f_config) {
             netsnmp_iterator *iter;
             netsnmp_transport_config *config_data;
-            int ret;
+            int ret = 0;
 
             iter = CONTAINER_ITERATOR(transport_configuration);
             if (NULL == iter) {
@@ -1445,10 +1445,12 @@ netsnmp_sess_config_transport(netsnmp_container *transport_configuration,
                 config_data = (netsnmp_transport_config*)ITERATOR_NEXT(iter)) {
                 ret = transport->f_config(transport, config_data->key,
                                           config_data->value);
-                if (ret) {
-                    return SNMPERR_TRANSPORT_CONFIG_ERROR;
-                }
+                if (ret)
+                    break;
             }
+            ITERATOR_RELEASE(iter);
+            if (ret)
+                return SNMPERR_TRANSPORT_CONFIG_ERROR;
         } else {
             return SNMPERR_TRANSPORT_NO_CONFIG;
         }
@@ -1565,7 +1567,7 @@ _sess_open(netsnmp_session * in_session)
                                                NULL);
         }
 
-        if (NULL != clientaddr_save)
+        if (NULL != in_session->localname)
             netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
                                   NETSNMP_DS_LIB_CLIENT_ADDR, clientaddr_save);
     }
@@ -3106,7 +3108,7 @@ snmp_pdu_build(netsnmp_pdu *pdu, u_char * cp, size_t * out_length)
     h1e = cp;
 
     /*
-     * store fields in the PDU preceeding the variable-bindings sequence 
+     * store fields in the PDU preceding the variable-bindings sequence
      */
     if (pdu->command != SNMP_MSG_TRAP) {
         /*
@@ -3351,7 +3353,7 @@ snmp_pdu_realloc_rbuild(u_char ** pkt, size_t * pkt_len, size_t * offset,
                                      *offset - start_offset);
 
     /*
-     * Store fields in the PDU preceeding the variable-bindings sequence.  
+     * Store fields in the PDU preceding the variable-bindings sequence.
      */
     if (pdu->command != SNMP_MSG_TRAP) {
         /*
@@ -4350,10 +4352,9 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
     u_char          type;
     u_char          msg_type;
     u_char         *var_val;
-    int             badtype = 0;
     size_t          len;
     size_t          four;
-    netsnmp_variable_list *vp = NULL;
+    netsnmp_variable_list *vp = NULL, *vplast = NULL;
     oid             objid[MAX_OID_LEN];
     u_char         *p;
 
@@ -4368,7 +4369,7 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
     pdu->flags &= (~UCD_MSG_FLAG_RESPONSE_PDU);
 
     /*
-     * get the fields in the PDU preceeding the variable-bindings sequence 
+     * get the fields in the PDU preceding the variable-bindings sequence
      */
     switch (pdu->command) {
     case SNMP_MSG_TRAP:
@@ -4493,38 +4494,24 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
                               (ASN_SEQUENCE | ASN_CONSTRUCTOR),
                               "varbinds");
     if (data == NULL)
-        return -1;
+        goto fail;
 
     /*
      * get each varBind sequence 
      */
     while ((int) *length > 0) {
-        netsnmp_variable_list *vptemp;
-        vptemp = (netsnmp_variable_list *) malloc(sizeof(*vptemp));
-        if (NULL == vptemp) {
-            return -1;
-        }
-        if (NULL == vp) {
-            pdu->variables = vptemp;
-        } else {
-            vp->next_variable = vptemp;
-        }
-        vp = vptemp;
+        vp = SNMP_MALLOC_TYPEDEF(netsnmp_variable_list);
+        if (NULL == vp)
+            goto fail;
 
-        vp->next_variable = NULL;
-        vp->val.string = NULL;
         vp->name_length = MAX_OID_LEN;
-        vp->name = NULL;
-        vp->index = 0;
-        vp->data = NULL;
-        vp->dataFreeHook = NULL;
         DEBUGDUMPSECTION("recv", "VarBind");
         data = snmp_parse_var_op(data, objid, &vp->name_length, &vp->type,
                                  &vp->val_len, &var_val, length);
         if (data == NULL)
-            return -1;
+            goto fail;
         if (snmp_set_var_objid(vp, objid, vp->name_length))
-            return -1;
+            goto fail;
 
         len = MAX_PACKET_LENGTH;
         DEBUGDUMPHEADER("recv", "Value");
@@ -4536,7 +4523,7 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
                           (long *) vp->val.integer,
                           sizeof(*vp->val.integer));
             if (!p)
-                return -1;
+                goto fail;
             break;
         case ASN_COUNTER:
         case ASN_GAUGE:
@@ -4548,7 +4535,7 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
                                    (u_long *) vp->val.integer,
                                    vp->val_len);
             if (!p)
-                return -1;
+                goto fail;
             break;
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
         case ASN_OPAQUE_COUNTER64:
@@ -4561,7 +4548,7 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
                                      (struct counter64 *) vp->val.
                                      counter64, vp->val_len);
             if (!p)
-                return -1;
+                goto fail;
             break;
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
         case ASN_OPAQUE_FLOAT:
@@ -4570,7 +4557,7 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
             p = asn_parse_float(var_val, &len, &vp->type,
                             vp->val.floatVal, vp->val_len);
             if (!p)
-                return -1;
+                goto fail;
             break;
         case ASN_OPAQUE_DOUBLE:
             vp->val.doubleVal = (double *) vp->buf;
@@ -4578,7 +4565,7 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
             p = asn_parse_double(var_val, &len, &vp->type,
                              vp->val.doubleVal, vp->val_len);
             if (!p)
-                return -1;
+                goto fail;
             break;
         case ASN_OPAQUE_I64:
             vp->val.counter64 = (struct counter64 *) vp->buf;
@@ -4588,12 +4575,12 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
                                    sizeof(*vp->val.counter64));
 
             if (!p)
-                return -1;
+                goto fail;
             break;
 #endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
         case ASN_IPADDRESS:
             if (vp->val_len != 4)
-                return -1;
+                goto fail;
             /* fallthrough */
         case ASN_OCTET_STR:
         case ASN_OPAQUE:
@@ -4604,22 +4591,22 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
                 vp->val.string = (u_char *) malloc(vp->val_len);
             }
             if (vp->val.string == NULL) {
-                return -1;
+                goto fail;
             }
             p = asn_parse_string(var_val, &len, &vp->type, vp->val.string,
                              &vp->val_len);
             if (!p)
-                return -1;
+                goto fail;
             break;
         case ASN_OBJECT_ID:
             vp->val_len = MAX_OID_LEN;
             p = asn_parse_objid(var_val, &len, &vp->type, objid, &vp->val_len);
             if (!p)
-                return -1;
+                goto fail;
             vp->val_len *= sizeof(oid);
             vp->val.objid = (oid *) malloc(vp->val_len);
             if (vp->val.objid == NULL) {
-                return -1;
+                goto fail;
             }
             memmove(vp->val.objid, objid, vp->val_len);
             break;
@@ -4631,21 +4618,37 @@ snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data, size_t * length)
         case ASN_BIT_STR:
             vp->val.bitstring = (u_char *) malloc(vp->val_len);
             if (vp->val.bitstring == NULL) {
-                return -1;
+                goto fail;
             }
             p = asn_parse_bitstring(var_val, &len, &vp->type,
                                 vp->val.bitstring, &vp->val_len);
             if (!p)
-                return -1;
+                goto fail;
             break;
         default:
             snmp_log(LOG_ERR, "bad type returned (%x)\n", vp->type);
-            badtype = -1;
+            goto fail;
             break;
         }
         DEBUGINDENTADD(-4);
+
+        if (NULL == vplast) {
+            pdu->variables = vp;
+        } else {
+            vplast->next_variable = vp;
+        }
+        vplast = vp;
+        vp = NULL;
     }
-    return badtype;
+    return 0;
+
+  fail:
+    DEBUGMSGTL(("recv", "error while parsing VarBindList\n"));
+    /** if we were parsing a var, remove it from the pdu and free it */
+    if (vp)
+        snmp_free_var(vp);
+
+    return -1;
 }
 
 /*
@@ -4976,6 +4979,18 @@ _sess_async_send(void *sessp,
     reqid = pdu->reqid;
 
     /*
+     * Bug 2387: 0 is a valid request id, so since reqid is used as a return
+     * code with 0 meaning an error, set reqid to 1 if there is no error. This
+     * does not affect the request id in the packet and fixes a memory leak
+     * for incoming PDUs with a request id of 0. This could cause some
+     * confusion if the caller is expecting the request id to match the
+     * return code, as the documentation states it will. Most example code
+     * just checks for non-zero, so hopefully this wont be an issue.
+     */
+    if (0 == reqid && (SNMPERR_SUCCESS == session->s_snmp_errno))
+        ++reqid;
+
+    /*
      * Add to pending requests list if we expect a response.  
      */
     if (pdu->flags & UCD_MSG_FLAG_EXPECT_RESPONSE) {
@@ -5177,7 +5192,10 @@ snmp_create_sess_pdu(netsnmp_transport *transport, void *opaque,
  * This function processes a complete (according to asn_check_packet or the
  * AgentX equivalent) packet, parsing it into a PDU and calling the relevant
  * callbacks.  On entry, packetptr points at the packet in the session's
- * buffer and length is the length of the packet.  
+ * buffer and length is the length of the packet.  Return codes:
+ *   0: pdu handled (pdu deleted)
+ *  -1: error (pdu deleted)
+ *  -2: pdu not found for shared session (pdu NOT deleted)
  */
 
 static int
@@ -5193,6 +5211,8 @@ _sess_process_packet(void *sessp, netsnmp_session * sp,
   struct snmp_secmod_def *sptr;
   int             ret = 0, handled = 0;
 
+  debug_indent_reset();
+
   DEBUGMSGTL(("sess_process_packet",
 	      "session %p fd %d pkt %p length %d\n", sessp,
 	      transport->sock, packetptr, length));
@@ -5384,7 +5404,9 @@ _sess_process_packet(void *sessp, netsnmp_session * sp,
 	      /*
 	       * TODO FIX: recover after message callback *?
                */
-	      return -1;
+                snmp_log(LOG_ERR, "malloc failed handling pdu\n");
+                snmp_free_pdu(pdu);
+                return -1;
 	    }
 	    memcpy(sp->securityEngineID, pdu->securityEngineID,
 		   pdu->securityEngineIDLen);
@@ -5397,6 +5419,8 @@ _sess_process_packet(void *sessp, netsnmp_session * sp,
 		/*
 		 * TODO FIX: recover after message callback *?
 		 */
+                snmp_log(LOG_ERR, "malloc failed handling pdu\n");
+                snmp_free_pdu(pdu);
                 return -1;
 	      }
 	      memcpy(sp->contextEngineID,
@@ -5525,6 +5549,11 @@ _sess_read(void *sessp, netsnmp_large_fd_set * fdset)
         return 0;
     }
 
+    if (NULL == slp || NULL == sp || NULL == isp || NULL == transport) {
+        snmp_log(LOG_ERR, "bad parameters to _sess_read\n");
+        return SNMPERR_GENERR;
+    }
+
     /* to avoid subagent crash */ 
     if (transport->sock < 0) { 
         snmp_log (LOG_INFO, "transport->sock got negative fd value %d\n", transport->sock);
@@ -5596,6 +5625,9 @@ _sess_read(void *sessp, netsnmp_large_fd_set * fdset)
                     (void)nslp->session->callback(NETSNMP_CALLBACK_OP_CONNECT,
                                                   nslp->session, 0, NULL,
                                                   sp->callback_magic);
+                } else {
+                    transport->f_close(new_transport);
+                    netsnmp_transport_free(new_transport);
                 }
                 return 0;
             } else {
@@ -6655,6 +6687,7 @@ netsnmp_oid_find_prefix(const oid * in_name1, size_t len1,
                            Return its length. */
 }
 
+#ifndef NETSNMP_DISABLE_MIB_LOADING
 static int _check_range(struct tree *tp, long ltmp, int *resptr,
 	                const char *errmsg)
 {
@@ -6697,7 +6730,7 @@ static int _check_range(struct tree *tp, long ltmp, int *resptr,
     free(temp);
     return 1;
 }
-        
+#endif /* NETSNMP_DISABLE_MIB_LOADING */
 
 /*
  * Add a variable with the requested name to the end of the list of
@@ -6786,14 +6819,14 @@ snmp_add_var(netsnmp_pdu *pdu,
 					     NETSNMP_DS_LIB_NO_DISPLAY_HINT);
     u_char         *hintptr;
     struct tree    *tp;
+    struct enum_list *ep;
+    int             itmp;
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
     u_char         *buf = NULL;
     const u_char   *buf_ptr = NULL;
     size_t          buf_len = 0, value_len = 0, tint;
     in_addr_t       atmp;
     long            ltmp;
-    int             itmp;
-    struct enum_list *ep;
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
     double          dtmp;
     float           ftmp;
@@ -7039,8 +7072,6 @@ snmp_add_var(netsnmp_pdu *pdu,
                 snmp_set_detail(value);
                 break;
             }
-            /* initialize itmp value so that range check below works */
-            itmp = value_len;
             buf_ptr = buf;
         } else if (type == 's') {
             buf_ptr = (const u_char *)value;
@@ -7084,6 +7115,10 @@ snmp_add_var(netsnmp_pdu *pdu,
 #endif /* NETSNMP_DISABLE_MIB_LOADING */
 
 	vp = strdup(value);
+        if (!vp) {
+            SNMP_FREE(buf);
+            goto fail;
+        }
 	for (cp = strtok_r(vp, " ,\t", &st); cp; cp = strtok_r(NULL, " ,\t", &st)) {
             int             ix, bit;
 
@@ -7091,7 +7126,7 @@ snmp_add_var(netsnmp_pdu *pdu,
             if (*ecp != 0) {
 #ifndef NETSNMP_DISABLE_MIB_LOADING
                 for (ep = tp ? tp->enums : NULL; ep != NULL; ep = ep->next) {
-                    if (strncmp(ep->label, cp, strlen(ep->label)) == 0) {
+                    if (strcmp(ep->label, cp) == 0) {
                         break;
                     }
                 }
diff --git a/snmplib/snmp_client.c b/snmplib/snmp_client.c
index ab7a58c..afad4c4 100644
--- a/snmplib/snmp_client.c
+++ b/snmplib/snmp_client.c
@@ -32,6 +32,11 @@ SOFTWARE.
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 /** @defgroup snmp_client various PDU processing routines
@@ -400,7 +405,7 @@ _clone_pdu_header(netsnmp_pdu *pdu)
         if (ret)
         {
             snmp_free_pdu(newpdu);
-            return 0;
+            return NULL;
         }
     }
 
@@ -430,6 +435,8 @@ _copy_varlist(netsnmp_variable_list * var,      /* source varList */
     while (var && (copy_count-- > 0)) {
         /*
          * Drop the specified variable (if applicable) 
+         * xxx hmm, is it intentional that dropping the errindex
+         *     counts towards copy_count?
          */
         if (++ii == errindex) {
             var = var->next_variable;
@@ -1044,11 +1051,13 @@ snmp_synch_response_cb(netsnmp_session * ss,
     ss->callback = pcb;
     ss->callback_magic = (void *) state;
 
-    if ((state->reqid = snmp_send(ss, pdu)) == 0) {
+    if (snmp_send(ss, pdu) == 0) {
         snmp_free_pdu(pdu);
         state->status = STAT_ERROR;
-    } else
+    } else {
+        state->reqid = pdu->reqid;
         state->waiting = 1;
+    }
 
     while (state->waiting) {
         numfds = 0;
@@ -1056,7 +1065,7 @@ snmp_synch_response_cb(netsnmp_session * ss,
         block = NETSNMP_SNMPBLOCK;
         tvp = &timeout;
         timerclear(tvp);
-        snmp_sess_select_info_flags(0, &numfds, &fdset, tvp, &block,
+        snmp_sess_select_info_flags(NULL, &numfds, &fdset, tvp, &block,
                                     NETSNMP_SELECT_NOALARMS);
         if (block == 1)
             tvp = NULL;         /* block without timeout */
@@ -1136,11 +1145,13 @@ snmp_sess_synch_response(void *sessp,
     ss->callback = snmp_synch_input;
     ss->callback_magic = (void *) state;
 
-    if ((state->reqid = snmp_sess_send(sessp, pdu)) == 0) {
+    if (snmp_sess_send(sessp, pdu) == 0) {
         snmp_free_pdu(pdu);
         state->status = STAT_ERROR;
-    } else
+    } else {
         state->waiting = 1;
+        state->reqid = pdu->reqid;
+    }
 
     while (state->waiting) {
         numfds = 0;
@@ -1281,17 +1292,37 @@ static int _query(netsnmp_variable_list *list,
                   int                    request,
                   netsnmp_session       *session) {
 
-    netsnmp_pdu *pdu      = snmp_pdu_create( request );
+    netsnmp_pdu *pdu;
     netsnmp_pdu *response = NULL;
     netsnmp_variable_list *vb1, *vb2, *vtmp;
     int ret, count;
 
     DEBUGMSGTL(("iquery", "query on session %p\n", session));
+
+    if (NULL == list) {
+        snmp_log(LOG_ERR, "empty variable list in _query\n");
+        return SNMP_ERR_GENERR;
+    }
+
+    pdu = snmp_pdu_create( request );
+    if (NULL == pdu) {
+        snmp_log(LOG_ERR, "could not allocate pdu\n");
+        return SNMP_ERR_GENERR;
+    }
+
     /*
      * Clone the varbind list into the request PDU...
      */
     pdu->variables = snmp_clone_varbind( list );
+    if (NULL == pdu->variables) {
+        snmp_log(LOG_ERR, "could not clone variable list\n");
+        snmp_free_pdu(pdu);
+        return SNMP_ERR_GENERR;
+    }
+
+#ifndef NETSNMP_NO_WRITE_SUPPORT
 retry:
+#endif
     if ( session )
         ret = snmp_synch_response(            session, pdu, &response );
     else if (_def_query_session)
@@ -1355,7 +1386,7 @@ retry:
                 }
                 vtmp = vb2->next_variable;
                 snmp_free_var_internals( vb2 );
-                snmp_clone_var( vb1, vb2 );
+                snmp_clone_var( vb1, vb2 ); /* xxx: check return? */
                 vb2->next_variable = vtmp;
             }
         }
diff --git a/snmplib/snmp_debug.c b/snmplib/snmp_debug.c
index 27ce233..24f5668 100644
--- a/snmplib/snmp_debug.c
+++ b/snmplib/snmp_debug.c
@@ -1,3 +1,14 @@
+/*
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
 #include <net-snmp/net-snmp-config.h>
 
 #include <limits.h>
@@ -31,6 +42,7 @@
 
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/snmp_assert.h>
 
 #define SNMP_DEBUG_DISABLED           0
 #define SNMP_DEBUG_ACTIVE             1
@@ -45,7 +57,7 @@ static int      debug_print_everything = 0;
 netsnmp_token_descr dbg_tokens[MAX_DEBUG_TOKENS];
 
 /*
- * Number of spaces to indent debug outpur. Valid range is [0,INT_MAX]
+ * Number of spaces to indent debug output. Valid range is [0,INT_MAX]
  */
 static int debugindent = 0;
 
@@ -80,6 +92,14 @@ NETSNMP_IMPORT void
 debug_config_register_tokens(const char *configtoken, char *tokens);
 
 void
+debug_indent_reset(void)
+{
+    if (debugindent != 0)
+        DEBUGMSGTL(("dump_indent","indent rest from %d\n", debugindent));
+    debugindent = 0;
+}
+
+void
 debug_config_register_tokens(const char *configtoken, char *tokens)
 {
     debug_register_tokens(tokens);
@@ -105,6 +125,8 @@ debug_register_tokens(const char *tokens)
         return;
 
     newp = strdup(tokens);      /* strtok_r messes it up */
+    if (!newp)
+        return;
     cp = strtok_r(newp, DEBUG_TOKEN_DELIMITER, &st);
     while (cp) {
         if (strlen(cp) < MAX_DEBUG_TOKEN_LEN) {
@@ -576,3 +598,13 @@ snmp_debug_init(void)
                                     debug_config_register_tokens, NULL,
                                     "token[,token...]");
 }
+
+void
+snmp_debug_shutdown(void)
+{
+    int i;
+
+   for (i=0; i<debug_num_tokens; i++) {
+       SNMP_FREE(dbg_tokens [i].token_name);
+    }
+}
diff --git a/snmplib/snmp_enum.c b/snmplib/snmp_enum.c
index 8a6bd38..7b0fcf7 100644
--- a/snmplib/snmp_enum.c
+++ b/snmplib/snmp_enum.c
@@ -21,6 +21,7 @@
 
 #include <net-snmp/library/snmp_enum.h>
 #include <net-snmp/library/tools.h>
+#include <net-snmp/library/system.h>      /* strcasecmp() */
 #include <net-snmp/library/snmp_assert.h>
 
 netsnmp_feature_child_of(snmp_enum_all, libnetsnmp)
@@ -67,7 +68,7 @@ init_snmp_enum(const char *type)
     }
     current_min_num = SE_MAX_SUBIDS;
 
-    register_config_handler(type, "enum", se_read_conf, NULL, NULL);
+    register_const_config_handler(type, "enum", se_read_conf, NULL, NULL);
     return SE_OK;
 }
 
@@ -94,11 +95,11 @@ se_store_in_list(struct snmp_enum_list *new_list,
 }
 
 void
-se_read_conf(const char *word, char *cptr)
+se_read_conf(const char *word, const char *cptr)
 {
     int major, minor;
     int value;
-    char *cp, *cp2;
+    const char *cp, *cp2;
     char e_name[BUFSIZ];
     char e_enum[  BUFSIZ];
 
@@ -109,8 +110,8 @@ se_read_conf(const char *word, char *cptr)
      * Extract the first token
      *   (which should be the name of the list)
      */
-    cp = copy_nword(cptr, e_name, sizeof(e_name));
-    cp = skip_white(cp);
+    cp = copy_nword_const(cptr, e_name, sizeof(e_name));
+    cp = skip_white_const(cp);
     if (!cp || *cp=='\0')
         return;
 
@@ -124,7 +125,7 @@ se_read_conf(const char *word, char *cptr)
          *  Numeric major/minor style
          */
         while (1) {
-            cp = copy_nword(cp, e_enum, sizeof(e_enum));
+            cp = copy_nword_const(cp, e_enum, sizeof(e_enum));
             if (sscanf(e_enum, "%d:", &value) != 1) {
                 break;
             }
@@ -140,7 +141,7 @@ se_read_conf(const char *word, char *cptr)
          *  Named enumeration
          */
         while (1) {
-            cp = copy_nword(cp, e_enum, sizeof(e_enum));
+            cp = copy_nword_const(cp, e_enum, sizeof(e_enum));
             if (sscanf(e_enum, "%d:", &value) != 1) {
                 break;
             }
diff --git a/snmplib/snmp_logging.c b/snmplib/snmp_logging.c
index a2cd55a..d01cbc1 100644
--- a/snmplib/snmp_logging.c
+++ b/snmplib/snmp_logging.c
@@ -11,6 +11,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 /** @defgroup snmp_logging generic logging for net-snmp 
  *  @ingroup library
@@ -84,6 +89,9 @@
 #define va_copy(dest, src) memcpy (&dest, &src, sizeof (va_list))
 #endif
 #endif
+#ifndef HAVE_VSNPRINTF
+#include "snprintf.h"
+#endif
 
 netsnmp_feature_child_of(logging_all, libnetsnmp)
 
@@ -137,14 +145,6 @@ void
 netsnmp_enable_filelog(netsnmp_log_handler *logh, int dont_zero_log);
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_FILE */
 
-#ifndef HAVE_VSNPRINTF
-                /*
-                 * Need to use the UCD-provided one 
-                 */
-int             vsnprintf(char *str, size_t count, const char *fmt,
-                          va_list arg);
-#endif
-
 void
 parse_config_logOption(const char *token, char *cptr)
 {
@@ -240,7 +240,7 @@ netsnmp_set_line_buffering(FILE *stream)
  *                 OUT - points to last character after the decoded priority
  * @param pri_max - OUT - maximum priority (i.e. 0x7 from "0-7")
  */
-int
+static int
 decode_priority( char **optarg, int *pri_max )
 {
     int pri_low = LOG_DEBUG;
@@ -309,7 +309,7 @@ decode_priority( char **optarg, int *pri_max )
 }
 
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG
-int
+static int
 decode_facility( char *optarg )
 {
     if (optarg == NULL)
@@ -444,8 +444,10 @@ snmp_log_options(char *optarg, int argc, char *const *argv)
      */
     case 'F':
         priority = decode_priority( &optarg, &pri_max );
-        if (priority == -1 || !argv)  return -1;
-        optarg = argv[++optind];
+        if (priority == -1) return -1;
+        while (*optarg == ' ') optarg++;
+        if (!*optarg && !argv) return -1;
+        else if (!*optarg) optarg = argv[++optind];
         /* Fallthrough */
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_FILE
     case 'f':
@@ -455,6 +457,7 @@ snmp_log_options(char *optarg, int argc, char *const *argv)
             fprintf(stderr, "Missing log file\n");
             return -1;
         }
+        DEBUGMSGTL(("logging:options", "%d-%d: '%s'\n", priority, pri_max, optarg));
         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_FILE, priority);
         if (logh) {
             logh->pri_max = pri_max;
@@ -491,7 +494,10 @@ snmp_log_options(char *optarg, int argc, char *const *argv)
         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_SYSLOG, priority);
         if (logh) {
             int facility = decode_facility(optarg);
-            if (facility == -1)  return -1;
+            if (facility == -1) {
+                netsnmp_remove_loghandler(logh);
+                return -1;
+            }
             logh->pri_max = pri_max;
             logh->token   = strdup(snmp_log_syslogname(NULL));
             logh->magic   = (void *)(intptr_t)facility;
@@ -729,7 +735,9 @@ void
 netsnmp_logging_restart(void)
 {
     netsnmp_log_handler *logh;
+#ifndef NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG
     int doneone = 0;
+#endif /* NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG */
 
     for (logh = logh_head; logh; logh = logh->next) {
         if (0 == logh->enabled)
@@ -995,6 +1003,11 @@ netsnmp_register_loghandler( int type, int priority )
 
     DEBUGMSGT(("logging:register", "registering log type %d with pri %d\n",
                type, priority));
+    if (priority > LOG_DEBUG) {
+        DEBUGMSGT(("logging:register", "  limiting pri %d to %d\n", priority,
+                   LOG_DEBUG));
+        priority = LOG_DEBUG;
+    }
 
     logh->type     = type;
     switch ( type ) {
@@ -1078,7 +1091,8 @@ netsnmp_remove_loghandler( netsnmp_log_handler *logh )
         logh->next->prev = logh->prev;
 
     for (i=LOG_EMERG; i<=logh->priority; i++)
-        logh_priorities[i] = NULL;
+        if (logh == logh_priorities[i])
+            logh_priorities[i] = logh->next;
     free(NETSNMP_REMOVE_CONST(char*, logh->token));
     SNMP_FREE(logh);
 
@@ -1312,6 +1326,8 @@ snmp_log_string(int priority, const char *str)
     /*
      * Start at the given priority, and work "upwards"....
      */
+    if (priority > LOG_DEBUG)
+        priority = LOG_DEBUG;
     logh = logh_priorities[priority];
     for ( ; logh; logh = logh->next ) {
         /*
diff --git a/snmplib/snmp_openssl.c b/snmplib/snmp_openssl.c
index 3b0eaa8..20b7c55 100644
--- a/snmplib/snmp_openssl.c
+++ b/snmplib/snmp_openssl.c
@@ -1,5 +1,14 @@
 /*
  * snmp_openssl.c
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -303,6 +312,7 @@ _cert_get_extension_id(X509 *ocert, int which, char **buf, int *len, int flags)
     return _cert_get_extension_at(ocert, pos, buf, len, flags);
 }
 
+#ifndef NETSNMP_FEATURE_REMOVE_OPENSSL_CERT_GET_SUBJECTALTNAMES
 /** _cert_get_extension_id_str: get extension field from cert
  * @internal
  */
@@ -325,6 +335,7 @@ _cert_get_extension_id_str(X509 *ocert, int which, char **buf, int *len,
 
     return _cert_get_extension_str_at(ocert, pos, buf, len, flags);
 }
+#endif /* NETSNMP_FEATURE_REMOVE_OPENSSL_CERT_GET_SUBJECTALTNAMES */
 
 static char *
 _extract_oname(const GENERAL_NAME *oname)
@@ -712,9 +723,10 @@ _cert_get_san_type(X509 *ocert, int mapType)
         }
         else if (GEN_IPADD == oname->type) {
             if ((TSNM_tlstmCertSANIpAddress == mapType) ||
-                (TSNM_tlstmCertSANAny == mapType))
+                (TSNM_tlstmCertSANAny == mapType)) {
                 buf = _extract_oname(oname);
                 break;
+            }
         }
         else if (GEN_EMAIL == oname->type) {
             if ((TSNM_tlstmCertSANRFC822Name == mapType) ||
diff --git a/snmplib/snmp_parse_args.c b/snmplib/snmp_parse_args.c
index 6842d0e..abfc53e 100644
--- a/snmplib/snmp_parse_args.c
+++ b/snmplib/snmp_parse_args.c
@@ -59,6 +59,7 @@
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
+#include <net-snmp/library/snmpv3.h>
 #include <net-snmp/library/snmp_parse_args.h>   /* for "internal" definitions */
 #include <net-snmp/utilities.h>
 
@@ -73,8 +74,6 @@
 #include <net-snmp/library/snmpv3.h>
 #include <net-snmp/library/transform_oids.h>
 
-int             random_access = 0;
-
 void
 snmp_parse_args_usage(FILE * outf)
 {
@@ -186,10 +185,6 @@ handle_long_opt(const char *myoptarg)
     free(cp);
 }
 
-extern int      snmpv3_options(char *optarg, netsnmp_session * session,
-                               char **Apsz, char **Xpsz, int argc,
-                               char *const *argv);
-
 int
 netsnmp_parse_args(int argc,
                    char **argv,
@@ -252,7 +247,7 @@ netsnmp_parse_args(int argc,
             break;
 
         case 'H':
-            init_snmp("snmpapp");
+            init_snmp(NETSNMP_APPLICATION_CONFIG_TYPE);
             fprintf(stderr, "Configuration directives understood:\n");
             read_config_print_usage("  ");
             return (NETSNMP_PARSE_ARGS_SUCCESS_EXIT);
@@ -355,6 +350,7 @@ netsnmp_parse_args(int argc,
             tmpcp = strchr(tmpopt, '=');
             if (!tmpcp) {
                 fprintf(stderr, "-T expects a NAME=VALUE pair.\n");
+                free(tmpopt);
                 return (NETSNMP_PARSE_ARGS_ERROR_USAGE);
             }
             *tmpcp++ = '\0';
@@ -647,7 +643,7 @@ netsnmp_parse_args(int argc,
     /*
      * read in MIB database and initialize the snmp library
      */
-    init_snmp("snmpapp");
+    init_snmp(NETSNMP_APPLICATION_CONFIG_TYPE);
 
     /*
      * session default version 
diff --git a/snmplib/snmp_secmod.c b/snmplib/snmp_secmod.c
index 9e60a42..8425cf2 100644
--- a/snmplib/snmp_secmod.c
+++ b/snmplib/snmp_secmod.c
@@ -1,5 +1,14 @@
 /*
  * security service wrapper to support pluggable security models 
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -63,9 +72,9 @@ int
 register_sec_mod(int secmod, const char *modname,
                  struct snmp_secmod_def *newdef)
 {
-    int             result;
+    int             result = 0;
     struct snmp_secmod_list *sptr;
-    char           *othername;
+    char           *othername, *modname2 = NULL;
 
     for (sptr = registered_services; sptr; sptr = sptr->next) {
         if (sptr->securityModel == secmod) {
@@ -79,9 +88,13 @@ register_sec_mod(int secmod, const char *modname,
     sptr->securityModel = secmod;
     sptr->next = registered_services;
     registered_services = sptr;
-    if ((result =
-         se_add_pair_to_slist("snmp_secmods", strdup(modname), secmod))
-        != SE_OK) {
+    modname2 = strdup(modname);
+    if (!modname2)
+        result = SE_NOMEM;
+    else
+        result = se_add_pair_to_slist("snmp_secmods", modname2, secmod);
+    if (result != SE_OK) {
+        SNMP_FREE(modname2);
         switch (result) {
         case SE_NOMEM:
             snmp_log(LOG_CRIT, "snmp_secmod: no memory\n");
diff --git a/snmplib/snmp_transport.c b/snmplib/snmp_transport.c
index ada4781..8f9c290 100644
--- a/snmplib/snmp_transport.c
+++ b/snmplib/snmp_transport.c
@@ -498,7 +498,8 @@ netsnmp_tdomain_transport_full(const char *application,
     const char * const *spec = NULL;
     int                 any_found = 0;
     char buf[SNMP_MAXPATH];
-    char **lspec = 0;
+    char **lspec = NULL;
+    char *tokenized_domain = NULL;
 
     DEBUGMSGTL(("tdomain",
                 "tdomain_transport_full(\"%s\", \"%s\", %d, \"%s\", \"%s\")\n",
@@ -593,13 +594,14 @@ netsnmp_tdomain_transport_full(const char *application,
             else {
                 int commas = 0;
                 const char *cp = default_domain;
-                char *dup = strdup(default_domain);
+                char *ptr = NULL;
+                tokenized_domain = strdup(default_domain);
 
                 while (*++cp) if (*cp == ',') commas++;
                 lspec = calloc(commas+2, sizeof(char *));
                 commas = 1;
-                lspec[0] = strtok(dup, ",");
-                while ((lspec[commas++] = strtok(NULL, ",")))
+                lspec[0] = strtok_r(tokenized_domain, ",", &ptr);
+                while ((lspec[commas++] = strtok_r(NULL, ",", &ptr)))
                     ;
                 spec = (const char * const *)lspec;
             }
@@ -652,7 +654,7 @@ netsnmp_tdomain_transport_full(const char *application,
                 t = match->f_create_from_tstring_new(addr, local, addr2);
             if (t) {
                 if (lspec) {
-                    free(lspec[0]);
+                    free(tokenized_domain);
                     free(lspec);
                 }
                 return t;
@@ -667,7 +669,7 @@ netsnmp_tdomain_transport_full(const char *application,
     if (!any_found)
         snmp_log(LOG_ERR, "No support for any checked transport domain\n");
     if (lspec) {
-        free(lspec[0]);
+        free(tokenized_domain);
         free(lspec);
     }
     return NULL;
diff --git a/snmplib/snmpusm.c b/snmplib/snmpusm.c
index 6a9cec3..24f5c38 100644
--- a/snmplib/snmpusm.c
+++ b/snmplib/snmpusm.c
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 /*
  * snmpusm.c
@@ -2340,6 +2345,9 @@ usm_process_in_msg(int msgProcModel,    /* (UNUSED) */
 #ifdef HAVE_AES
     u_int           net_boots, net_time;
 #endif
+#ifndef NETSNMP_DISABLE_DES
+    int             i;
+#endif
     u_char          signature[BYTESIZE(USM_MAX_KEYEDHASH_LENGTH)];
     size_t          signature_length = BYTESIZE(USM_MAX_KEYEDHASH_LENGTH);
     u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
@@ -2351,7 +2359,7 @@ usm_process_in_msg(int msgProcModel,    /* (UNUSED) */
     u_char          type_value;
     u_char         *end_of_overhead = NULL;
     int             error;
-    int             i, rc = 0;
+    int             rc = 0;
     struct usmStateReference **secStateRef =
         (struct usmStateReference **) secStateRf;
 
@@ -3221,7 +3229,11 @@ init_usm(void)
     def->handle_report = usm_handle_report;
     def->probe_engineid = usm_discover_engineid;
     def->post_probe_engineid = usm_create_user_from_session_hook;
-    register_sec_mod(USM_SEC_MODEL_NUMBER, "usm", def);
+    if (register_sec_mod(USM_SEC_MODEL_NUMBER, "usm", def) != SNMPERR_SUCCESS) {
+        SNMP_FREE(def);
+        snmp_log(LOG_ERR, "could not register usm sec mod\n");
+        return;
+    }
 
     snmp_register_callback(SNMP_CALLBACK_LIBRARY,
                            SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,
@@ -4483,24 +4495,28 @@ usm_parse_create_usmUser(const char *token, char *line)
      * READ: Privacy Type 
      */
     testcase = 0;
-#ifndef NETSNMP_DISABLE_DES
     if (strncmp(cp, "DES", 3) == 0) {
+#ifndef NETSNMP_DISABLE_DES
         memcpy(newuser->privProtocol, usmDESPrivProtocol,
                sizeof(usmDESPrivProtocol));
         testcase = 1;
 	/* DES uses a 128 bit key, 64 bits of which is a salt */
 	privKeyLen = 16;
-    }
+#else
+        config_perror("DES support disabled");
 #endif
-#ifdef HAVE_AES
+    }
     if (strncmp(cp, "AES128", 6) == 0 ||
                strncmp(cp, "AES", 3) == 0) {
+#ifdef HAVE_AES
         memcpy(newuser->privProtocol, usmAESPrivProtocol,
                sizeof(usmAESPrivProtocol));
         testcase = 1;
 	privKeyLen = 16;
-    }
+#else
+        config_perror("AES support not available");
 #endif
+    }
     if (testcase == 0) {
         config_perror("Unknown privacy protocol");
         usm_free_user(newuser);
@@ -4650,8 +4666,10 @@ snmpv3_privtype_conf(const char *word, char *cptr)
 #endif
     if (testcase == 0)
         config_perror("Unknown privacy type");
-    defaultPrivTypeLen = SNMP_DEFAULT_PRIV_PROTOLEN;
-    DEBUGMSGTL(("snmpv3", "set default privacy type: %s\n", cptr));
+    else {
+        defaultPrivTypeLen = SNMP_DEFAULT_PRIV_PROTOLEN;
+        DEBUGMSGTL(("snmpv3", "set default privacy type: %s\n", cptr));
+    }
 }
 
 const oid      *
diff --git a/snmplib/snmpv3.c b/snmplib/snmpv3.c
index 435cafd..49201a6 100644
--- a/snmplib/snmpv3.c
+++ b/snmplib/snmpv3.c
@@ -1,5 +1,14 @@
 /*
  * snmpv3.c
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -135,9 +144,6 @@ snmpv3_secLevel_conf(const char *word, char *cptr)
 }
 
 
-NETSNMP_IMPORT int
-snmpv3_options(char *optarg, netsnmp_session * session, char **Apsz,
-               char **Xpsz, int argc, char *const *argv);
 int
 snmpv3_options(char *optarg, netsnmp_session * session, char **Apsz,
                char **Xpsz, int argc, char *const *argv)
@@ -523,7 +529,7 @@ setup_engineID(u_char ** eidp, const char *text)
     /*
      * Allocate memory and store enterprise ID.
      */
-    if ((bufp = (u_char *) malloc(len)) == NULL) {
+    if ((bufp = (u_char *) calloc(1, len)) == NULL) {
         snmp_log_perror("setup_engineID malloc");
         return -1;
     }
@@ -577,7 +583,8 @@ setup_engineID(u_char ** eidp, const char *text)
 #ifdef AF_INET6
     case ENGINEID_TYPE_IPV6:
         bufp[4] = ENGINEID_TYPE_IPV6;
-        memcpy(bufp + 5, hent->h_addr_list[0], hent->h_length);
+        if (hent)
+            memcpy(bufp + 5, hent->h_addr_list[0], hent->h_length);
         break;
 #endif
 #endif
@@ -1148,13 +1155,11 @@ snmpv3_generate_engineID(size_t * length)
 
     if (newID) {
         *length = snmpv3_get_engineID(newID, engineIDLength);
+        if (*length == 0) {
+            SNMP_FREE(newID);
+            newID = NULL;
+        }
     }
-
-    if (*length == 0) {
-        SNMP_FREE(newID);
-        newID = NULL;
-    }
-
     return newID;
 
 }                               /* end snmpv3_generate_engineID() */
diff --git a/snmplib/snprintf.c b/snmplib/snprintf.c
index 726c4f4..b92fba9 100644
--- a/snmplib/snprintf.c
+++ b/snmplib/snprintf.c
@@ -3,6 +3,11 @@
  * This code is based on code written by Patrick Powell (papowell@astart.com)
  * It may be used for any purpose as long as this notice remains intact
  * on all source code distributions
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 /**************************************************************
@@ -63,7 +68,9 @@
 #include <ctype.h>
 #include <sys/types.h>
 
-# include <stdarg.h>
+#include <stdarg.h>
+#include "snprintf.h"
+
 # define VA_LOCAL_DECL   va_list ap
 # define VA_START(f)     va_start(ap, f)
 # define VA_SHIFT(v,t)  ;       /* no-op for ANSI */
@@ -75,10 +82,6 @@
 #define LDOUBLE double
 #endif
 
-int             snprintf(char *str, size_t count, const char *fmt, ...);
-int             vsnprintf(char *str, size_t count, const char *fmt,
-                          va_list arg);
-
 static void     dopr(char *buffer, size_t maxlen, const char *format,
                      va_list args);
 static void     fmtstr(char *buffer, size_t * currlen, size_t maxlen,
@@ -243,7 +246,7 @@ dopr(char *buffer, size_t maxlen, const char *format, va_list args)
             case 'd':
             case 'i':
                 if (cflags == DP_C_SHORT)
-                    value = va_arg(args, short int);
+                    value = va_arg(args, long);
                 else if (cflags == DP_C_LONG)
                     value = va_arg(args, long int);
                 else
@@ -254,7 +257,7 @@ dopr(char *buffer, size_t maxlen, const char *format, va_list args)
             case 'o':
                 flags |= DP_F_UNSIGNED;
                 if (cflags == DP_C_SHORT)
-                    value = va_arg(args, unsigned short int);
+                    value = va_arg(args, unsigned long);
                 else if (cflags == DP_C_LONG)
                     value = va_arg(args, unsigned long int);
                 else
@@ -265,7 +268,7 @@ dopr(char *buffer, size_t maxlen, const char *format, va_list args)
             case 'u':
                 flags |= DP_F_UNSIGNED;
                 if (cflags == DP_C_SHORT)
-                    value = va_arg(args, unsigned short int);
+                    value = va_arg(args, unsigned long);
                 else if (cflags == DP_C_LONG)
                     value = va_arg(args, unsigned long int);
                 else
@@ -278,7 +281,7 @@ dopr(char *buffer, size_t maxlen, const char *format, va_list args)
             case 'x':
                 flags |= DP_F_UNSIGNED;
                 if (cflags == DP_C_SHORT)
-                    value = va_arg(args, unsigned short int);
+                    value = va_arg(args, unsigned long);
                 else if (cflags == DP_C_LONG)
                     value = va_arg(args, unsigned long int);
                 else
@@ -379,10 +382,11 @@ dopr(char *buffer, size_t maxlen, const char *format, va_list args)
 
 static void
 fmtstr(char *buffer, size_t * currlen, size_t maxlen,
-       char *value, int flags, int min, int max)
+       char *valuein, int flags, int min, int max)
 {
     int             padlen, strln;      /* amount to pad */
     int             cnt = 0;
+    const char     *value = valuein;
 
     if (value == 0) {
         value = "<NULL>";
@@ -524,7 +528,7 @@ abs_val(LDOUBLE value)
 }
 
 static          LDOUBLE
-pow10(int exp)
+ns_pow10(int exp)
 {
     LDOUBLE         result = 1;
 
@@ -537,7 +541,7 @@ pow10(int exp)
 }
 
 static long
-round(LDOUBLE value)
+ns_round(LDOUBLE value)
 {
     long            intpart;
 
@@ -599,11 +603,11 @@ fmtfp(char *buffer, size_t * currlen, size_t maxlen,
      * We "cheat" by converting the fractional part to integer by
      * * multiplying by a factor of 10
      */
-    fracpart = round((pow10(max)) * (ufvalue - intpart));
+    fracpart = ns_round((ns_pow10(max)) * (ufvalue - intpart));
 
-    if (fracpart >= pow10(max)) {
+    if (fracpart >= ns_pow10(max)) {
         intpart++;
-        fracpart -= pow10(max);
+        fracpart -= ns_pow10(max);
     }
 #ifdef DEBUG_SNPRINTF
     dprint(1,
diff --git a/snmplib/snprintf.h b/snmplib/snprintf.h
new file mode 100644
index 0000000..c9a1eba
--- /dev/null
+++ b/snmplib/snprintf.h
@@ -0,0 +1,2 @@
+int snprintf(char *str, size_t count, const char *fmt, ...);
+int vsnprintf(char *str, size_t count, const char *fmt, va_list arg);
diff --git a/snmplib/system.c b/snmplib/system.c
index cc7cf3c..65b7d97 100644
--- a/snmplib/system.c
+++ b/snmplib/system.c
@@ -37,6 +37,11 @@ SOFTWARE.
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 /*
  * System dependent routines go here
@@ -212,6 +217,8 @@ netsnmp_feature_child_of(calculate_sectime_diff, system_all)
 static void
 _daemon_prep(int stderr_log)
 {
+    int fd;
+
     /* Avoid keeping any directory in use. */
     chdir("/");
 
@@ -222,16 +229,17 @@ _daemon_prep(int stderr_log)
      * Close inherited file descriptors to avoid
      * keeping unnecessary references.
      */
-    close(0);
-    close(1);
-    close(2);
+    close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO);
 
     /*
      * Redirect std{in,out,err} to /dev/null, just in case.
      */
-    open("/dev/null", O_RDWR);
-    dup(0);
-    dup(0);
+    if ((fd = open("/dev/null", O_RDWR)) >= 0) {
+        dup2(fd, STDOUT_FILENO);
+        dup2(fd, STDERR_FILENO);
+    }
 }
 #endif
 
@@ -283,7 +291,11 @@ netsnmp_daemonize(int quit_immediately, int stderr_log)
      * Fork to return control to the invoking process and to
      * guarantee that we aren't a process group leader.
      */
+#if HAVE_FORKALL
+    i = forkall();
+#else
     i = fork();
+#endif
     if (i != 0) {
         /* Parent. */
         DEBUGMSGT(("daemonize","first fork returned %d.\n", i));
@@ -305,7 +317,12 @@ netsnmp_daemonize(int quit_immediately, int stderr_log)
         /*
          * Fork to let the process/session group leader exit.
          */
-        if ((i = fork()) != 0) {
+#if HAVE_FORKALL
+	i = forkall();
+#else
+	i = fork();
+#endif
+        if (i != 0) {
             DEBUGMSGT(("daemonize","second fork returned %d.\n", i));
             if(i == -1) {
                 snmp_log(LOG_ERR,"second fork failed (errno %d) in "
@@ -924,9 +941,18 @@ netsnmp_gethostbyname(const char *name)
     if (hp == NULL) {
         DEBUGMSGTL(("dns:gethostbyname",
                     "couldn't resolve %s\n", name));
-    } else if (hp->h_addrtype != AF_INET) {
+    } else if (hp->h_addrtype != AF_INET
+#ifdef AF_INET6
+               && hp->h_addrtype != AF_INET6
+#endif
+        ) {
+#ifdef AF_INET6
+        DEBUGMSGTL(("dns:gethostbyname",
+                    "warning: response for %s not AF_INET/AF_INET6!\n", name));
+#else
         DEBUGMSGTL(("dns:gethostbyname",
                     "warning: response for %s not AF_INET!\n", name));
+#endif
     } else {
         DEBUGMSGTL(("dns:gethostbyname",
                     "%s resolved okay\n", name));
@@ -1112,7 +1138,7 @@ calculate_sectime_diff(const struct timeval *now, const struct timeval *then)
     struct timeval  diff;
 
     NETSNMP_TIMERSUB(now, then, &diff);
-    return diff.tv_sec + (diff.tv_usec >= 500000L);
+    return (u_int)(diff.tv_sec + (diff.tv_usec >= 500000L));
 }
 #endif /* NETSNMP_FEATURE_REMOVE_CALCULATE_SECTIME_DIFF */
 
diff --git a/snmplib/transports/snmpIPv6BaseDomain.c b/snmplib/transports/snmpIPv6BaseDomain.c
index 1ad6888..d1b18cf 100644
--- a/snmplib/transports/snmpIPv6BaseDomain.c
+++ b/snmplib/transports/snmpIPv6BaseDomain.c
@@ -1,4 +1,13 @@
 /* IPV6 base transport support functions
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -60,6 +69,7 @@ static const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
 #endif
 
 
+#if HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
 static unsigned
 netsnmp_if_nametoindex(const char *ifname)
 {
@@ -84,26 +94,43 @@ netsnmp_if_indextoname(unsigned ifindex, char *ifname)
     return NULL;
 #endif
 }
+#endif /* HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID */
 
 char *
 netsnmp_ipv6_fmtaddr(const char *prefix, netsnmp_transport *t,
                      void *data, int len)
 {
     struct sockaddr_in6 *to = NULL;
+    char scope_id[IF_NAMESIZE + 1] = "";
+    char port[6];
     char addr[INET6_ADDRSTRLEN];
-    char tmp[INET6_ADDRSTRLEN + 18];
+    /** tmp buffer size */
+    size_t tmplen = sizeof(addr) + sizeof(scope_id) + sizeof(port) +
+        strlen(prefix) + 10; /* 10 is spaces/separators + some wiggle room */
+    char *tmp = malloc(tmplen);
+
+    if (NULL == tmp)
+        return NULL;
 
     DEBUGMSGTL(("netsnmp_ipv6", "fmtaddr: t = %p, data = %p, len = %d\n", t,
                 data, len));
     if (data != NULL && len == sizeof(struct sockaddr_in6)) {
         to = (struct sockaddr_in6 *) data;
+    } else if (data != NULL && len == sizeof(netsnmp_indexed_addr_pair)) {
+        netsnmp_indexed_addr_pair *addr_pair =
+            (netsnmp_indexed_addr_pair *) data;
+        to = (struct sockaddr_in6 *) &(addr_pair->remote_addr);
     } else if (t != NULL && t->data != NULL) {
         to = (struct sockaddr_in6 *) t->data;
     }
     if (to == NULL) {
-        snprintf(tmp, sizeof(tmp), "%s: unknown", prefix);
+        strlcpy(tmp, prefix, tmplen);
+        strlcat(tmp, ": unknown", tmplen);
+    } else if ( t && t->flags & NETSNMP_TRANSPORT_FLAG_HOSTNAME ) {
+	struct hostent *host;
+	host = netsnmp_gethostbyaddr((char *)&to->sin6_addr, sizeof(struct in6_addr), AF_INET6);
+	return (host ? strdup(host->h_name) : NULL);
     } else {
-        char scope_id[IF_NAMESIZE + 1] = "";
 
 #if defined(HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID)
 	if (to->sin6_scope_id
@@ -111,12 +138,17 @@ netsnmp_ipv6_fmtaddr(const char *prefix, netsnmp_transport *t,
             scope_id[0] = '%';
         }
 #endif
-        snprintf(tmp, sizeof(tmp), "%s: [%s%s]:%hu", prefix,
-                 inet_ntop(AF_INET6, (void *) &(to->sin6_addr), addr,
-                           INET6_ADDRSTRLEN), scope_id, ntohs(to->sin6_port));
+        strlcpy(tmp, prefix, tmplen);
+        inet_ntop(AF_INET6, (void *) &(to->sin6_addr), addr, sizeof(addr));
+        strlcat(tmp, ": [", tmplen);
+        strlcat(tmp, addr, tmplen);
+        strlcat(tmp, scope_id, tmplen);
+        strlcat(tmp, "]:", tmplen);
+        snprintf(port,sizeof(port), "%hu", ntohs(to->sin6_port));
+        strlcat(tmp, port, tmplen);
     }
-    tmp[sizeof(tmp)-1] = '\0';
-    return strdup(tmp);
+    tmp[tmplen-1] = '\0';
+    return tmp;
 }
 
 int
@@ -199,12 +231,16 @@ netsnmp_sockaddr_in6_2(struct sockaddr_in6 *addr,
 	       *
 	       */
 	        char *scope_id;
+#if HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
 	        unsigned int if_index = 0;
+#endif
                 *cp = '\0';
 		scope_id = strchr(peername + 1, '%');
 		if (scope_id != NULL) {
 		    *scope_id = '\0';
+#if HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
 		    if_index = netsnmp_if_nametoindex(scope_id + 1);
+#endif
 		}
                 if (*(cp + 1) == ':') {
                     portno = atoi(cp+2);
@@ -218,6 +254,7 @@ netsnmp_sockaddr_in6_2(struct sockaddr_in6 *addr,
                             addr->sin6_port = htons((u_short)portno);
                         } else {
                             DEBUGMSGTL(("netsnmp_sockaddr_in6_2", "invalid port number: %d", portno));
+                            free(peername);
                             return 0;
                         }
 
@@ -255,12 +292,16 @@ netsnmp_sockaddr_in6_2(struct sockaddr_in6 *addr,
         cp = strrchr(peername, ':');
         if (cp != NULL) {
 	    char *scope_id;
+#if HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
 	    unsigned int if_index = 0;
+#endif
 	    *cp = '\0';
 	    scope_id = strchr(peername + 1, '%');
 	    if (scope_id != NULL) {
 	        *scope_id = '\0';
+#if HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
 	        if_index = netsnmp_if_nametoindex(scope_id + 1);
+#endif
 	    }
             portno = atoi(cp + 1);
             if (portno != 0 &&
@@ -273,6 +314,7 @@ netsnmp_sockaddr_in6_2(struct sockaddr_in6 *addr,
                     addr->sin6_port = htons((u_short)portno);
                 } else {
                     DEBUGMSGTL(("netsnmp_sockaddr_in6_2", "invalid port number: %d", portno));
+                    free(peername);
                     return 0;
                 }
 
@@ -312,6 +354,7 @@ netsnmp_sockaddr_in6_2(struct sockaddr_in6 *addr,
                     addr->sin6_port = htons((u_short)portno);
                 } else {
                     DEBUGMSGTL(("netsnmp_sockaddr_in6_2", "invalid port number: %d", portno));
+                    free(peername);
                     return 0;
                 }
 
diff --git a/snmplib/transports/snmpTCPIPv6Domain.c b/snmplib/transports/snmpTCPIPv6Domain.c
index d2e0a2d..3b29513 100644
--- a/snmplib/transports/snmpTCPIPv6Domain.c
+++ b/snmplib/transports/snmpTCPIPv6Domain.c
@@ -309,12 +309,6 @@ netsnmp_tcp6_transport(struct sockaddr_in6 *addr, int local)
     return t;
 }
 
-/*
- * Not extern but still defined in snmpUDPIPv6Domain.c
- */
-extern int
-netsnmp_sockaddr_in6_2(struct sockaddr_in6*, const char*, const char*);
-
 netsnmp_transport *
 netsnmp_tcp6_create_tstring(const char *str, int local,
 			    const char *default_target)
diff --git a/snmplib/transports/snmpTLSBaseDomain.c b/snmplib/transports/snmpTLSBaseDomain.c
index c54d6ad..782272c 100644
--- a/snmplib/transports/snmpTLSBaseDomain.c
+++ b/snmplib/transports/snmpTLSBaseDomain.c
@@ -116,6 +116,11 @@ int verify_callback(int ok, X509_STORE_CTX *ctx) {
             return 0;
         }
 
+#if 0
+        /*
+         * This code is unreachable because of the return statements above.
+         * Comment it out to avoid that Coverity complains about this code.
+         */
         if (0 == depth && verify_info &&
             (verify_info->flags & VRFY_PARENT_WAS_OK)) {
             DEBUGMSGTL(("tls_x509:verify", "verify_callback called with: ok=%d ctx=%p depth=%d err=%i:%s\n", ok, ctx, depth, err, X509_verify_cert_error_string(err)));
@@ -123,6 +128,7 @@ int verify_callback(int ok, X509_STORE_CTX *ctx) {
             SNMP_FREE(fingerprint);
             return 1; /* we'll check the hostname later at this level */
         }
+#endif
     }
 
     if (0 == ok)
diff --git a/snmplib/transports/snmpTLSTCPDomain.c b/snmplib/transports/snmpTLSTCPDomain.c
index 473d02c..d9393f2 100644
--- a/snmplib/transports/snmpTLSTCPDomain.c
+++ b/snmplib/transports/snmpTLSTCPDomain.c
@@ -153,7 +153,9 @@ netsnmp_tlstcp_recv(netsnmp_transport *t, void *buf, int size,
                  "tlstcp received an invalid invocation with missing data\n");
         DEBUGMSGTL(("tlstcp", "recvfrom fd %d err %d (\"%s\")\n",
                     (t ? t->sock : -1), errno, strerror(errno)));
-        DEBUGMSGTL(("tlstcp", "  tdata = %p\n", t->data));
+        if (t)
+            DEBUGMSGTL(("tlstcp", "  tdata = %p", t->data));
+        DEBUGMSGTL(("tlstcp", "\n"));
         return -1;
     }
         
diff --git a/snmplib/transports/snmpUDPBaseDomain.c b/snmplib/transports/snmpUDPBaseDomain.c
index 8497f71..5ece0fb 100644
--- a/snmplib/transports/snmpUDPBaseDomain.c
+++ b/snmplib/transports/snmpUDPBaseDomain.c
@@ -1,4 +1,13 @@
 /* UDP base transport support functions
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -234,7 +243,7 @@ int netsnmp_udpbase_sendto(int fd, struct in_addr *srcip, int if_index,
 {
 #if !defined(WIN32)
     struct iovec iov;
-    struct msghdr m = { 0 };
+    struct msghdr m = { NULL };
     char          cmsg[CMSG_SPACE(cmsg_data_size)];
     int           rc;
 
@@ -444,13 +453,21 @@ netsnmp_udpbase_send(netsnmp_transport *t, void *buf, int size,
     netsnmp_indexed_addr_pair *addr_pair = NULL;
     struct sockaddr *to = NULL;
 
-    if (opaque != NULL && *opaque != NULL &&
+    if (opaque != NULL && *opaque != NULL && NULL != olength &&
         ((*olength == sizeof(netsnmp_indexed_addr_pair) ||
           (*olength == sizeof(struct sockaddr_in))))) {
         addr_pair = (netsnmp_indexed_addr_pair *) (*opaque);
     } else if (t != NULL && t->data != NULL &&
                 t->data_length == sizeof(netsnmp_indexed_addr_pair)) {
         addr_pair = (netsnmp_indexed_addr_pair *) (t->data);
+    } else {
+        int len = -1;
+        if (opaque != NULL && *opaque != NULL && NULL != olength)
+            len = *olength;
+        else if (t != NULL && t->data != NULL)
+            len = t->data_length;
+        snmp_log(LOG_ERR, "unknown addr type of size %d\n", len);
+        return SNMPERR_GENERR;
     }
 
     to = &addr_pair->remote_addr.sa;
diff --git a/snmplib/transports/snmpUDPDomain.c b/snmplib/transports/snmpUDPDomain.c
index a0abd8c..1cf6416 100644
--- a/snmplib/transports/snmpUDPDomain.c
+++ b/snmplib/transports/snmpUDPDomain.c
@@ -80,11 +80,6 @@ static netsnmp_tdomain udpDomain;
  */
 typedef netsnmp_indexed_addr_pair netsnmp_udp_addr_pair;
 
-/*
- * not static, since snmpUDPIPv6Domain needs it, but not public, either.
- * (ie don't put it in a public header.)
- */
-void _netsnmp_udp_sockopt_set(int fd, int server);
 int
 netsnmp_sockaddr_in2(struct sockaddr_in *addr,
                      const char *inpeername, const char *default_target);
diff --git a/snmplib/transports/snmpUDPIPv4BaseDomain.c b/snmplib/transports/snmpUDPIPv4BaseDomain.c
index 8c0fb05..9a66ecb 100644
--- a/snmplib/transports/snmpUDPIPv4BaseDomain.c
+++ b/snmplib/transports/snmpUDPIPv4BaseDomain.c
@@ -1,4 +1,13 @@
 /* IPV4 base transport support functions
+ *
+ * Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -179,12 +188,13 @@ netsnmp_udpipv4base_transport(struct sockaddr_in *addr, int local)
             rc = bind(t->sock, (struct sockaddr *)&client_addr,
                   sizeof(struct sockaddr));
             if ( rc != 0 ) {
-                DEBUGMSGTL(("netsnmp_udpbase", "failed to bind for clientaddr: %d %s\n",
-                            errno, strerror(errno)));
+                snmp_log(LOG_ERR, "Cannot bind for clientaddr %s: %s\n",
+                            client_socket, strerror(errno));
                 netsnmp_socketbase_close(t);
                 netsnmp_transport_free(t);
                 return NULL;
             }
+            memset(&addr_pair, 0, sizeof(netsnmp_indexed_addr_pair));
             local_addr_len = sizeof(addr_pair.local_addr);
             rc2 = getsockname(t->sock, (struct sockaddr*)&addr_pair.local_addr,
                               &local_addr_len);
diff --git a/snmplib/transports/snmpUDPIPv6Domain.c b/snmplib/transports/snmpUDPIPv6Domain.c
index 18de876..c12974f 100644
--- a/snmplib/transports/snmpUDPIPv6Domain.c
+++ b/snmplib/transports/snmpUDPIPv6Domain.c
@@ -74,12 +74,6 @@ oid netsnmp_UDPIPv6Domain[] = { TRANSPORT_DOMAIN_UDP_IPV6 };
 static netsnmp_tdomain udp6Domain;
 
 /*
- * from snmpUDPDomain. not static, but not public, either.
- * (ie don't put it in a public header.)
- */
-extern void _netsnmp_udp_sockopt_set(int fd, int server);
-
-/*
  * Return a string representing the address in data, or else the "far end"
  * address if data is NULL.  
  */
@@ -266,6 +260,28 @@ netsnmp_udp6_transport(struct sockaddr_in6 *addr, int local)
         return NULL;
 #endif /* NETSNMP_NO_LISTEN_SUPPORT */
     } else {
+        char           *client_socket = NULL;
+        /*
+         * This is a client session.  If we've been given a
+         * client address to send from, then bind to that.
+         * Otherwise the send will use "something sensible".
+         */
+
+        client_socket = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
+                                    NETSNMP_DS_LIB_CLIENT_ADDR);
+        if (client_socket) {
+            struct sockaddr_in6 client_addr;
+            netsnmp_sockaddr_in6_2(&client_addr, client_socket, NULL);
+            rc = bind(t->sock, (struct sockaddr *)&client_addr,
+                              sizeof(struct sockaddr_in6));
+            if ( rc != 0 ) {
+                DEBUGMSGTL(("netsnmp_udp6", "failed to bind for clientaddr: %d %s\n",
+                                 errno, strerror(errno)));
+                netsnmp_socketbase_close(t);
+                netsnmp_transport_free(t);
+                return NULL;
+            }
+        }
         /*
          * This is a client session.  Save the address in the
          * transport-specific data pointer for later use by netsnmp_udp6_send.
diff --git a/snmplib/ucd_compat.c b/snmplib/ucd_compat.c
index 64c1e13..6adc17b 100644
--- a/snmplib/ucd_compat.c
+++ b/snmplib/ucd_compat.c
@@ -3,6 +3,8 @@
  * previous versions of the UCD library only.
  */
 
+#define UCD_COMPATIBLE
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
@@ -12,6 +14,8 @@
 #include <net-snmp/library/mib.h>	/* for OID O/P format enums */
 #include <net-snmp/library/ucd_compat.h>
 
+#include <ucd-snmp/default_store.h>
+
 netsnmp_feature_child_of(ucd_compatibility, libnetsnmp)
 
 #ifndef NETSNMP_FEATURE_REMOVE_UCD_COMPATIBILITY
diff --git a/snmplib/vacm.c b/snmplib/vacm.c
index c639785..0b14568 100644
--- a/snmplib/vacm.c
+++ b/snmplib/vacm.c
@@ -7,6 +7,11 @@
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
+ *
+ * Portions of this file are copyrighted by:
+ * Copyright (c) 2016 VMware, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
  */
 
 /*
@@ -177,7 +182,7 @@ vacm_parse_config_view(const char *token, const char *line)
     len = sizeof(view.viewName);
     line =
         read_config_read_octet_string(line, (u_char **) & viewName, &len);
-    view.viewSubtreeLen = MAX_OID_LEN;
+    view.viewSubtreeLen = MAX_OID_LEN + 1;
     line =
         read_config_read_objid_const(line, (oid **) & viewSubtree,
                                &view.viewSubtreeLen);
diff --git a/snmplib/winservice.c b/snmplib/winservice.c
index bc27f8c..a346315 100644
--- a/snmplib/winservice.c
+++ b/snmplib/winservice.c
@@ -159,7 +159,8 @@ RegisterService (LPCTSTR lpszServiceName, LPCTSTR lpszServiceDisplayName,
     /*
      * Generate the command to be executed by the SCM 
      */
-    _sntprintf (szServiceCommand, CountOf(szServiceCommand), _T("%s %s"), szServicePath, _T ("-service"));
+    _sntprintf(szServiceCommand, CountOf(szServiceCommand), _T("\"%s\" %s"),
+               szServicePath, _T("-service"));
 
     /*
      * Create the desired service 
@@ -631,7 +632,7 @@ ProcessError (WORD eventLogType, LPCTSTR pszMessage, int useGetLastError, int qu
 static BOOL
 UpdateServiceStatus (DWORD dwStatus, DWORD dwErrorCode, DWORD dwWaitHint)
 {
-  DWORD static dwCheckpoint = 1;
+  static DWORD dwCheckpoint = 1;
   DWORD dwControls = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
   if (g_fRunningAsService == FALSE)
     return FALSE;
diff --git a/testing/Makefile.in b/testing/Makefile.in
index 2a64137..79d069d 100644
--- a/testing/Makefile.in
+++ b/testing/Makefile.in
@@ -31,6 +31,7 @@ all:
 	@echo "Also see the RUNFULLTESTS script for details"
 
 test:
+	@$(srcdir)/check_for_pskill
 	@if test "x$(PERL)" = "x" \
 	         -o "x@PERL_SYSTEM_INVOKES_POSIX_SHELL@" != xyes \
 		 || { ! $(PERL) -e 'require TAP::Harness;' >/dev/null 2>&1 \
diff --git a/testing/RUNFULLTESTS b/testing/RUNFULLTESTS
index 40a40b8..f901f08 100755
--- a/testing/RUNFULLTESTS
+++ b/testing/RUNFULLTESTS
@@ -3,6 +3,7 @@
 use Getopt::Long;
 #use Data::Dumper;
 use File::Basename;
+use File::Spec;
 use Cwd qw(abs_path);
 use strict;
 
@@ -69,6 +70,12 @@ if (!$ENV{'MIBDIRS'}) {
     $ENV{'MIBDIRS'} = "$opts{srcdir}/mibs";
 }
 
+my $cfp_path = File::Spec->catfile(dirname(abs_path($0)), "check_for_pskill");
+my $rc = `$cfp_path`;
+if ($rc != 0) {
+    die "$cfp_path failed with error code $rc\n";
+}
+
 ########################################
 # Protection measures
 $ENV{'SNMPCONFPATH'} = "/dev/null";
diff --git a/testing/RUNTESTS b/testing/RUNTESTS
index 4933307..6715831 100755
--- a/testing/RUNTESTS
+++ b/testing/RUNTESTS
@@ -10,19 +10,7 @@ if [ "x$MIBDIRS" = "x" ]; then
     export MIBDIRS
 fi
 
-# Make sure MinGW / MSYS users have the pskill.exe program to stop the agent and
-# snmptrapd
-if [ "x$OSTYPE" = "xmsys" ]; then
-    for e in pskill.exe pslist.exe; do
-	if [ "x`type $e 2>/dev/null`" = "x" ]; then
-	    echo "Could not find $e. Aborting tests."
-	    echo "$e can be installed as follows:"
-	    echo "- Download PSTools.zip from http://technet.microsoft.com/en-us/sysinternals/default."
-	    echo "- Copy $e to C:\\MinGW\\msys\\1.0\\bin."
-	    exit 1
-	fi
-    done
-fi
+"`dirname "$0"`/check_for_pskill"
 
 success_count=0
 failed_count=0
diff --git a/testing/check_for_pskill b/testing/check_for_pskill
new file mode 100755
index 0000000..613d217
--- /dev/null
+++ b/testing/check_for_pskill
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+# Make sure MinGW / MSYS users have the pskill.exe program to stop the agent and
+# snmptrapd
+if [ "x$OSTYPE" = "xmsys" ]; then
+    for e in pskill.exe pslist.exe; do
+	if [ "x`type $e 2>/dev/null`" = "x" ]; then
+	    echo "Could not find $e. Aborting tests."
+	    echo "$e can be installed as follows:"
+	    echo -- "- Download PSTools.zip from http://technet.microsoft.com/en-us/sysinternals/default."
+	    echo -- "- Copy $e to C:\\MinGW\\msys\\1.0\\bin."
+	    exit 1
+	fi
+    done
+fi
diff --git a/testing/fulltests/default/Sv3vacmconfigMD5 b/testing/fulltests/default/Sv3vacmconfigMD5
new file mode 100644
index 0000000..7f0c880
--- /dev/null
+++ b/testing/fulltests/default/Sv3vacmconfigMD5
@@ -0,0 +1,28 @@
+#!/bin/sh
+
+# generically set up the user "initial1" and "initial2"  for snmp v3
+# access to the agent.
+
+# Configuration:
+#initial1 can access .1.3.6.1.2.1.1.1, deny others
+#initial2 can access all except .1.3.6.1.2.1.1.1
+
+# XXX: do autoselection of supported algorithms
+SKIPIF NETSNMP_DISABLE_MD5
+SKIPIFNOT NETSNMP_SECMOD_USM
+
+CONFIGAGENT [snmp] persistentdir $SNMP_TMP_PERSISTENTDIR
+
+CONFIGAGENT createUser initial1 MD5 initial_test_pass_auth
+CONFIGAGENT createUser initial2 MD5 initial_test_pass_auth
+
+
+CONFIGAGENT group   testcommunitygroup1  usm     initial1
+CONFIGAGENT group   testcommunitygroup2  usm     initial2
+
+CONFIGAGENT view    system1     included .1.3.6.1.2.1.1.1
+CONFIGAGENT view    system2     included .1
+CONFIGAGENT view    system2     excluded .1.3.6.1.2.1.1.1
+CONFIGAGENT 'access  testcommunitygroup1  "" any auth exact system1 none none'
+CONFIGAGENT 'access  testcommunitygroup2  "" any auth exact system2 none none'
+
diff --git a/testing/fulltests/default/T000configure_simple b/testing/fulltests/default/T000configure_simple
index 2e2b4ef..d3cd6db 100644
--- a/testing/fulltests/default/T000configure_simple
+++ b/testing/fulltests/default/T000configure_simple
@@ -14,7 +14,7 @@ HEADER Checking the Net-SNMP configure script validity
 
 VERSIONNEEDED=`cat $versionfile`
 
-CHECKORDIE "^# Generated by GNU Autoconf $VERSIONNEEDED for Net-SNMP " \
+CHECKORDIE "^# Generated by GNU Autoconf $VERSIONNEEDED for Net-SNMP" \
 	"$configurefile"
 SAVE_RESULTS
 
diff --git a/testing/fulltests/default/T023snmpv3getMD5DES_simple b/testing/fulltests/default/T023snmpv3getMD5DES_simple
index 000478a..633a810 100755
--- a/testing/fulltests/default/T023snmpv3getMD5DES_simple
+++ b/testing/fulltests/default/T023snmpv3getMD5DES_simple
@@ -7,6 +7,7 @@ HEADER SNMPv3 get using MD5/DES of .1.3.6.1.2.1.1.3.0
 SKIPIFNOT NETSNMP_CAN_DO_CRYPTO
 SKIPIFNOT NETSNMP_ENABLE_SCAPI_AUTHPRIV
 SKIPIF NETSNMP_DISABLE_MD5
+SKIPIF NETSNMP_DISABLE_DES
 
 #
 # Begin test
diff --git a/testing/fulltests/default/T065agentextend_sh_simple b/testing/fulltests/default/T065agentextend_sh_simple
index 52ea826..c3be1d7 100644
--- a/testing/fulltests/default/T065agentextend_sh_simple
+++ b/testing/fulltests/default/T065agentextend_sh_simple
@@ -34,7 +34,7 @@ number1=111
 number2=222
 rm -f $echo_two_numbers
 cat <<EOF >$echo_two_numbers
-#!$(if [ "x$MSYS_SH" != x ]; then echo "$MSYS_SH"; else echo /bin/sh; fi)
+#!${MSYS_SH:-/bin/sh}
 echo $number1
 echo $number2
 EOF
diff --git a/testing/fulltests/default/T067passpersist_simple b/testing/fulltests/default/T067passpersist_simple
index 40f1333..970fa8a 100644
--- a/testing/fulltests/default/T067passpersist_simple
+++ b/testing/fulltests/default/T067passpersist_simple
@@ -44,6 +44,8 @@ CHECKORDIE "NET-SNMP-PASS-MIB::netSnmpPassTimeTicks.0 = Timeticks: (363136200) 4
 CHECKORDIE "NET-SNMP-PASS-MIB::netSnmpPassIpAddress.0 = IpAddress: 127.0.0.1"
 CHECKORDIE "NET-SNMP-PASS-MIB::netSnmpPassCounter.0 = Counter32: 1"
 CHECKORDIE "NET-SNMP-PASS-MIB::netSnmpPassGauge.0 = Gauge32: 42"
+CHECKORDIE "NET-SNMP-PASS-MIB::netSnmpPassCounter64.0 = Counter64: 9223372036854775806"
+CHECKORDIE "NET-SNMP-PASS-MIB::netSnmpPassInteger64.0 = Opaque: Int64: 9223372036854775807"
 
 #COMMENT A couple of spot checks of GET requests.
 CAPTURE "$SNMPGET $SNMP_FLAGS -$snmp_version -c $TESTCOMMUNITY $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT NET-SNMP-PASS-MIB::netSnmpPassInteger.1"
diff --git a/testing/fulltests/default/T069exechup_simple b/testing/fulltests/default/T069exechup_simple
new file mode 100644
index 0000000..b29e6b8
--- /dev/null
+++ b/testing/fulltests/default/T069exechup_simple
@@ -0,0 +1,67 @@
+#!/bin/sh
+
+. ../support/simple_eval_tools.sh
+
+HEADER "eval configuration constency after SIGHUP"
+
+SKIPIFNOT USING_UCD_SNMP_EXTENSIBLE_MODULE
+SKIPIF NETSNMP_DISABLE_SNMPV2C
+
+# make sure snmpset and snmpwalk can be executed
+SNMPSET="${builddir}/apps/snmpset"
+[ -x "$SNMPSET" ] || SKIP snmpset not compiled
+SNMPWALK="${builddir}/apps/snmpwalk"
+[ -x "$SNMPWALK" ] || SKIP snmpwalk not compiled
+
+snmp_version=v2c
+snmp_write_access='all'
+TESTCOMMUNITY=testcommunity
+. ./Sv2cconfig
+
+#
+# Begin test
+#
+if [ "x$OSTYPE" = xmsys ]; then
+    cmd1="true"
+    cmd2="false"
+    echo="echo"
+else
+    cmd1="$(which true)"
+    cmd2="$(which false)"
+    echo="$(which echo)"
+fi
+CONFIGAGENT exec    true-command    $cmd1
+CONFIGAGENT exec    false-command   $cmd2
+
+STARTAGENT
+
+# Check a full walk of UCD-SNMP-MIB::extTable
+CAPTURE "$SNMPWALK $SNMP_FLAGS -$snmp_version -c $TESTCOMMUNITY $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT UCD-SNMP-MIB::extEntry"
+CHECK 'UCD-SNMP-MIB::extNames.1 = STRING: true-command$'
+CHECK 'UCD-SNMP-MIB::extCommand.1 = STRING: '"$cmd1"
+CHECK 'UCD-SNMP-MIB::extResult.1 = INTEGER: 0$'
+CHECK 'UCD-SNMP-MIB::extOutput.1 = STRING: $'
+CHECK 'UCD-SNMP-MIB::extNames.2 = STRING: false-command$'
+CHECK 'UCD-SNMP-MIB::extCommand.2 = STRING: '"$cmd2"'$'
+CHECK 'UCD-SNMP-MIB::extResult.2 = INTEGER: 1$'
+CHECK 'UCD-SNMP-MIB::extOutput.2 = STRING: $'
+
+# Send HUP
+HUPAGENT
+
+# Check a full walk of UCD-SNMP-MIB::extTable
+CAPTURE "$SNMPWALK $SNMP_FLAGS -$snmp_version -c $TESTCOMMUNITY $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT UCD-SNMP-MIB::extEntry"
+CHECK 'UCD-SNMP-MIB::extNames.1 = STRING: true-command$'
+CHECK 'UCD-SNMP-MIB::extCommand.1 = STRING: '"$cmd1"
+CHECK 'UCD-SNMP-MIB::extResult.1 = INTEGER: 0$'
+CHECK 'UCD-SNMP-MIB::extOutput.1 = STRING: $'
+CHECK 'UCD-SNMP-MIB::extNames.2 = STRING: false-command$'
+CHECK 'UCD-SNMP-MIB::extCommand.2 = STRING: '"$cmd2"'$'
+CHECK 'UCD-SNMP-MIB::extResult.2 = INTEGER: 1$'
+CHECK 'UCD-SNMP-MIB::extOutput.2 = STRING: $'
+# We shouldn't have more rows.
+CHECKANDDIE 'UCD-SNMP-MIB::extNames.3'
+CHECKANDDIE 'UCD-SNMP-MIB::extNames.4'
+
+STOPAGENT
+FINISHED
diff --git a/testing/fulltests/default/T124proxywalkself_simple b/testing/fulltests/default/T124proxywalkself_simple
new file mode 100644
index 0000000..b8178c8
--- /dev/null
+++ b/testing/fulltests/default/T124proxywalkself_simple
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+. ../support/simple_eval_tools.sh
+
+HEADER Proxy GETNEXT support: walk when proxying to self
+
+SKIPIFNOT USING_UCD_SNMP_PROXY_MODULE
+SKIPIFNOT USING_MIBII_SYSTEM_MIB_MODULE
+SKIPIF NETSNMP_DISABLE_SNMPV2C
+
+# XXX: ucd-snmp/proxy doesn't properly support TCP -- remove this once it does
+[ "x$SNMP_TRANSPORT_SPEC" = "xtcp" -o "x$SNMP_TRANSPORT_SPEC" = "xtcp6" ] && SKIP Test does not support TCP
+
+#
+# Begin test
+#
+
+OID=.1.3.6.1.4.1.8072.42
+
+# standard v2c configuration
+. ./Sv2cconfig
+# config the proxy to proxy to itself
+CONFIGAGENT proxy -v 2c -c testcommunity $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT $OID .1.3.6.1.2.1.1
+
+# Start the agent with proxy debugging
+ORIG_AGENT_FLAGS="$AGENT_FLAGS"
+AGENT_FLAGS="$ORIG_AGENT_FLAGS -Dproxy"
+STARTAGENT
+
+# Check that we get a string from the proxied sysObjectID
+CAPTURE "snmpgetnext -On $SNMP_FLAGS -v 2c -c testcommunity $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT $OID"
+
+# TODO: can we compare with the real sysDescr?
+CHECK "${OID}.1.0 = STRING: "
+
+# Check that we can walk without a non-increasing error
+CAPTURE "snmpwalk -On $SNMP_FLAGS -v 2c -c testcommunity $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT $OID"
+
+CHECKANDDIE "Error: OID not increasing"
+CHECKCOUNT atleastone "^${OID}"
+
+# Also check the same for a table underneath the proxy OID itself
+# using the sysORTable
+CAPTURE "snmpwalk -On $SNMP_FLAGS -v 2c -c testcommunity $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT ${OID}.9"
+
+CHECKANDDIE "Error: OID not increasing"
+CHECKCOUNT atleastone "^${OID}.9."
+
+
+# stop the agent
+STOPAGENT
+
+# all done (whew)
+FINISHED
diff --git a/testing/fulltests/default/T132snmpv3vacmget_simple b/testing/fulltests/default/T132snmpv3vacmget_simple
index 004d0dd..6c3e120 100644
--- a/testing/fulltests/default/T132snmpv3vacmget_simple
+++ b/testing/fulltests/default/T132snmpv3vacmget_simple
@@ -14,7 +14,7 @@ HEADER SNMPv3 vacm acceptance support
 #This case test for successful access
 
 snmp_version=v3
-. ./Sv3vacmconfig
+. ./Sv3vacmconfigMD5
 
 STARTAGENT
 
diff --git a/testing/fulltests/default/T142snmpv3vacmgetfail_simple b/testing/fulltests/default/T142snmpv3vacmgetfail_simple
index cfc000b..d2fda21 100644
--- a/testing/fulltests/default/T142snmpv3vacmgetfail_simple
+++ b/testing/fulltests/default/T142snmpv3vacmgetfail_simple
@@ -14,7 +14,7 @@ HEADER SNMPv3 vacm denial support
 #This case test for denied access
 
 snmp_version=v3
-. ./Sv3vacmconfig
+. ./Sv3vacmconfigMD5
 
 STARTAGENT
 
diff --git a/testing/fulltests/default/T155dismanexprmib_simple b/testing/fulltests/default/T155dismanexprmib_simple
new file mode 100644
index 0000000..a35be8a
--- /dev/null
+++ b/testing/fulltests/default/T155dismanexprmib_simple
@@ -0,0 +1,89 @@
+#!/bin/sh
+
+. ../support/simple_eval_tools.sh
+
+HEADER DISMAN EXPRESSION MIB
+
+ISDEFINED USING_DISMAN_EXPRESSION_EXPEXPRESSIONTABLE_MODULE ||
+ISDEFINED USING_DISMAN_EXPRESSION_MODULE ||
+SKIP "DISMAN EXPRESSION MIB is not available"
+
+# SNMPv2-TC
+active=1
+createAndWait=5
+destroy=6
+# Test configuration
+# expExpressionOwner and expExpressionName
+on='"foo"."bar"'
+
+#
+# Begin test
+#
+
+# standard V3 configuration
+snmp_write_access='all'
+. ./Sv3config
+
+CONFIGAGENT "createUser    internal"
+CONFIGAGENT "iquerySecName internal"
+CONFIGAGENT "rouser        internal"
+
+AGENT_FLAGS="$AGENT_FLAGS -DexpValueTable -Ddisman:expr:run"
+
+STARTAGENT
+
+capture_snmpset() {
+    CAPTURE "snmpset $SNMP_FLAGS $NOAUTHTESTARGS                 \
+         $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT $*"
+}
+
+capture_snmpget() {
+    CAPTURE "snmpget $SNMP_FLAGS $NOAUTHTESTARGS                 \
+         $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT $*"
+}
+
+capture_snmpwalk() {
+    CAPTURE "snmpwalk $SNMP_FLAGS $NOAUTHTESTARGS                \
+         $SNMP_TRANSPORT_SPEC:$SNMP_TEST_DEST$SNMP_SNMPD_PORT $*"
+}
+
+capture_snmpset DISMAN-EXPRESSION-MIB::expExpressionEntryStatus."${on}" \
+    i $destroy
+CHECK "^DISMAN-EXPRESSION-MIB::expExpressionEntryStatus.${on} = INTEGER: destroy(6)"
+capture_snmpset DISMAN-EXPRESSION-MIB::expExpressionEntryStatus."${on}" \
+    i $createAndWait
+CHECK "^DISMAN-EXPRESSION-MIB::expExpressionEntryStatus.${on} = INTEGER: createAndWait(5)"
+capture_snmpset DISMAN-EXPRESSION-MIB::expExpression."${on}"            \
+    = '$1+$2*($1+$2*($1+$2))'
+CHECK "^DISMAN-EXPRESSION-MIB::expExpression.${on} = STRING: "
+capture_snmpset DISMAN-EXPRESSION-MIB::expExpressionValueType."${on}"   \
+    = counter32
+CHECK "^DISMAN-EXPRESSION-MIB::expExpressionValueType.${on} = INTEGER: counter32(1)"
+capture_snmpset DISMAN-EXPRESSION-MIB::expExpressionEntryStatus."${on}" \
+    i $active
+CHECK "^DISMAN-EXPRESSION-MIB::expExpressionEntryStatus.${on} = INTEGER: active(1)"
+
+i=1
+for e in IF-MIB::ifIndex.1 IF-MIB::ifIndex.2; do
+    capture_snmpset DISMAN-EXPRESSION-MIB::expObjectEntryStatus."${on}".$i \
+        i $destroy
+    CHECK "^DISMAN-EXPRESSION-MIB::expObjectEntryStatus.${on}.$i = INTEGER: destroy(6)"
+    capture_snmpset DISMAN-EXPRESSION-MIB::expObjectEntryStatus."${on}".$i \
+        = createAndWait
+    CHECK "^DISMAN-EXPRESSION-MIB::expObjectEntryStatus.${on}.$i = INTEGER: createAndWait(5)"
+    capture_snmpset DISMAN-EXPRESSION-MIB::expObjectID."${on}".$i          \
+        = $e
+    CHECK "^DISMAN-EXPRESSION-MIB::expObjectID.${on}.$i = OID: $e"
+    capture_snmpset DISMAN-EXPRESSION-MIB::expObjectEntryStatus."${on}".$i \
+        i $active
+    CHECK "^DISMAN-EXPRESSION-MIB::expObjectEntryStatus.${on}.$i = INTEGER: active(1)"
+    i=`expr $i + 1`
+done
+
+capture_snmpget DISMAN-EXPRESSION-MIB::expValueCounter32Val."${on}".0.0.0
+
+CHECK "^DISMAN-EXPRESSION-MIB::expValueCounter32Val.${on}.0.0.0 = Counter32: 15"
+
+STOPAGENT
+
+FINISHED
diff --git a/testing/fulltests/snmpv3/T010scapitest_capp.c b/testing/fulltests/snmpv3/T010scapitest_capp.c
index ee794a7..7d00ad8 100644
--- a/testing/fulltests/snmpv3/T010scapitest_capp.c
+++ b/testing/fulltests/snmpv3/T010scapitest_capp.c
@@ -115,19 +115,6 @@ int             doalltests = 0, docrypt = 0, dokeyedhash = 0, dorandom = 0;
 #define MLCOUNT_MAX	6       /* MAC Length Count Maximum. */
 
 
-
-/*
- * Prototypes.
- */
-void            usage(void);
-
-int             test_docrypt(void);
-int             test_dokeyedhash(void);
-int             test_dorandom(void);
-
-
-
-
 int
 main(int argc, char **argv)
 {
diff --git a/testing/fulltests/snmpv3/T020hashtests_capp.c b/testing/fulltests/snmpv3/T020hashtests_capp.c
index 9cb5b47..a17625e 100644
--- a/testing/fulltests/snmpv3/T020hashtests_capp.c
+++ b/testing/fulltests/snmpv3/T020hashtests_capp.c
@@ -4,8 +4,6 @@
 
 #include <stdio.h>
 
-void print_hash(const char *label, u_char *MAC, size_t MAC_LEN);
-
 
 int
 main(int argc, char **argv) {
diff --git a/testing/fulltests/snmpv3/T040keymanagetest_capp.c b/testing/fulltests/snmpv3/T040keymanagetest_capp.c
index d68f663..305ed67 100644
--- a/testing/fulltests/snmpv3/T040keymanagetest_capp.c
+++ b/testing/fulltests/snmpv3/T040keymanagetest_capp.c
@@ -103,18 +103,6 @@ const u_char   *newkey = NULL;
 int             bequiet = 0;
 
 
-/*
- * Prototypes.
- */
-void            usage(FILE * ofp);
-
-int             test_genkul(void);
-int             test_genKu(void);
-int             test_keychange(void);
-
-
-
-
 int
 main(int argc, char **argv)
 {
diff --git a/testing/fulltests/snmpv3/T050etimetest_capp.c b/testing/fulltests/snmpv3/T050etimetest_capp.c
index 53951aa..2d4c60d 100644
--- a/testing/fulltests/snmpv3/T050etimetest_capp.c
+++ b/testing/fulltests/snmpv3/T050etimetest_capp.c
@@ -95,19 +95,6 @@ int             sleeptime = 2;
 #define BLAT "alk;djf;an riu;alicenmrul;aiknglksajhe1 adcfalcenrco2"
 
 
-
-
-/*
- * Prototypes.
- */
-void            usage(FILE * ofp);
-
-int             test_etime(void);
-int             test_hashindex(void);
-
-
-
-
 int
 main(int argc, char **argv)
 {
diff --git a/testing/fulltests/support/simple_TESTCONF.sh b/testing/fulltests/support/simple_TESTCONF.sh
index 2a0a8af..2b2fe35 100644
--- a/testing/fulltests/support/simple_TESTCONF.sh
+++ b/testing/fulltests/support/simple_TESTCONF.sh
@@ -196,6 +196,9 @@ elif test -x /cygdrive/c/windows/system32/netstat ; then
 elif test -x /c/Windows/System32/netstat ; then
     # MinGW + MSYS
     NETSTAT=/c/Windows/System32/netstat
+elif test -x /usr/sbin/ss ; then
+    # Fedora24, RHEL7 does not install netstat as standard
+    NETSTAT=/usr/sbin/ss
 else
     NETSTAT=""
 fi
diff --git a/testing/fulltests/support/simple_eval_tools.sh b/testing/fulltests/support/simple_eval_tools.sh
index 718edc4..4d3beb4 100644
--- a/testing/fulltests/support/simple_eval_tools.sh
+++ b/testing/fulltests/support/simple_eval_tools.sh
@@ -214,7 +214,7 @@ KNORG
 
 	fi
 	echo "RUNNING: $*" > $junkoutputfile
-	( $* 2>&1 ) >> $junkoutputfile 2>&1
+	( $DYNAMIC_ANALYZER $* 2>&1 ) >> $junkoutputfile 2>&1
 	RC=$?
 
 	if [ $SNMP_VERBOSE -gt 1 ]; then
diff --git a/testing/fulltests/unit-tests/T004snmp_enum_clib.c b/testing/fulltests/unit-tests/T004snmp_enum_clib.c
index d28b19b..5df00c5 100644
--- a/testing/fulltests/unit-tests/T004snmp_enum_clib.c
+++ b/testing/fulltests/unit-tests/T004snmp_enum_clib.c
@@ -82,8 +82,7 @@ OK(strcmp(se_find_label_in_slist("testing", 2), STRING2) == 0,
 se_clear_slist("testing");
 
 
-se_read_conf("enum",
-             NETSNMP_REMOVE_CONST(char *, "2:3 1:apple 2:pear 3:kiwifruit"));
+se_read_conf("enum", "2:3 1:apple 2:pear 3:kiwifruit");
 OK(se_find_list(2, 3), "list (2, 3) should be present");
 if (se_find_list(2, 3)) {
   OK(se_find_value(2, 3, "kiwifruit") == 3,
@@ -93,8 +92,7 @@ if (se_find_list(2, 3)) {
      "lookup by label should return the proper string");
 }
 
-se_read_conf("enum",
-             NETSNMP_REMOVE_CONST(char *, "fruit 1:apple 2:pear 3:kiwifruit"));
+se_read_conf("enum", "fruit 1:apple 2:pear 3:kiwifruit");
 OK(se_find_value_in_slist("fruit", "kiwifruit") == 3,
    "lookup by string should return the proper value");
 se_find_result = se_find_label_in_slist("fruit", 2);
diff --git a/testing/fulltests/unit-tests/T011snmp_old_api_registration_cagentlib.c b/testing/fulltests/unit-tests/T011snmp_old_api_registration_cagentlib.c
index 6f1d449..2c1d084 100644
--- a/testing/fulltests/unit-tests/T011snmp_old_api_registration_cagentlib.c
+++ b/testing/fulltests/unit-tests/T011snmp_old_api_registration_cagentlib.c
@@ -41,6 +41,6 @@ netsnmp_register_old_api("exp.327.b",
                          0, /* range_ubound */
                          sess,
                          "context", 5/*timeout*/, 0/*flags - ignored*/);
-OK(res == SNMPERR_SUCCESS, "Handler registration (2).");
+OK(res == MIB_DUPLICATE_REGISTRATION, "Handler registration (2).");
 
 snmp_shutdown("snmp");
diff --git a/testing/fulltests/unit-tests/T014gethostbyaddr_clib.c b/testing/fulltests/unit-tests/T014gethostbyaddr_clib.c
index 41a578e..13a2b5f 100644
--- a/testing/fulltests/unit-tests/T014gethostbyaddr_clib.c
+++ b/testing/fulltests/unit-tests/T014gethostbyaddr_clib.c
@@ -56,6 +56,7 @@ SOCK_STARTUP;
     if (s >= 0) {
         if (bind(s, (struct sockaddr *) &sin6_addr, sizeof(sin6_addr)) >=
             0) {
+            addr = NULL;
             strcpy(buf, "(failed)");
             h = netsnmp_gethostbyaddr(&v6loop, sizeof(v6loop), AF_INET6);
             if (h) {
@@ -74,18 +75,18 @@ SOCK_STARTUP;
                     }
                     if (!ap)
                         strcpy(buf, "no AF_INET6 address found");
-                    if (addr)
-                        freeaddrinfo(addr);
                 } else {
                     snprintf(buf, sizeof(buf), "getaddrinfo() failed: %s",
                              strerror(errno));
                 }
             }
             OKF(h && (strcmp(h->h_name, "localhost") == 0 ||
-                      (res == 0 && memcmp(addr->ai_addr, &sin6_addr,
-                                          sizeof(sin6_addr)) == 0)),
+                      (res == 0 && addr && memcmp(addr->ai_addr, &sin6_addr,
+                                                  sizeof(sin6_addr)) == 0)),
                 ("::1 lookup (%s -> %s)", h ? h->h_name : "(failed)",
                  buf));
+            if (addr)
+                freeaddrinfo(addr);
             ran_test = 1;
         }
         close(s);
diff --git a/testing/fulltests/unit-tests/T015int64_clib.c b/testing/fulltests/unit-tests/T015int64_clib.c
index 5f5f4b6..66f66b7 100644
--- a/testing/fulltests/unit-tests/T015int64_clib.c
+++ b/testing/fulltests/unit-tests/T015int64_clib.c
@@ -1,4 +1,4 @@
-/* HEADER Testing 64-bit integer operations (U64). */
+/* HEADER Testing 64-bit integer operations (struct counter64). */
 
 int i, j;
 char buf[22];
@@ -15,7 +15,7 @@ static const int64_t intval[] = {
 };
 
 for (i = 0; i < sizeof(intval)/sizeof(intval[0]); ++i) {
-    U64 a, b;
+    struct counter64 a, b;
     a.low = (uint32_t)intval[i];
     a.high = (uint32_t)(intval[i] >> 32);
     printI64(buf, &a);
@@ -27,7 +27,7 @@ for (i = 0; i < sizeof(intval)/sizeof(intval[0]); ++i) {
 
 for (i = 0; i < sizeof(intval)/sizeof(intval[0]); ++i) {
     for (j = i; j < sizeof(intval)/sizeof(intval[0]); ++j) {
-        U64 a, b;
+        struct counter64 a, b;
         uint64_t d;
         a.low = (uint32_t)intval[i];
         a.high = (uint32_t)(intval[i] >> 32);
@@ -43,7 +43,7 @@ for (i = 0; i < sizeof(intval)/sizeof(intval[0]); ++i) {
         
 for (i = 0; i < sizeof(intval)/sizeof(intval[0]); ++i) {
     for (j = i; j < sizeof(intval)/sizeof(intval[0]); ++j) {
-        U64 a, b, c;
+        struct counter64 a, b, c;
         uint64_t d;
         a.low = (uint32_t)intval[i];
         a.high = (uint32_t)(intval[i] >> 32);
@@ -58,7 +58,7 @@ for (i = 0; i < sizeof(intval)/sizeof(intval[0]); ++i) {
 }
         
 {
-    U64 old_val, new_val;
+    struct counter64 old_val, new_val;
     old_val.low = 7;
     old_val.high = 0;
     new_val = old_val;
diff --git a/testing/fulltests/unit-tests/T102pdu_build_clib.c b/testing/fulltests/unit-tests/T102pdu_build_clib.c
index 1fba69e..c1a5547 100644
--- a/testing/fulltests/unit-tests/T102pdu_build_clib.c
+++ b/testing/fulltests/unit-tests/T102pdu_build_clib.c
@@ -8,11 +8,6 @@ size_t packet_len, offset = 0;
 netsnmp_session session, *ss;
 int rc;
 
-/* prototype copied from snmp_api.c */
-int             snmp_build(u_char ** pkt, size_t * pkt_len,
-                           size_t * offset, netsnmp_session * pss,
-                           netsnmp_pdu *pdu);
-
 init_snmp("testing");
 snmp_sess_init(&session);
 session.version = SNMP_VERSION_2c;
diff --git a/win32/Makefile-apps.in b/win32/Makefile-apps.in
index bcfb26e..45f19a2 100644
--- a/win32/Makefile-apps.in
+++ b/win32/Makefile-apps.in
@@ -32,7 +32,7 @@ CLEAN :
     if not exist "$(INTDIR)/$(NULL)" mkdir "$(INTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /EHsc /Zi /O2 /I "." /I ".." /I "..\..\snmplib" /I "..\.." /I "..\..\include" /D "WIN32" /D "_BIND_TO_CURRENT_VCLIBS_VERSION" /D "NDEBUG" /D "_CONSOLE" /D "_CRT_SECURE_NO_WARNINGS" /D "_CRT_NONSTDC_NO_WARNINGS" /D "_MBCS" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\$(PROGNAME).pdb" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /EHsc /Zi /O2 /I "." /I ".." /I "..\..\snmplib" /I "..\.." /I "..\..\include" /D "WIN32" /D "_BIND_TO_CURRENT_VCLIBS_VERSION" /D "NDEBUG" /D "_CONSOLE" /D "_CRT_SECURE_NO_WARNINGS" /D "_CRT_NONSTDC_NO_WARNINGS" /D "_WINSOCK_DEPRECATED_NO_WARNINGS" /D "_MBCS" /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\$(PROGNAME).pdb" /FD /c
 
 !IF "$(LINKTYPE)" == "dynamic"
 CPP_PROJ=$(CPP_PROJ) /D "NMAKE_NETSNMP_USE_DLL"
diff --git a/win32/build.pl b/win32/build.pl
index 4007fae..2d03350 100644
--- a/win32/build.pl
+++ b/win32/build.pl
@@ -13,6 +13,7 @@ use constant false => 0;
 use constant true => 1;
 my $target_arch = $ENV{TARGET_CPU} ? $ENV{TARGET_CPU} : $ENV{Platform} ?
                   $ENV{Platform} : "x86";
+$target_arch = lc $target_arch;
 if ($target_arch ne "x86" && $target_arch ne "x64") {
     print "Error: unsupported target architecture $target_arch\n";
     die;
@@ -168,13 +169,13 @@ $configOpts .= $debug ? "--config=debug" : "--config=release";
 $ENV{NO_EXTERNAL_DEPS}="1";
 
 # Set PATH environment variable so Perl make tests can locate the DLL
-$ENV{PATH} = "$current_pwd\\bin\\" . ($debug ? "debug" : "release" ) . ";$ENV{PATH}";
+$ENV{PATH} = File::Spec->catdir($current_pwd, "bin", $debug ? "debug" : "release") . ";$ENV{PATH}";
 
 $ENV{INCLUDE} .= ";$opensslincdir";
 $ENV{LIB}     .= ";$openssllibdir";
 
 # Set MIBDIRS environment variable so Perl make tests can locate the mibs
-$ENV{MIBDIRS} = dirname($current_pwd) . "/mibs";
+$ENV{MIBDIRS} = File::Spec->catdir(dirname($current_pwd), "mibs");
 
 # Set SNMPCONFPATH environment variable so Perl conf.t test can locate
 # the configuration files.
@@ -203,6 +204,9 @@ print "Building main package...\n";
 system("nmake /nologo" . ($logging ? " > make.out 2>&1" : "")) == 0 || die ($logging ? "Build error (see make.out)" : "Build error (see above)");
 
 if ($perl) {
+  if ($Config{'ccname'} =~ /^gcc/) {
+    die "The perl interpreter has been built with gcc instead of MSVC. Giving up.\n";
+  }
   if (!$link_dynamic) {
     print "Running Configure for DLL...\n";
     system("perl Configure $configOpts --linktype=dynamic --prefix=\"$install_base\"" . ($logging ? " > perlconfigure.out 2>&1" : "")) == 0 || die ($logging ? "Build error (see perlconfigure.out)" : "Build error (see above)");
diff --git a/win32/net-snmp/net-snmp-config.h b/win32/net-snmp/net-snmp-config.h
index 1608563..040d913 100644
--- a/win32/net-snmp/net-snmp-config.h
+++ b/win32/net-snmp/net-snmp-config.h
@@ -5,6 +5,7 @@
 #define NET_SNMP_CONFIG_H
 
 /* _MSC_VER values
+   1900 = MSCV++ 14.0 (Visual Studio 2015)
    1800 = MSVC++ 12.0 (Visual Studio 2013)
    1700 = MSVC++ 11.0 (Visual Studio 2012)
    1600 = MSVC++ 10.0 (Visual Studio 2010)
@@ -1644,7 +1645,7 @@ enum {
 #if defined(_MSC_VER) && _MSC_VER < 1500
 #define vsnprintf _vsnprintf
 #endif
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && _MSC_VER < 1900
 #define snprintf  _snprintf
 #endif
 
@@ -1687,15 +1688,31 @@ enum {
 #  if defined(NETSNMP_USE_OPENSSL)
 #    ifdef _DLL
 #      ifdef _DEBUG
-#        pragma comment(lib, "libeay32MDd.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MDd.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MDd.lib")
+#        endif
 #      else
-#        pragma comment(lib, "libeay32MD.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MD.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MD.lib")
+#        endif
 #      endif
 #    else
 #      ifdef _DEBUG
-#        pragma comment(lib, "libeay32MTd.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MTd.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MTd.lib")
+#        endif
 #      else
-#        pragma comment(lib, "libeay32MT.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MT.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MT.lib")
+#        endif
 #      endif
 #    endif
 #    pragma comment(lib, "gdi32.lib")
@@ -1726,7 +1743,7 @@ enum {
 #define       LOG_DAEMON      (3<<3)  /* system daemons */
 #endif
 
-#if UCD_COMPATIBLE
+#ifdef UCD_COMPATIBLE
 /* old and in the way */
 #define EXTENSIBLEMIB NETSNMP_UCDAVIS_MIB
 #endif
diff --git a/win32/net-snmp/net-snmp-config.h.in b/win32/net-snmp/net-snmp-config.h.in
index 9693730..cb877d1 100644
--- a/win32/net-snmp/net-snmp-config.h.in
+++ b/win32/net-snmp/net-snmp-config.h.in
@@ -5,6 +5,7 @@
 #define NET_SNMP_CONFIG_H
 
 /* _MSC_VER values
+   1900 = MSCV++ 14.0 (Visual Studio 2015)
    1800 = MSVC++ 12.0 (Visual Studio 2013)
    1700 = MSVC++ 11.0 (Visual Studio 2012)
    1600 = MSVC++ 10.0 (Visual Studio 2010)
@@ -1644,7 +1645,7 @@ enum {
 #if defined(_MSC_VER) && _MSC_VER < 1500
 #define vsnprintf _vsnprintf
 #endif
-#ifdef _MSC_VER
+#if defined(_MSC_VER) && _MSC_VER < 1900
 #define snprintf  _snprintf
 #endif
 
@@ -1687,15 +1688,31 @@ enum {
 #  if defined(NETSNMP_USE_OPENSSL)
 #    ifdef _DLL
 #      ifdef _DEBUG
-#        pragma comment(lib, "libeay32MDd.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MDd.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MDd.lib")
+#        endif
 #      else
-#        pragma comment(lib, "libeay32MD.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MD.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MD.lib")
+#        endif
 #      endif
 #    else
 #      ifdef _DEBUG
-#        pragma comment(lib, "libeay32MTd.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MTd.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MTd.lib")
+#        endif
 #      else
-#        pragma comment(lib, "libeay32MT.lib")
+#        ifdef OPENSSL_BEFORE_1_1_0
+#          pragma comment(lib, "libeay32MT.lib")
+#        else
+#          pragma comment(lib, "libcrypto32MT.lib")
+#        endif
 #      endif
 #    endif
 #    pragma comment(lib, "gdi32.lib")
@@ -1726,7 +1743,7 @@ enum {
 #define       LOG_DAEMON      (3<<3)  /* system daemons */
 #endif
 
-#if UCD_COMPATIBLE
+#ifdef UCD_COMPATIBLE
 /* old and in the way */
 #define EXTENSIBLEMIB NETSNMP_UCDAVIS_MIB
 #endif
@@ -1761,7 +1778,7 @@ enum {
 
 /* Define to 1 if you have the `strtoull' function. */
 #if _MSC_VER >= 1800
-#define HAVE_STRTOULL
+#define HAVE_STRTOULL 1
 #else
 /* #undef HAVE_STRTOULL */
 #endif
